var myLibrary =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ((function(modules) {
	// Check all modules for deduplicated modules
	for(var i in modules) {
		if(Object.prototype.hasOwnProperty.call(modules, i)) {
			switch(typeof modules[i]) {
			case "function": break;
			case "object":
				// Module can be created from a template
				modules[i] = (function(_m) {
					var args = _m.slice(1), fn = modules[_m[0]];
					return function (a,b,c) {
						fn.apply(this, [a,b,c].concat(args));
					};
				}(modules[i]));
				break;
			default:
				// Module is a copy of another module
				modules[i] = modules[modules[i]];
				break;
			}
		}
	}
	return modules;
}([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(1);
	module.exports = __webpack_require__(2);


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

	(function (global, factory) {
	   true ? factory(exports) :
	  typeof define === 'function' && define.amd ? define(['exports'], factory) :
	  (factory((global.WHATWGFetch = {})));
	}(this, (function (exports) { 'use strict';
	
	  var support = {
	    searchParams: 'URLSearchParams' in self,
	    iterable: 'Symbol' in self && 'iterator' in Symbol,
	    blob:
	      'FileReader' in self &&
	      'Blob' in self &&
	      (function() {
	        try {
	          new Blob();
	          return true
	        } catch (e) {
	          return false
	        }
	      })(),
	    formData: 'FormData' in self,
	    arrayBuffer: 'ArrayBuffer' in self
	  };
	
	  function isDataView(obj) {
	    return obj && DataView.prototype.isPrototypeOf(obj)
	  }
	
	  if (support.arrayBuffer) {
	    var viewClasses = [
	      '[object Int8Array]',
	      '[object Uint8Array]',
	      '[object Uint8ClampedArray]',
	      '[object Int16Array]',
	      '[object Uint16Array]',
	      '[object Int32Array]',
	      '[object Uint32Array]',
	      '[object Float32Array]',
	      '[object Float64Array]'
	    ];
	
	    var isArrayBufferView =
	      ArrayBuffer.isView ||
	      function(obj) {
	        return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1
	      };
	  }
	
	  function normalizeName(name) {
	    if (typeof name !== 'string') {
	      name = String(name);
	    }
	    if (/[^a-z0-9\-#$%&'*+.^_`|~]/i.test(name)) {
	      throw new TypeError('Invalid character in header field name')
	    }
	    return name.toLowerCase()
	  }
	
	  function normalizeValue(value) {
	    if (typeof value !== 'string') {
	      value = String(value);
	    }
	    return value
	  }
	
	  // Build a destructive iterator for the value list
	  function iteratorFor(items) {
	    var iterator = {
	      next: function() {
	        var value = items.shift();
	        return {done: value === undefined, value: value}
	      }
	    };
	
	    if (support.iterable) {
	      iterator[Symbol.iterator] = function() {
	        return iterator
	      };
	    }
	
	    return iterator
	  }
	
	  function Headers(headers) {
	    this.map = {};
	
	    if (headers instanceof Headers) {
	      headers.forEach(function(value, name) {
	        this.append(name, value);
	      }, this);
	    } else if (Array.isArray(headers)) {
	      headers.forEach(function(header) {
	        this.append(header[0], header[1]);
	      }, this);
	    } else if (headers) {
	      Object.getOwnPropertyNames(headers).forEach(function(name) {
	        this.append(name, headers[name]);
	      }, this);
	    }
	  }
	
	  Headers.prototype.append = function(name, value) {
	    name = normalizeName(name);
	    value = normalizeValue(value);
	    var oldValue = this.map[name];
	    this.map[name] = oldValue ? oldValue + ', ' + value : value;
	  };
	
	  Headers.prototype['delete'] = function(name) {
	    delete this.map[normalizeName(name)];
	  };
	
	  Headers.prototype.get = function(name) {
	    name = normalizeName(name);
	    return this.has(name) ? this.map[name] : null
	  };
	
	  Headers.prototype.has = function(name) {
	    return this.map.hasOwnProperty(normalizeName(name))
	  };
	
	  Headers.prototype.set = function(name, value) {
	    this.map[normalizeName(name)] = normalizeValue(value);
	  };
	
	  Headers.prototype.forEach = function(callback, thisArg) {
	    for (var name in this.map) {
	      if (this.map.hasOwnProperty(name)) {
	        callback.call(thisArg, this.map[name], name, this);
	      }
	    }
	  };
	
	  Headers.prototype.keys = function() {
	    var items = [];
	    this.forEach(function(value, name) {
	      items.push(name);
	    });
	    return iteratorFor(items)
	  };
	
	  Headers.prototype.values = function() {
	    var items = [];
	    this.forEach(function(value) {
	      items.push(value);
	    });
	    return iteratorFor(items)
	  };
	
	  Headers.prototype.entries = function() {
	    var items = [];
	    this.forEach(function(value, name) {
	      items.push([name, value]);
	    });
	    return iteratorFor(items)
	  };
	
	  if (support.iterable) {
	    Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
	  }
	
	  function consumed(body) {
	    if (body.bodyUsed) {
	      return Promise.reject(new TypeError('Already read'))
	    }
	    body.bodyUsed = true;
	  }
	
	  function fileReaderReady(reader) {
	    return new Promise(function(resolve, reject) {
	      reader.onload = function() {
	        resolve(reader.result);
	      };
	      reader.onerror = function() {
	        reject(reader.error);
	      };
	    })
	  }
	
	  function readBlobAsArrayBuffer(blob) {
	    var reader = new FileReader();
	    var promise = fileReaderReady(reader);
	    reader.readAsArrayBuffer(blob);
	    return promise
	  }
	
	  function readBlobAsText(blob) {
	    var reader = new FileReader();
	    var promise = fileReaderReady(reader);
	    reader.readAsText(blob);
	    return promise
	  }
	
	  function readArrayBufferAsText(buf) {
	    var view = new Uint8Array(buf);
	    var chars = new Array(view.length);
	
	    for (var i = 0; i < view.length; i++) {
	      chars[i] = String.fromCharCode(view[i]);
	    }
	    return chars.join('')
	  }
	
	  function bufferClone(buf) {
	    if (buf.slice) {
	      return buf.slice(0)
	    } else {
	      var view = new Uint8Array(buf.byteLength);
	      view.set(new Uint8Array(buf));
	      return view.buffer
	    }
	  }
	
	  function Body() {
	    this.bodyUsed = false;
	
	    this._initBody = function(body) {
	      this._bodyInit = body;
	      if (!body) {
	        this._bodyText = '';
	      } else if (typeof body === 'string') {
	        this._bodyText = body;
	      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
	        this._bodyBlob = body;
	      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
	        this._bodyFormData = body;
	      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
	        this._bodyText = body.toString();
	      } else if (support.arrayBuffer && support.blob && isDataView(body)) {
	        this._bodyArrayBuffer = bufferClone(body.buffer);
	        // IE 10-11 can't handle a DataView body.
	        this._bodyInit = new Blob([this._bodyArrayBuffer]);
	      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
	        this._bodyArrayBuffer = bufferClone(body);
	      } else {
	        this._bodyText = body = Object.prototype.toString.call(body);
	      }
	
	      if (!this.headers.get('content-type')) {
	        if (typeof body === 'string') {
	          this.headers.set('content-type', 'text/plain;charset=UTF-8');
	        } else if (this._bodyBlob && this._bodyBlob.type) {
	          this.headers.set('content-type', this._bodyBlob.type);
	        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
	          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
	        }
	      }
	    };
	
	    if (support.blob) {
	      this.blob = function() {
	        var rejected = consumed(this);
	        if (rejected) {
	          return rejected
	        }
	
	        if (this._bodyBlob) {
	          return Promise.resolve(this._bodyBlob)
	        } else if (this._bodyArrayBuffer) {
	          return Promise.resolve(new Blob([this._bodyArrayBuffer]))
	        } else if (this._bodyFormData) {
	          throw new Error('could not read FormData body as blob')
	        } else {
	          return Promise.resolve(new Blob([this._bodyText]))
	        }
	      };
	
	      this.arrayBuffer = function() {
	        if (this._bodyArrayBuffer) {
	          return consumed(this) || Promise.resolve(this._bodyArrayBuffer)
	        } else {
	          return this.blob().then(readBlobAsArrayBuffer)
	        }
	      };
	    }
	
	    this.text = function() {
	      var rejected = consumed(this);
	      if (rejected) {
	        return rejected
	      }
	
	      if (this._bodyBlob) {
	        return readBlobAsText(this._bodyBlob)
	      } else if (this._bodyArrayBuffer) {
	        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))
	      } else if (this._bodyFormData) {
	        throw new Error('could not read FormData body as text')
	      } else {
	        return Promise.resolve(this._bodyText)
	      }
	    };
	
	    if (support.formData) {
	      this.formData = function() {
	        return this.text().then(decode)
	      };
	    }
	
	    this.json = function() {
	      return this.text().then(JSON.parse)
	    };
	
	    return this
	  }
	
	  // HTTP methods whose capitalization should be normalized
	  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];
	
	  function normalizeMethod(method) {
	    var upcased = method.toUpperCase();
	    return methods.indexOf(upcased) > -1 ? upcased : method
	  }
	
	  function Request(input, options) {
	    options = options || {};
	    var body = options.body;
	
	    if (input instanceof Request) {
	      if (input.bodyUsed) {
	        throw new TypeError('Already read')
	      }
	      this.url = input.url;
	      this.credentials = input.credentials;
	      if (!options.headers) {
	        this.headers = new Headers(input.headers);
	      }
	      this.method = input.method;
	      this.mode = input.mode;
	      this.signal = input.signal;
	      if (!body && input._bodyInit != null) {
	        body = input._bodyInit;
	        input.bodyUsed = true;
	      }
	    } else {
	      this.url = String(input);
	    }
	
	    this.credentials = options.credentials || this.credentials || 'same-origin';
	    if (options.headers || !this.headers) {
	      this.headers = new Headers(options.headers);
	    }
	    this.method = normalizeMethod(options.method || this.method || 'GET');
	    this.mode = options.mode || this.mode || null;
	    this.signal = options.signal || this.signal;
	    this.referrer = null;
	
	    if ((this.method === 'GET' || this.method === 'HEAD') && body) {
	      throw new TypeError('Body not allowed for GET or HEAD requests')
	    }
	    this._initBody(body);
	  }
	
	  Request.prototype.clone = function() {
	    return new Request(this, {body: this._bodyInit})
	  };
	
	  function decode(body) {
	    var form = new FormData();
	    body
	      .trim()
	      .split('&')
	      .forEach(function(bytes) {
	        if (bytes) {
	          var split = bytes.split('=');
	          var name = split.shift().replace(/\+/g, ' ');
	          var value = split.join('=').replace(/\+/g, ' ');
	          form.append(decodeURIComponent(name), decodeURIComponent(value));
	        }
	      });
	    return form
	  }
	
	  function parseHeaders(rawHeaders) {
	    var headers = new Headers();
	    // Replace instances of \r\n and \n followed by at least one space or horizontal tab with a space
	    // https://tools.ietf.org/html/rfc7230#section-3.2
	    var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, ' ');
	    preProcessedHeaders.split(/\r?\n/).forEach(function(line) {
	      var parts = line.split(':');
	      var key = parts.shift().trim();
	      if (key) {
	        var value = parts.join(':').trim();
	        headers.append(key, value);
	      }
	    });
	    return headers
	  }
	
	  Body.call(Request.prototype);
	
	  function Response(bodyInit, options) {
	    if (!options) {
	      options = {};
	    }
	
	    this.type = 'default';
	    this.status = options.status === undefined ? 200 : options.status;
	    this.ok = this.status >= 200 && this.status < 300;
	    this.statusText = 'statusText' in options ? options.statusText : 'OK';
	    this.headers = new Headers(options.headers);
	    this.url = options.url || '';
	    this._initBody(bodyInit);
	  }
	
	  Body.call(Response.prototype);
	
	  Response.prototype.clone = function() {
	    return new Response(this._bodyInit, {
	      status: this.status,
	      statusText: this.statusText,
	      headers: new Headers(this.headers),
	      url: this.url
	    })
	  };
	
	  Response.error = function() {
	    var response = new Response(null, {status: 0, statusText: ''});
	    response.type = 'error';
	    return response
	  };
	
	  var redirectStatuses = [301, 302, 303, 307, 308];
	
	  Response.redirect = function(url, status) {
	    if (redirectStatuses.indexOf(status) === -1) {
	      throw new RangeError('Invalid status code')
	    }
	
	    return new Response(null, {status: status, headers: {location: url}})
	  };
	
	  exports.DOMException = self.DOMException;
	  try {
	    new exports.DOMException();
	  } catch (err) {
	    exports.DOMException = function(message, name) {
	      this.message = message;
	      this.name = name;
	      var error = Error(message);
	      this.stack = error.stack;
	    };
	    exports.DOMException.prototype = Object.create(Error.prototype);
	    exports.DOMException.prototype.constructor = exports.DOMException;
	  }
	
	  function fetch(input, init) {
	    return new Promise(function(resolve, reject) {
	      var request = new Request(input, init);
	
	      if (request.signal && request.signal.aborted) {
	        return reject(new exports.DOMException('Aborted', 'AbortError'))
	      }
	
	      var xhr = new XMLHttpRequest();
	
	      function abortXhr() {
	        xhr.abort();
	      }
	
	      xhr.onload = function() {
	        var options = {
	          status: xhr.status,
	          statusText: xhr.statusText,
	          headers: parseHeaders(xhr.getAllResponseHeaders() || '')
	        };
	        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');
	        var body = 'response' in xhr ? xhr.response : xhr.responseText;
	        resolve(new Response(body, options));
	      };
	
	      xhr.onerror = function() {
	        reject(new TypeError('Network request failed'));
	      };
	
	      xhr.ontimeout = function() {
	        reject(new TypeError('Network request failed'));
	      };
	
	      xhr.onabort = function() {
	        reject(new exports.DOMException('Aborted', 'AbortError'));
	      };
	
	      xhr.open(request.method, request.url, true);
	
	      if (request.credentials === 'include') {
	        xhr.withCredentials = true;
	      } else if (request.credentials === 'omit') {
	        xhr.withCredentials = false;
	      }
	
	      if ('responseType' in xhr && support.blob) {
	        xhr.responseType = 'blob';
	      }
	
	      request.headers.forEach(function(value, name) {
	        xhr.setRequestHeader(name, value);
	      });
	
	      if (request.signal) {
	        request.signal.addEventListener('abort', abortXhr);
	
	        xhr.onreadystatechange = function() {
	          // DONE (success or failure)
	          if (xhr.readyState === 4) {
	            request.signal.removeEventListener('abort', abortXhr);
	          }
	        };
	      }
	
	      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);
	    })
	  }
	
	  fetch.polyfill = true;
	
	  if (!self.fetch) {
	    self.fetch = fetch;
	    self.Headers = Headers;
	    self.Request = Request;
	    self.Response = Response;
	  }
	
	  exports.Headers = Headers;
	  exports.Request = Request;
	  exports.Response = Response;
	  exports.fetch = fetch;
	
	  Object.defineProperty(exports, '__esModule', { value: true });
	
	})));


/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

	var req = __webpack_require__(3);
	var req2 = __webpack_require__(36);
	
	req.keys().forEach(function(key){
	    req(key);
	});
	
	req2.keys().forEach(function(key){
	    req2(key);
	});

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

	var map = {
		"./ajax-button.js": 4,
		"./calendar.js": 5,
		"./chosen.js": 8,
		"./chosen.order.jquery.js": 10,
		"./custom-scroll.js": 11,
		"./dotdotdot-init.js": 16,
		"./flip.js": 18,
		"./form.js": 20,
		"./jquery.datetimepicker.full.js": 22,
		"./knob.js": 23,
		"./magnific-popup.js": 25,
		"./owl-carousel-init.js": 27,
		"./reshMultiselect.js": 30,
		"./scroll-width.js": 31,
		"./svg4everybody-init.js": 32,
		"./tooltips.js": 34
	};
	function webpackContext(req) {
		return __webpack_require__(webpackContextResolve(req));
	};
	function webpackContextResolve(req) {
		return map[req] || (function() { throw new Error("Cannot find module '" + req + "'.") }());
	};
	webpackContext.keys = function webpackContextKeys() {
		return Object.keys(map);
	};
	webpackContext.resolve = webpackContextResolve;
	module.exports = webpackContext;
	webpackContext.id = 3;


/***/ }),
/* 4 */
/***/ (function(module, exports) {

	const ajaxButtonPost = (url, data, button, success) => {
	    if (button.hasClass('ajax-executing') === true) {
	        return;
	    }
	    $.ajax({
	        type: "POST",
	        url: url,
	        data: data,
	        beforeSend: () => {
	            button.addClass('ajax-executing');
	            button.prop('disabled', true);
	        },
	        success: success,
	        complete: () => {
	            button.removeClass('ajax-executing');
	            button.prop('disabled', false);
	        }
	    });
	};
	
	module.exports = ajaxButtonPost;

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(6);
	
	var settings = {
	    changeYear: true,
	    changeMonth: true,
	    dateFormat: "dd.mm.yy",
	    yearRange: "-90:+0",
	    dayNamesMin: ['Вс', 'Пн', 'Вт', 'Ср', 'Чт', 'Пт', 'Сб'],
	    monthNamesShort: ["Янв", "Фев", "Мар", "Апр", "Май", "Июн", "Июл", "Авг", "Сен", "Окт", "Ноя", "Дек"],
	    monthNames: ["Январь", "Февраль", "Март", "Апрель", "Май", "Июнь", "Июль", "Август", "Сентябрь", "Октябрь", "Ноябрь", "Декабрь"]
	};
	
	$('.datepicker').datepicker(
	    settings
	);
	
	$('.lk-datepicker').datepicker(
	    $.extend(settings, {
	        showOn: "both",
	        buttonText: ""
	    })
	);
	
	
	$('.diary-datepicker-old').datepicker(
	    $.extend(settings, {
	        showOn: "both",
	        buttonText: "",
	        defaultDate: "-7d"
	    })
	);
	
	$('.diary-datepicker-new').datepicker(
	    $.extend(settings, {
	        showOn: "both",
	        buttonText: ""
	    })
	);
	
	
	$('#ui-datepicker-div').wrap("<div class='ll-skin-melon'></div>");
	
	// date format: dd.mm.yyyy
	function diaryDate(a) {
	    return d = a.getDate(), d < 10 ? x = "0" + d : x = d, m = a.getMonth() + 1, m < 10 ? i = "0" + m : i = m, x + "." + i + "." + a.getFullYear()
	}
	
	$('.lk-date-1').val(diaryDate(new Date(new Date().getTime() - 7 * 24 * 60 * 60 * 1000)));
	$('.lk-date-2').val(diaryDate(new Date()));

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*! jQuery UI - v1.12.0 - 2016-08-05
	* http://jqueryui.com
	* Includes: keycode.js, widgets/datepicker.js, effect.js, effects/effect-blind.js, effects/effect-bounce.js, effects/effect-clip.js, effects/effect-drop.js, effects/effect-explode.js, effects/effect-fade.js, effects/effect-fold.js, effects/effect-highlight.js, effects/effect-puff.js, effects/effect-pulsate.js, effects/effect-scale.js, effects/effect-size.js, effects/effect-slide.js, effects/effect-transfer.js
	* Copyright jQuery Foundation and other contributors; Licensed MIT */
	
	(function( factory ) {
		if ( true ) {
	
			// AMD. Register as an anonymous module.
			!(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(7) ], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		} else {
	
			// Browser globals
			factory( jQuery );
		}
	}(function( $ ) {
	
	$.ui = $.ui || {};
	
	var version = $.ui.version = "1.12.0";
	
	
	/*!
	 * jQuery UI Keycode 1.12.0
	 * http://jqueryui.com
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license.
	 * http://jquery.org/license
	 */
	
	//>>label: Keycode
	//>>group: Core
	//>>description: Provide keycodes as keynames
	//>>docs: http://api.jqueryui.com/jQuery.ui.keyCode/
	
	
	var keycode = $.ui.keyCode = {
		BACKSPACE: 8,
		COMMA: 188,
		DELETE: 46,
		DOWN: 40,
		END: 35,
		ENTER: 13,
		ESCAPE: 27,
		HOME: 36,
		LEFT: 37,
		PAGE_DOWN: 34,
		PAGE_UP: 33,
		PERIOD: 190,
		RIGHT: 39,
		SPACE: 32,
		TAB: 9,
		UP: 38
	};
	
	
	// jscs:disable maximumLineLength
	/* jscs:disable requireCamelCaseOrUpperCaseIdentifiers */
	/*!
	 * jQuery UI Datepicker 1.12.0
	 * http://jqueryui.com
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license.
	 * http://jquery.org/license
	 */
	
	//>>label: Datepicker
	//>>group: Widgets
	//>>description: Displays a calendar from an input or inline for selecting dates.
	//>>docs: http://api.jqueryui.com/datepicker/
	//>>demos: http://jqueryui.com/datepicker/
	//>>css.structure: ../../themes/base/core.css
	//>>css.structure: ../../themes/base/datepicker.css
	//>>css.theme: ../../themes/base/theme.css
	
	
	
	$.extend( $.ui, { datepicker: { version: "1.12.0" } } );
	
	var datepicker_instActive;
	
	function datepicker_getZindex( elem ) {
		var position, value;
		while ( elem.length && elem[ 0 ] !== document ) {
	
			// Ignore z-index if position is set to a value where z-index is ignored by the browser
			// This makes behavior of this function consistent across browsers
			// WebKit always returns auto if the element is positioned
			position = elem.css( "position" );
			if ( position === "absolute" || position === "relative" || position === "fixed" ) {
	
				// IE returns 0 when zIndex is not specified
				// other browsers return a string
				// we ignore the case of nested elements with an explicit value of 0
				// <div style="z-index: -10;"><div style="z-index: 0;"></div></div>
				value = parseInt( elem.css( "zIndex" ), 10 );
				if ( !isNaN( value ) && value !== 0 ) {
					return value;
				}
			}
			elem = elem.parent();
		}
	
		return 0;
	}
	/* Date picker manager.
	   Use the singleton instance of this class, $.datepicker, to interact with the date picker.
	   Settings for (groups of) date pickers are maintained in an instance object,
	   allowing multiple different settings on the same page. */
	
	function Datepicker() {
		this._curInst = null; // The current instance in use
		this._keyEvent = false; // If the last event was a key event
		this._disabledInputs = []; // List of date picker inputs that have been disabled
		this._datepickerShowing = false; // True if the popup picker is showing , false if not
		this._inDialog = false; // True if showing within a "dialog", false if not
		this._mainDivId = "ui-datepicker-div"; // The ID of the main datepicker division
		this._inlineClass = "ui-datepicker-inline"; // The name of the inline marker class
		this._appendClass = "ui-datepicker-append"; // The name of the append marker class
		this._triggerClass = "ui-datepicker-trigger"; // The name of the trigger marker class
		this._dialogClass = "ui-datepicker-dialog"; // The name of the dialog marker class
		this._disableClass = "ui-datepicker-disabled"; // The name of the disabled covering marker class
		this._unselectableClass = "ui-datepicker-unselectable"; // The name of the unselectable cell marker class
		this._currentClass = "ui-datepicker-current-day"; // The name of the current day marker class
		this._dayOverClass = "ui-datepicker-days-cell-over"; // The name of the day hover marker class
		this.regional = []; // Available regional settings, indexed by language code
		this.regional[ "" ] = { // Default regional settings
			closeText: "Done", // Display text for close link
			prevText: "Prev", // Display text for previous month link
			nextText: "Next", // Display text for next month link
			currentText: "Today", // Display text for current month link
			monthNames: [ "January","February","March","April","May","June",
				"July","August","September","October","November","December" ], // Names of months for drop-down and formatting
			monthNamesShort: [ "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" ], // For formatting
			dayNames: [ "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" ], // For formatting
			dayNamesShort: [ "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" ], // For formatting
			dayNamesMin: [ "Su","Mo","Tu","We","Th","Fr","Sa" ], // Column headings for days starting at Sunday
			weekHeader: "Wk", // Column header for week of the year
			dateFormat: "mm/dd/yy", // See format options on parseDate
			firstDay: 0, // The first day of the week, Sun = 0, Mon = 1, ...
			isRTL: false, // True if right-to-left language, false if left-to-right
			showMonthAfterYear: false, // True if the year select precedes month, false for month then year
			yearSuffix: "" // Additional text to append to the year in the month headers
		};
		this._defaults = { // Global defaults for all the date picker instances
			showOn: "focus", // "focus" for popup on focus,
				// "button" for trigger button, or "both" for either
			showAnim: "fadeIn", // Name of jQuery animation for popup
			showOptions: {}, // Options for enhanced animations
			defaultDate: null, // Used when field is blank: actual date,
				// +/-number for offset from today, null for today
			appendText: "", // Display text following the input box, e.g. showing the format
			buttonText: "...", // Text for trigger button
			buttonImage: "", // URL for trigger button image
			buttonImageOnly: false, // True if the image appears alone, false if it appears on a button
			hideIfNoPrevNext: false, // True to hide next/previous month links
				// if not applicable, false to just disable them
			navigationAsDateFormat: false, // True if date formatting applied to prev/today/next links
			gotoCurrent: false, // True if today link goes back to current selection instead
			changeMonth: false, // True if month can be selected directly, false if only prev/next
			changeYear: false, // True if year can be selected directly, false if only prev/next
			yearRange: "c-10:c+10", // Range of years to display in drop-down,
				// either relative to today's year (-nn:+nn), relative to currently displayed year
				// (c-nn:c+nn), absolute (nnnn:nnnn), or a combination of the above (nnnn:-n)
			showOtherMonths: false, // True to show dates in other months, false to leave blank
			selectOtherMonths: false, // True to allow selection of dates in other months, false for unselectable
			showWeek: false, // True to show week of the year, false to not show it
			calculateWeek: this.iso8601Week, // How to calculate the week of the year,
				// takes a Date and returns the number of the week for it
			shortYearCutoff: "+10", // Short year values < this are in the current century,
				// > this are in the previous century,
				// string value starting with "+" for current year + value
			minDate: null, // The earliest selectable date, or null for no limit
			maxDate: null, // The latest selectable date, or null for no limit
			duration: "fast", // Duration of display/closure
			beforeShowDay: null, // Function that takes a date and returns an array with
				// [0] = true if selectable, false if not, [1] = custom CSS class name(s) or "",
				// [2] = cell title (optional), e.g. $.datepicker.noWeekends
			beforeShow: null, // Function that takes an input field and
				// returns a set of custom settings for the date picker
			onSelect: null, // Define a callback function when a date is selected
			onChangeMonthYear: null, // Define a callback function when the month or year is changed
			onClose: null, // Define a callback function when the datepicker is closed
			numberOfMonths: 1, // Number of months to show at a time
			showCurrentAtPos: 0, // The position in multipe months at which to show the current month (starting at 0)
			stepMonths: 1, // Number of months to step back/forward
			stepBigMonths: 12, // Number of months to step back/forward for the big links
			altField: "", // Selector for an alternate field to store selected dates into
			altFormat: "", // The date format to use for the alternate field
			constrainInput: true, // The input is constrained by the current date format
			showButtonPanel: false, // True to show button panel, false to not show it
			autoSize: false, // True to size the input for the date format, false to leave as is
			disabled: false // The initial disabled state
		};
		$.extend( this._defaults, this.regional[ "" ] );
		this.regional.en = $.extend( true, {}, this.regional[ "" ] );
		this.regional[ "en-US" ] = $.extend( true, {}, this.regional.en );
		this.dpDiv = datepicker_bindHover( $( "<div id='" + this._mainDivId + "' class='ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>" ) );
	}
	
	$.extend( Datepicker.prototype, {
		/* Class name added to elements to indicate already configured with a date picker. */
		markerClassName: "hasDatepicker",
	
		//Keep track of the maximum number of rows displayed (see #7043)
		maxRows: 4,
	
		// TODO rename to "widget" when switching to widget factory
		_widgetDatepicker: function() {
			return this.dpDiv;
		},
	
		/* Override the default settings for all instances of the date picker.
		 * @param  settings  object - the new settings to use as defaults (anonymous object)
		 * @return the manager object
		 */
		setDefaults: function( settings ) {
			datepicker_extendRemove( this._defaults, settings || {} );
			return this;
		},
	
		/* Attach the date picker to a jQuery selection.
		 * @param  target	element - the target input field or division or span
		 * @param  settings  object - the new settings to use for this date picker instance (anonymous)
		 */
		_attachDatepicker: function( target, settings ) {
			var nodeName, inline, inst;
			nodeName = target.nodeName.toLowerCase();
			inline = ( nodeName === "div" || nodeName === "span" );
			if ( !target.id ) {
				this.uuid += 1;
				target.id = "dp" + this.uuid;
			}
			inst = this._newInst( $( target ), inline );
			inst.settings = $.extend( {}, settings || {} );
			if ( nodeName === "input" ) {
				this._connectDatepicker( target, inst );
			} else if ( inline ) {
				this._inlineDatepicker( target, inst );
			}
		},
	
		/* Create a new instance object. */
		_newInst: function( target, inline ) {
			var id = target[ 0 ].id.replace( /([^A-Za-z0-9_\-])/g, "\\\\$1" ); // escape jQuery meta chars
			return { id: id, input: target, // associated target
				selectedDay: 0, selectedMonth: 0, selectedYear: 0, // current selection
				drawMonth: 0, drawYear: 0, // month being drawn
				inline: inline, // is datepicker inline or not
				dpDiv: ( !inline ? this.dpDiv : // presentation div
				datepicker_bindHover( $( "<div class='" + this._inlineClass + " ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>" ) ) ) };
		},
	
		/* Attach the date picker to an input field. */
		_connectDatepicker: function( target, inst ) {
			var input = $( target );
			inst.append = $( [] );
			inst.trigger = $( [] );
			if ( input.hasClass( this.markerClassName ) ) {
				return;
			}
			this._attachments( input, inst );
			input.addClass( this.markerClassName ).on( "keydown", this._doKeyDown ).
				on( "keypress", this._doKeyPress ).on( "keyup", this._doKeyUp );
			this._autoSize( inst );
			$.data( target, "datepicker", inst );
	
			//If disabled option is true, disable the datepicker once it has been attached to the input (see ticket #5665)
			if ( inst.settings.disabled ) {
				this._disableDatepicker( target );
			}
		},
	
		/* Make attachments based on settings. */
		_attachments: function( input, inst ) {
			var showOn, buttonText, buttonImage,
				appendText = this._get( inst, "appendText" ),
				isRTL = this._get( inst, "isRTL" );
	
			if ( inst.append ) {
				inst.append.remove();
			}
			if ( appendText ) {
				inst.append = $( "<span class='" + this._appendClass + "'>" + appendText + "</span>" );
				input[ isRTL ? "before" : "after" ]( inst.append );
			}
	
			input.off( "focus", this._showDatepicker );
	
			if ( inst.trigger ) {
				inst.trigger.remove();
			}
	
			showOn = this._get( inst, "showOn" );
			if ( showOn === "focus" || showOn === "both" ) { // pop-up date picker when in the marked field
				input.on( "focus", this._showDatepicker );
			}
			if ( showOn === "button" || showOn === "both" ) { // pop-up date picker when button clicked
				buttonText = this._get( inst, "buttonText" );
				buttonImage = this._get( inst, "buttonImage" );
				inst.trigger = $( this._get( inst, "buttonImageOnly" ) ?
					$( "<img/>" ).addClass( this._triggerClass ).
						attr( { src: buttonImage, alt: buttonText, title: buttonText } ) :
					$( "<button type='button'></button>" ).addClass( this._triggerClass ).
						html( !buttonImage ? buttonText : $( "<img/>" ).attr(
						{ src:buttonImage, alt:buttonText, title:buttonText } ) ) );
				input[ isRTL ? "before" : "after" ]( inst.trigger );
				inst.trigger.on( "click", function() {
					if ( $.datepicker._datepickerShowing && $.datepicker._lastInput === input[ 0 ] ) {
						$.datepicker._hideDatepicker();
					} else if ( $.datepicker._datepickerShowing && $.datepicker._lastInput !== input[ 0 ] ) {
						$.datepicker._hideDatepicker();
						$.datepicker._showDatepicker( input[ 0 ] );
					} else {
						$.datepicker._showDatepicker( input[ 0 ] );
					}
					return false;
				} );
			}
		},
	
		/* Apply the maximum length for the date format. */
		_autoSize: function( inst ) {
			if ( this._get( inst, "autoSize" ) && !inst.inline ) {
				var findMax, max, maxI, i,
					date = new Date( 2009, 12 - 1, 20 ), // Ensure double digits
					dateFormat = this._get( inst, "dateFormat" );
	
				if ( dateFormat.match( /[DM]/ ) ) {
					findMax = function( names ) {
						max = 0;
						maxI = 0;
						for ( i = 0; i < names.length; i++ ) {
							if ( names[ i ].length > max ) {
								max = names[ i ].length;
								maxI = i;
							}
						}
						return maxI;
					};
					date.setMonth( findMax( this._get( inst, ( dateFormat.match( /MM/ ) ?
						"monthNames" : "monthNamesShort" ) ) ) );
					date.setDate( findMax( this._get( inst, ( dateFormat.match( /DD/ ) ?
						"dayNames" : "dayNamesShort" ) ) ) + 20 - date.getDay() );
				}
				inst.input.attr( "size", this._formatDate( inst, date ).length );
			}
		},
	
		/* Attach an inline date picker to a div. */
		_inlineDatepicker: function( target, inst ) {
			var divSpan = $( target );
			if ( divSpan.hasClass( this.markerClassName ) ) {
				return;
			}
			divSpan.addClass( this.markerClassName ).append( inst.dpDiv );
			$.data( target, "datepicker", inst );
			this._setDate( inst, this._getDefaultDate( inst ), true );
			this._updateDatepicker( inst );
			this._updateAlternate( inst );
	
			//If disabled option is true, disable the datepicker before showing it (see ticket #5665)
			if ( inst.settings.disabled ) {
				this._disableDatepicker( target );
			}
	
			// Set display:block in place of inst.dpDiv.show() which won't app on disconnected elements
			// http://bugs.jqueryui.com/ticket/7552 - A Datepicker created on a detached div has zero height
			inst.dpDiv.css( "display", "block" );
		},
	
		/* Pop-up the date picker in a "dialog" box.
		 * @param  input element - ignored
		 * @param  date	string or Date - the initial date to display
		 * @param  onSelect  function - the function to call when a date is selected
		 * @param  settings  object - update the dialog date picker instance's settings (anonymous object)
		 * @param  pos int[2] - coordinates for the dialog's position within the screen or
		 *					event - with x/y coordinates or
		 *					leave empty for default (screen centre)
		 * @return the manager object
		 */
		_dialogDatepicker: function( input, date, onSelect, settings, pos ) {
			var id, browserWidth, browserHeight, scrollX, scrollY,
				inst = this._dialogInst; // internal instance
	
			if ( !inst ) {
				this.uuid += 1;
				id = "dp" + this.uuid;
				this._dialogInput = $( "<input type='text' id='" + id +
					"' style='position: absolute; top: -100px; width: 0px;'/>" );
				this._dialogInput.on( "keydown", this._doKeyDown );
				$( "body" ).append( this._dialogInput );
				inst = this._dialogInst = this._newInst( this._dialogInput, false );
				inst.settings = {};
				$.data( this._dialogInput[ 0 ], "datepicker", inst );
			}
			datepicker_extendRemove( inst.settings, settings || {} );
			date = ( date && date.constructor === Date ? this._formatDate( inst, date ) : date );
			this._dialogInput.val( date );
	
			this._pos = ( pos ? ( pos.length ? pos : [ pos.pageX, pos.pageY ] ) : null );
			if ( !this._pos ) {
				browserWidth = document.documentElement.clientWidth;
				browserHeight = document.documentElement.clientHeight;
				scrollX = document.documentElement.scrollLeft || document.body.scrollLeft;
				scrollY = document.documentElement.scrollTop || document.body.scrollTop;
				this._pos = // should use actual width/height below
					[ ( browserWidth / 2 ) - 100 + scrollX, ( browserHeight / 2 ) - 150 + scrollY ];
			}
	
			// Move input on screen for focus, but hidden behind dialog
			this._dialogInput.css( "left", ( this._pos[ 0 ] + 20 ) + "px" ).css( "top", this._pos[ 1 ] + "px" );
			inst.settings.onSelect = onSelect;
			this._inDialog = true;
			this.dpDiv.addClass( this._dialogClass );
			this._showDatepicker( this._dialogInput[ 0 ] );
			if ( $.blockUI ) {
				$.blockUI( this.dpDiv );
			}
			$.data( this._dialogInput[ 0 ], "datepicker", inst );
			return this;
		},
	
		/* Detach a datepicker from its control.
		 * @param  target	element - the target input field or division or span
		 */
		_destroyDatepicker: function( target ) {
			var nodeName,
				$target = $( target ),
				inst = $.data( target, "datepicker" );
	
			if ( !$target.hasClass( this.markerClassName ) ) {
				return;
			}
	
			nodeName = target.nodeName.toLowerCase();
			$.removeData( target, "datepicker" );
			if ( nodeName === "input" ) {
				inst.append.remove();
				inst.trigger.remove();
				$target.removeClass( this.markerClassName ).
					off( "focus", this._showDatepicker ).
					off( "keydown", this._doKeyDown ).
					off( "keypress", this._doKeyPress ).
					off( "keyup", this._doKeyUp );
			} else if ( nodeName === "div" || nodeName === "span" ) {
				$target.removeClass( this.markerClassName ).empty();
			}
	
			if ( datepicker_instActive === inst ) {
				datepicker_instActive = null;
			}
		},
	
		/* Enable the date picker to a jQuery selection.
		 * @param  target	element - the target input field or division or span
		 */
		_enableDatepicker: function( target ) {
			var nodeName, inline,
				$target = $( target ),
				inst = $.data( target, "datepicker" );
	
			if ( !$target.hasClass( this.markerClassName ) ) {
				return;
			}
	
			nodeName = target.nodeName.toLowerCase();
			if ( nodeName === "input" ) {
				target.disabled = false;
				inst.trigger.filter( "button" ).
					each( function() { this.disabled = false; } ).end().
					filter( "img" ).css( { opacity: "1.0", cursor: "" } );
			} else if ( nodeName === "div" || nodeName === "span" ) {
				inline = $target.children( "." + this._inlineClass );
				inline.children().removeClass( "ui-state-disabled" );
				inline.find( "select.ui-datepicker-month, select.ui-datepicker-year" ).
					prop( "disabled", false );
			}
			this._disabledInputs = $.map( this._disabledInputs,
				function( value ) { return ( value === target ? null : value ); } ); // delete entry
		},
	
		/* Disable the date picker to a jQuery selection.
		 * @param  target	element - the target input field or division or span
		 */
		_disableDatepicker: function( target ) {
			var nodeName, inline,
				$target = $( target ),
				inst = $.data( target, "datepicker" );
	
			if ( !$target.hasClass( this.markerClassName ) ) {
				return;
			}
	
			nodeName = target.nodeName.toLowerCase();
			if ( nodeName === "input" ) {
				target.disabled = true;
				inst.trigger.filter( "button" ).
					each( function() { this.disabled = true; } ).end().
					filter( "img" ).css( { opacity: "0.5", cursor: "default" } );
			} else if ( nodeName === "div" || nodeName === "span" ) {
				inline = $target.children( "." + this._inlineClass );
				inline.children().addClass( "ui-state-disabled" );
				inline.find( "select.ui-datepicker-month, select.ui-datepicker-year" ).
					prop( "disabled", true );
			}
			this._disabledInputs = $.map( this._disabledInputs,
				function( value ) { return ( value === target ? null : value ); } ); // delete entry
			this._disabledInputs[ this._disabledInputs.length ] = target;
		},
	
		/* Is the first field in a jQuery collection disabled as a datepicker?
		 * @param  target	element - the target input field or division or span
		 * @return boolean - true if disabled, false if enabled
		 */
		_isDisabledDatepicker: function( target ) {
			if ( !target ) {
				return false;
			}
			for ( var i = 0; i < this._disabledInputs.length; i++ ) {
				if ( this._disabledInputs[ i ] === target ) {
					return true;
				}
			}
			return false;
		},
	
		/* Retrieve the instance data for the target control.
		 * @param  target  element - the target input field or division or span
		 * @return  object - the associated instance data
		 * @throws  error if a jQuery problem getting data
		 */
		_getInst: function( target ) {
			try {
				return $.data( target, "datepicker" );
			}
			catch ( err ) {
				throw "Missing instance data for this datepicker";
			}
		},
	
		/* Update or retrieve the settings for a date picker attached to an input field or division.
		 * @param  target  element - the target input field or division or span
		 * @param  name	object - the new settings to update or
		 *				string - the name of the setting to change or retrieve,
		 *				when retrieving also "all" for all instance settings or
		 *				"defaults" for all global defaults
		 * @param  value   any - the new value for the setting
		 *				(omit if above is an object or to retrieve a value)
		 */
		_optionDatepicker: function( target, name, value ) {
			var settings, date, minDate, maxDate,
				inst = this._getInst( target );
	
			if ( arguments.length === 2 && typeof name === "string" ) {
				return ( name === "defaults" ? $.extend( {}, $.datepicker._defaults ) :
					( inst ? ( name === "all" ? $.extend( {}, inst.settings ) :
					this._get( inst, name ) ) : null ) );
			}
	
			settings = name || {};
			if ( typeof name === "string" ) {
				settings = {};
				settings[ name ] = value;
			}
	
			if ( inst ) {
				if ( this._curInst === inst ) {
					this._hideDatepicker();
				}
	
				date = this._getDateDatepicker( target, true );
				minDate = this._getMinMaxDate( inst, "min" );
				maxDate = this._getMinMaxDate( inst, "max" );
				datepicker_extendRemove( inst.settings, settings );
	
				// reformat the old minDate/maxDate values if dateFormat changes and a new minDate/maxDate isn't provided
				if ( minDate !== null && settings.dateFormat !== undefined && settings.minDate === undefined ) {
					inst.settings.minDate = this._formatDate( inst, minDate );
				}
				if ( maxDate !== null && settings.dateFormat !== undefined && settings.maxDate === undefined ) {
					inst.settings.maxDate = this._formatDate( inst, maxDate );
				}
				if ( "disabled" in settings ) {
					if ( settings.disabled ) {
						this._disableDatepicker( target );
					} else {
						this._enableDatepicker( target );
					}
				}
				this._attachments( $( target ), inst );
				this._autoSize( inst );
				this._setDate( inst, date );
				this._updateAlternate( inst );
				this._updateDatepicker( inst );
			}
		},
	
		// Change method deprecated
		_changeDatepicker: function( target, name, value ) {
			this._optionDatepicker( target, name, value );
		},
	
		/* Redraw the date picker attached to an input field or division.
		 * @param  target  element - the target input field or division or span
		 */
		_refreshDatepicker: function( target ) {
			var inst = this._getInst( target );
			if ( inst ) {
				this._updateDatepicker( inst );
			}
		},
	
		/* Set the dates for a jQuery selection.
		 * @param  target element - the target input field or division or span
		 * @param  date	Date - the new date
		 */
		_setDateDatepicker: function( target, date ) {
			var inst = this._getInst( target );
			if ( inst ) {
				this._setDate( inst, date );
				this._updateDatepicker( inst );
				this._updateAlternate( inst );
			}
		},
	
		/* Get the date(s) for the first entry in a jQuery selection.
		 * @param  target element - the target input field or division or span
		 * @param  noDefault boolean - true if no default date is to be used
		 * @return Date - the current date
		 */
		_getDateDatepicker: function( target, noDefault ) {
			var inst = this._getInst( target );
			if ( inst && !inst.inline ) {
				this._setDateFromField( inst, noDefault );
			}
			return ( inst ? this._getDate( inst ) : null );
		},
	
		/* Handle keystrokes. */
		_doKeyDown: function( event ) {
			var onSelect, dateStr, sel,
				inst = $.datepicker._getInst( event.target ),
				handled = true,
				isRTL = inst.dpDiv.is( ".ui-datepicker-rtl" );
	
			inst._keyEvent = true;
			if ( $.datepicker._datepickerShowing ) {
				switch ( event.keyCode ) {
					case 9: $.datepicker._hideDatepicker();
							handled = false;
							break; // hide on tab out
					case 13: sel = $( "td." + $.datepicker._dayOverClass + ":not(." +
										$.datepicker._currentClass + ")", inst.dpDiv );
							if ( sel[ 0 ] ) {
								$.datepicker._selectDay( event.target, inst.selectedMonth, inst.selectedYear, sel[ 0 ] );
							}
	
							onSelect = $.datepicker._get( inst, "onSelect" );
							if ( onSelect ) {
								dateStr = $.datepicker._formatDate( inst );
	
								// Trigger custom callback
								onSelect.apply( ( inst.input ? inst.input[ 0 ] : null ), [ dateStr, inst ] );
							} else {
								$.datepicker._hideDatepicker();
							}
	
							return false; // don't submit the form
					case 27: $.datepicker._hideDatepicker();
							break; // hide on escape
					case 33: $.datepicker._adjustDate( event.target, ( event.ctrlKey ?
								-$.datepicker._get( inst, "stepBigMonths" ) :
								-$.datepicker._get( inst, "stepMonths" ) ), "M" );
							break; // previous month/year on page up/+ ctrl
					case 34: $.datepicker._adjustDate( event.target, ( event.ctrlKey ?
								+$.datepicker._get( inst, "stepBigMonths" ) :
								+$.datepicker._get( inst, "stepMonths" ) ), "M" );
							break; // next month/year on page down/+ ctrl
					case 35: if ( event.ctrlKey || event.metaKey ) {
								$.datepicker._clearDate( event.target );
							}
							handled = event.ctrlKey || event.metaKey;
							break; // clear on ctrl or command +end
					case 36: if ( event.ctrlKey || event.metaKey ) {
								$.datepicker._gotoToday( event.target );
							}
							handled = event.ctrlKey || event.metaKey;
							break; // current on ctrl or command +home
					case 37: if ( event.ctrlKey || event.metaKey ) {
								$.datepicker._adjustDate( event.target, ( isRTL ? +1 : -1 ), "D" );
							}
							handled = event.ctrlKey || event.metaKey;
	
							// -1 day on ctrl or command +left
							if ( event.originalEvent.altKey ) {
								$.datepicker._adjustDate( event.target, ( event.ctrlKey ?
									-$.datepicker._get( inst, "stepBigMonths" ) :
									-$.datepicker._get( inst, "stepMonths" ) ), "M" );
							}
	
							// next month/year on alt +left on Mac
							break;
					case 38: if ( event.ctrlKey || event.metaKey ) {
								$.datepicker._adjustDate( event.target, -7, "D" );
							}
							handled = event.ctrlKey || event.metaKey;
							break; // -1 week on ctrl or command +up
					case 39: if ( event.ctrlKey || event.metaKey ) {
								$.datepicker._adjustDate( event.target, ( isRTL ? -1 : +1 ), "D" );
							}
							handled = event.ctrlKey || event.metaKey;
	
							// +1 day on ctrl or command +right
							if ( event.originalEvent.altKey ) {
								$.datepicker._adjustDate( event.target, ( event.ctrlKey ?
									+$.datepicker._get( inst, "stepBigMonths" ) :
									+$.datepicker._get( inst, "stepMonths" ) ), "M" );
							}
	
							// next month/year on alt +right
							break;
					case 40: if ( event.ctrlKey || event.metaKey ) {
								$.datepicker._adjustDate( event.target, +7, "D" );
							}
							handled = event.ctrlKey || event.metaKey;
							break; // +1 week on ctrl or command +down
					default: handled = false;
				}
			} else if ( event.keyCode === 36 && event.ctrlKey ) { // display the date picker on ctrl+home
				$.datepicker._showDatepicker( this );
			} else {
				handled = false;
			}
	
			if ( handled ) {
				event.preventDefault();
				event.stopPropagation();
			}
		},
	
		/* Filter entered characters - based on date format. */
		_doKeyPress: function( event ) {
			var chars, chr,
				inst = $.datepicker._getInst( event.target );
	
			if ( $.datepicker._get( inst, "constrainInput" ) ) {
				chars = $.datepicker._possibleChars( $.datepicker._get( inst, "dateFormat" ) );
				chr = String.fromCharCode( event.charCode == null ? event.keyCode : event.charCode );
				return event.ctrlKey || event.metaKey || ( chr < " " || !chars || chars.indexOf( chr ) > -1 );
			}
		},
	
		/* Synchronise manual entry and field/alternate field. */
		_doKeyUp: function( event ) {
			var date,
				inst = $.datepicker._getInst( event.target );
	
			if ( inst.input.val() !== inst.lastVal ) {
				try {
					date = $.datepicker.parseDate( $.datepicker._get( inst, "dateFormat" ),
						( inst.input ? inst.input.val() : null ),
						$.datepicker._getFormatConfig( inst ) );
	
					if ( date ) { // only if valid
						$.datepicker._setDateFromField( inst );
						$.datepicker._updateAlternate( inst );
						$.datepicker._updateDatepicker( inst );
					}
				}
				catch ( err ) {
				}
			}
			return true;
		},
	
		/* Pop-up the date picker for a given input field.
		 * If false returned from beforeShow event handler do not show.
		 * @param  input  element - the input field attached to the date picker or
		 *					event - if triggered by focus
		 */
		_showDatepicker: function( input ) {
			input = input.target || input;
			if ( input.nodeName.toLowerCase() !== "input" ) { // find from button/image trigger
				input = $( "input", input.parentNode )[ 0 ];
			}
	
			if ( $.datepicker._isDisabledDatepicker( input ) || $.datepicker._lastInput === input ) { // already here
				return;
			}
	
			var inst, beforeShow, beforeShowSettings, isFixed,
				offset, showAnim, duration;
	
			inst = $.datepicker._getInst( input );
			if ( $.datepicker._curInst && $.datepicker._curInst !== inst ) {
				$.datepicker._curInst.dpDiv.stop( true, true );
				if ( inst && $.datepicker._datepickerShowing ) {
					$.datepicker._hideDatepicker( $.datepicker._curInst.input[ 0 ] );
				}
			}
	
			beforeShow = $.datepicker._get( inst, "beforeShow" );
			beforeShowSettings = beforeShow ? beforeShow.apply( input, [ input, inst ] ) : {};
			if ( beforeShowSettings === false ) {
				return;
			}
			datepicker_extendRemove( inst.settings, beforeShowSettings );
	
			inst.lastVal = null;
			$.datepicker._lastInput = input;
			$.datepicker._setDateFromField( inst );
	
			if ( $.datepicker._inDialog ) { // hide cursor
				input.value = "";
			}
			if ( !$.datepicker._pos ) { // position below input
				$.datepicker._pos = $.datepicker._findPos( input );
				$.datepicker._pos[ 1 ] += input.offsetHeight; // add the height
			}
	
			isFixed = false;
			$( input ).parents().each( function() {
				isFixed |= $( this ).css( "position" ) === "fixed";
				return !isFixed;
			} );
	
			offset = { left: $.datepicker._pos[ 0 ], top: $.datepicker._pos[ 1 ] };
			$.datepicker._pos = null;
	
			//to avoid flashes on Firefox
			inst.dpDiv.empty();
	
			// determine sizing offscreen
			inst.dpDiv.css( { position: "absolute", display: "block", top: "-1000px" } );
			$.datepicker._updateDatepicker( inst );
	
			// fix width for dynamic number of date pickers
			// and adjust position before showing
			offset = $.datepicker._checkOffset( inst, offset, isFixed );
			inst.dpDiv.css( { position: ( $.datepicker._inDialog && $.blockUI ?
				"static" : ( isFixed ? "fixed" : "absolute" ) ), display: "none",
				left: offset.left + "px", top: offset.top + "px" } );
	
			if ( !inst.inline ) {
				showAnim = $.datepicker._get( inst, "showAnim" );
				duration = $.datepicker._get( inst, "duration" );
				inst.dpDiv.css( "z-index", datepicker_getZindex( $( input ) ) + 1 );
				$.datepicker._datepickerShowing = true;
	
				if ( $.effects && $.effects.effect[ showAnim ] ) {
					inst.dpDiv.show( showAnim, $.datepicker._get( inst, "showOptions" ), duration );
				} else {
					inst.dpDiv[ showAnim || "show" ]( showAnim ? duration : null );
				}
	
				if ( $.datepicker._shouldFocusInput( inst ) ) {
					inst.input.trigger( "focus" );
				}
	
				$.datepicker._curInst = inst;
			}
		},
	
		/* Generate the date picker content. */
		_updateDatepicker: function( inst ) {
			this.maxRows = 4; //Reset the max number of rows being displayed (see #7043)
			datepicker_instActive = inst; // for delegate hover events
			inst.dpDiv.empty().append( this._generateHTML( inst ) );
			this._attachHandlers( inst );
	
			var origyearshtml,
				numMonths = this._getNumberOfMonths( inst ),
				cols = numMonths[ 1 ],
				width = 17,
				activeCell = inst.dpDiv.find( "." + this._dayOverClass + " a" );
	
			if ( activeCell.length > 0 ) {
				datepicker_handleMouseover.apply( activeCell.get( 0 ) );
			}
	
			inst.dpDiv.removeClass( "ui-datepicker-multi-2 ui-datepicker-multi-3 ui-datepicker-multi-4" ).width( "" );
			if ( cols > 1 ) {
				inst.dpDiv.addClass( "ui-datepicker-multi-" + cols ).css( "width", ( width * cols ) + "em" );
			}
			inst.dpDiv[ ( numMonths[ 0 ] !== 1 || numMonths[ 1 ] !== 1 ? "add" : "remove" ) +
				"Class" ]( "ui-datepicker-multi" );
			inst.dpDiv[ ( this._get( inst, "isRTL" ) ? "add" : "remove" ) +
				"Class" ]( "ui-datepicker-rtl" );
	
			if ( inst === $.datepicker._curInst && $.datepicker._datepickerShowing && $.datepicker._shouldFocusInput( inst ) ) {
				inst.input.trigger( "focus" );
			}
	
			// Deffered render of the years select (to avoid flashes on Firefox)
			if ( inst.yearshtml ) {
				origyearshtml = inst.yearshtml;
				setTimeout( function() {
	
					//assure that inst.yearshtml didn't change.
					if ( origyearshtml === inst.yearshtml && inst.yearshtml ) {
						inst.dpDiv.find( "select.ui-datepicker-year:first" ).replaceWith( inst.yearshtml );
					}
					origyearshtml = inst.yearshtml = null;
				}, 0 );
			}
		},
	
		// #6694 - don't focus the input if it's already focused
		// this breaks the change event in IE
		// Support: IE and jQuery <1.9
		_shouldFocusInput: function( inst ) {
			return inst.input && inst.input.is( ":visible" ) && !inst.input.is( ":disabled" ) && !inst.input.is( ":focus" );
		},
	
		/* Check positioning to remain on screen. */
		_checkOffset: function( inst, offset, isFixed ) {
			var dpWidth = inst.dpDiv.outerWidth(),
				dpHeight = inst.dpDiv.outerHeight(),
				inputWidth = inst.input ? inst.input.outerWidth() : 0,
				inputHeight = inst.input ? inst.input.outerHeight() : 0,
				viewWidth = document.documentElement.clientWidth + ( isFixed ? 0 : $( document ).scrollLeft() ),
				viewHeight = document.documentElement.clientHeight + ( isFixed ? 0 : $( document ).scrollTop() );
	
			offset.left -= ( this._get( inst, "isRTL" ) ? ( dpWidth - inputWidth ) : 0 );
			offset.left -= ( isFixed && offset.left === inst.input.offset().left ) ? $( document ).scrollLeft() : 0;
			offset.top -= ( isFixed && offset.top === ( inst.input.offset().top + inputHeight ) ) ? $( document ).scrollTop() : 0;
	
			// Now check if datepicker is showing outside window viewport - move to a better place if so.
			offset.left -= Math.min( offset.left, ( offset.left + dpWidth > viewWidth && viewWidth > dpWidth ) ?
				Math.abs( offset.left + dpWidth - viewWidth ) : 0 );
			offset.top -= Math.min( offset.top, ( offset.top + dpHeight > viewHeight && viewHeight > dpHeight ) ?
				Math.abs( dpHeight + inputHeight ) : 0 );
	
			return offset;
		},
	
		/* Find an object's position on the screen. */
		_findPos: function( obj ) {
			var position,
				inst = this._getInst( obj ),
				isRTL = this._get( inst, "isRTL" );
	
			while ( obj && ( obj.type === "hidden" || obj.nodeType !== 1 || $.expr.filters.hidden( obj ) ) ) {
				obj = obj[ isRTL ? "previousSibling" : "nextSibling" ];
			}
	
			position = $( obj ).offset();
			return [ position.left, position.top ];
		},
	
		/* Hide the date picker from view.
		 * @param  input  element - the input field attached to the date picker
		 */
		_hideDatepicker: function( input ) {
			var showAnim, duration, postProcess, onClose,
				inst = this._curInst;
	
			if ( !inst || ( input && inst !== $.data( input, "datepicker" ) ) ) {
				return;
			}
	
			if ( this._datepickerShowing ) {
				showAnim = this._get( inst, "showAnim" );
				duration = this._get( inst, "duration" );
				postProcess = function() {
					$.datepicker._tidyDialog( inst );
				};
	
				// DEPRECATED: after BC for 1.8.x $.effects[ showAnim ] is not needed
				if ( $.effects && ( $.effects.effect[ showAnim ] || $.effects[ showAnim ] ) ) {
					inst.dpDiv.hide( showAnim, $.datepicker._get( inst, "showOptions" ), duration, postProcess );
				} else {
					inst.dpDiv[ ( showAnim === "slideDown" ? "slideUp" :
						( showAnim === "fadeIn" ? "fadeOut" : "hide" ) ) ]( ( showAnim ? duration : null ), postProcess );
				}
	
				if ( !showAnim ) {
					postProcess();
				}
				this._datepickerShowing = false;
	
				onClose = this._get( inst, "onClose" );
				if ( onClose ) {
					onClose.apply( ( inst.input ? inst.input[ 0 ] : null ), [ ( inst.input ? inst.input.val() : "" ), inst ] );
				}
	
				this._lastInput = null;
				if ( this._inDialog ) {
					this._dialogInput.css( { position: "absolute", left: "0", top: "-100px" } );
					if ( $.blockUI ) {
						$.unblockUI();
						$( "body" ).append( this.dpDiv );
					}
				}
				this._inDialog = false;
			}
		},
	
		/* Tidy up after a dialog display. */
		_tidyDialog: function( inst ) {
			inst.dpDiv.removeClass( this._dialogClass ).off( ".ui-datepicker-calendar" );
		},
	
		/* Close date picker if clicked elsewhere. */
		_checkExternalClick: function( event ) {
			if ( !$.datepicker._curInst ) {
				return;
			}
	
			var $target = $( event.target ),
				inst = $.datepicker._getInst( $target[ 0 ] );
	
			if ( ( ( $target[ 0 ].id !== $.datepicker._mainDivId &&
					$target.parents( "#" + $.datepicker._mainDivId ).length === 0 &&
					!$target.hasClass( $.datepicker.markerClassName ) &&
					!$target.closest( "." + $.datepicker._triggerClass ).length &&
					$.datepicker._datepickerShowing && !( $.datepicker._inDialog && $.blockUI ) ) ) ||
				( $target.hasClass( $.datepicker.markerClassName ) && $.datepicker._curInst !== inst ) ) {
					$.datepicker._hideDatepicker();
			}
		},
	
		/* Adjust one of the date sub-fields. */
		_adjustDate: function( id, offset, period ) {
			var target = $( id ),
				inst = this._getInst( target[ 0 ] );
	
			if ( this._isDisabledDatepicker( target[ 0 ] ) ) {
				return;
			}
			this._adjustInstDate( inst, offset +
				( period === "M" ? this._get( inst, "showCurrentAtPos" ) : 0 ), // undo positioning
				period );
			this._updateDatepicker( inst );
		},
	
		/* Action for current link. */
		_gotoToday: function( id ) {
			var date,
				target = $( id ),
				inst = this._getInst( target[ 0 ] );
	
			if ( this._get( inst, "gotoCurrent" ) && inst.currentDay ) {
				inst.selectedDay = inst.currentDay;
				inst.drawMonth = inst.selectedMonth = inst.currentMonth;
				inst.drawYear = inst.selectedYear = inst.currentYear;
			} else {
				date = new Date();
				inst.selectedDay = date.getDate();
				inst.drawMonth = inst.selectedMonth = date.getMonth();
				inst.drawYear = inst.selectedYear = date.getFullYear();
			}
			this._notifyChange( inst );
			this._adjustDate( target );
		},
	
		/* Action for selecting a new month/year. */
		_selectMonthYear: function( id, select, period ) {
			var target = $( id ),
				inst = this._getInst( target[ 0 ] );
	
			inst[ "selected" + ( period === "M" ? "Month" : "Year" ) ] =
			inst[ "draw" + ( period === "M" ? "Month" : "Year" ) ] =
				parseInt( select.options[ select.selectedIndex ].value, 10 );
	
			this._notifyChange( inst );
			this._adjustDate( target );
		},
	
		/* Action for selecting a day. */
		_selectDay: function( id, month, year, td ) {
			var inst,
				target = $( id );
	
			if ( $( td ).hasClass( this._unselectableClass ) || this._isDisabledDatepicker( target[ 0 ] ) ) {
				return;
			}
	
			inst = this._getInst( target[ 0 ] );
			inst.selectedDay = inst.currentDay = $( "a", td ).html();
			inst.selectedMonth = inst.currentMonth = month;
			inst.selectedYear = inst.currentYear = year;
			this._selectDate( id, this._formatDate( inst,
				inst.currentDay, inst.currentMonth, inst.currentYear ) );
		},
	
		/* Erase the input field and hide the date picker. */
		_clearDate: function( id ) {
			var target = $( id );
			this._selectDate( target, "" );
		},
	
		/* Update the input field with the selected date. */
		_selectDate: function( id, dateStr ) {
			var onSelect,
				target = $( id ),
				inst = this._getInst( target[ 0 ] );
	
			dateStr = ( dateStr != null ? dateStr : this._formatDate( inst ) );
			if ( inst.input ) {
				inst.input.val( dateStr );
			}
			this._updateAlternate( inst );
	
			onSelect = this._get( inst, "onSelect" );
			if ( onSelect ) {
				onSelect.apply( ( inst.input ? inst.input[ 0 ] : null ), [ dateStr, inst ] );  // trigger custom callback
			} else if ( inst.input ) {
				inst.input.trigger( "change" ); // fire the change event
			}
	
			if ( inst.inline ) {
				this._updateDatepicker( inst );
			} else {
				this._hideDatepicker();
				this._lastInput = inst.input[ 0 ];
				if ( typeof( inst.input[ 0 ] ) !== "object" ) {
					inst.input.trigger( "focus" ); // restore focus
				}
				this._lastInput = null;
			}
		},
	
		/* Update any alternate field to synchronise with the main field. */
		_updateAlternate: function( inst ) {
			var altFormat, date, dateStr,
				altField = this._get( inst, "altField" );
	
			if ( altField ) { // update alternate field too
				altFormat = this._get( inst, "altFormat" ) || this._get( inst, "dateFormat" );
				date = this._getDate( inst );
				dateStr = this.formatDate( altFormat, date, this._getFormatConfig( inst ) );
				$( altField ).val( dateStr );
			}
		},
	
		/* Set as beforeShowDay function to prevent selection of weekends.
		 * @param  date  Date - the date to customise
		 * @return [boolean, string] - is this date selectable?, what is its CSS class?
		 */
		noWeekends: function( date ) {
			var day = date.getDay();
			return [ ( day > 0 && day < 6 ), "" ];
		},
	
		/* Set as calculateWeek to determine the week of the year based on the ISO 8601 definition.
		 * @param  date  Date - the date to get the week for
		 * @return  number - the number of the week within the year that contains this date
		 */
		iso8601Week: function( date ) {
			var time,
				checkDate = new Date( date.getTime() );
	
			// Find Thursday of this week starting on Monday
			checkDate.setDate( checkDate.getDate() + 4 - ( checkDate.getDay() || 7 ) );
	
			time = checkDate.getTime();
			checkDate.setMonth( 0 ); // Compare with Jan 1
			checkDate.setDate( 1 );
			return Math.floor( Math.round( ( time - checkDate ) / 86400000 ) / 7 ) + 1;
		},
	
		/* Parse a string value into a date object.
		 * See formatDate below for the possible formats.
		 *
		 * @param  format string - the expected format of the date
		 * @param  value string - the date in the above format
		 * @param  settings Object - attributes include:
		 *					shortYearCutoff  number - the cutoff year for determining the century (optional)
		 *					dayNamesShort	string[7] - abbreviated names of the days from Sunday (optional)
		 *					dayNames		string[7] - names of the days from Sunday (optional)
		 *					monthNamesShort string[12] - abbreviated names of the months (optional)
		 *					monthNames		string[12] - names of the months (optional)
		 * @return  Date - the extracted date value or null if value is blank
		 */
		parseDate: function( format, value, settings ) {
			if ( format == null || value == null ) {
				throw "Invalid arguments";
			}
	
			value = ( typeof value === "object" ? value.toString() : value + "" );
			if ( value === "" ) {
				return null;
			}
	
			var iFormat, dim, extra,
				iValue = 0,
				shortYearCutoffTemp = ( settings ? settings.shortYearCutoff : null ) || this._defaults.shortYearCutoff,
				shortYearCutoff = ( typeof shortYearCutoffTemp !== "string" ? shortYearCutoffTemp :
					new Date().getFullYear() % 100 + parseInt( shortYearCutoffTemp, 10 ) ),
				dayNamesShort = ( settings ? settings.dayNamesShort : null ) || this._defaults.dayNamesShort,
				dayNames = ( settings ? settings.dayNames : null ) || this._defaults.dayNames,
				monthNamesShort = ( settings ? settings.monthNamesShort : null ) || this._defaults.monthNamesShort,
				monthNames = ( settings ? settings.monthNames : null ) || this._defaults.monthNames,
				year = -1,
				month = -1,
				day = -1,
				doy = -1,
				literal = false,
				date,
	
				// Check whether a format character is doubled
				lookAhead = function( match ) {
					var matches = ( iFormat + 1 < format.length && format.charAt( iFormat + 1 ) === match );
					if ( matches ) {
						iFormat++;
					}
					return matches;
				},
	
				// Extract a number from the string value
				getNumber = function( match ) {
					var isDoubled = lookAhead( match ),
						size = ( match === "@" ? 14 : ( match === "!" ? 20 :
						( match === "y" && isDoubled ? 4 : ( match === "o" ? 3 : 2 ) ) ) ),
						minSize = ( match === "y" ? size : 1 ),
						digits = new RegExp( "^\\d{" + minSize + "," + size + "}" ),
						num = value.substring( iValue ).match( digits );
					if ( !num ) {
						throw "Missing number at position " + iValue;
					}
					iValue += num[ 0 ].length;
					return parseInt( num[ 0 ], 10 );
				},
	
				// Extract a name from the string value and convert to an index
				getName = function( match, shortNames, longNames ) {
					var index = -1,
						names = $.map( lookAhead( match ) ? longNames : shortNames, function( v, k ) {
							return [ [ k, v ] ];
						} ).sort( function( a, b ) {
							return -( a[ 1 ].length - b[ 1 ].length );
						} );
	
					$.each( names, function( i, pair ) {
						var name = pair[ 1 ];
						if ( value.substr( iValue, name.length ).toLowerCase() === name.toLowerCase() ) {
							index = pair[ 0 ];
							iValue += name.length;
							return false;
						}
					} );
					if ( index !== -1 ) {
						return index + 1;
					} else {
						throw "Unknown name at position " + iValue;
					}
				},
	
				// Confirm that a literal character matches the string value
				checkLiteral = function() {
					if ( value.charAt( iValue ) !== format.charAt( iFormat ) ) {
						throw "Unexpected literal at position " + iValue;
					}
					iValue++;
				};
	
			for ( iFormat = 0; iFormat < format.length; iFormat++ ) {
				if ( literal ) {
					if ( format.charAt( iFormat ) === "'" && !lookAhead( "'" ) ) {
						literal = false;
					} else {
						checkLiteral();
					}
				} else {
					switch ( format.charAt( iFormat ) ) {
						case "d":
							day = getNumber( "d" );
							break;
						case "D":
							getName( "D", dayNamesShort, dayNames );
							break;
						case "o":
							doy = getNumber( "o" );
							break;
						case "m":
							month = getNumber( "m" );
							break;
						case "M":
							month = getName( "M", monthNamesShort, monthNames );
							break;
						case "y":
							year = getNumber( "y" );
							break;
						case "@":
							date = new Date( getNumber( "@" ) );
							year = date.getFullYear();
							month = date.getMonth() + 1;
							day = date.getDate();
							break;
						case "!":
							date = new Date( ( getNumber( "!" ) - this._ticksTo1970 ) / 10000 );
							year = date.getFullYear();
							month = date.getMonth() + 1;
							day = date.getDate();
							break;
						case "'":
							if ( lookAhead( "'" ) ) {
								checkLiteral();
							} else {
								literal = true;
							}
							break;
						default:
							checkLiteral();
					}
				}
			}
	
			if ( iValue < value.length ) {
				extra = value.substr( iValue );
				if ( !/^\s+/.test( extra ) ) {
					throw "Extra/unparsed characters found in date: " + extra;
				}
			}
	
			if ( year === -1 ) {
				year = new Date().getFullYear();
			} else if ( year < 100 ) {
				year += new Date().getFullYear() - new Date().getFullYear() % 100 +
					( year <= shortYearCutoff ? 0 : -100 );
			}
	
			if ( doy > -1 ) {
				month = 1;
				day = doy;
				do {
					dim = this._getDaysInMonth( year, month - 1 );
					if ( day <= dim ) {
						break;
					}
					month++;
					day -= dim;
				} while ( true );
			}
	
			date = this._daylightSavingAdjust( new Date( year, month - 1, day ) );
			if ( date.getFullYear() !== year || date.getMonth() + 1 !== month || date.getDate() !== day ) {
				throw "Invalid date"; // E.g. 31/02/00
			}
			return date;
		},
	
		/* Standard date formats. */
		ATOM: "yy-mm-dd", // RFC 3339 (ISO 8601)
		COOKIE: "D, dd M yy",
		ISO_8601: "yy-mm-dd",
		RFC_822: "D, d M y",
		RFC_850: "DD, dd-M-y",
		RFC_1036: "D, d M y",
		RFC_1123: "D, d M yy",
		RFC_2822: "D, d M yy",
		RSS: "D, d M y", // RFC 822
		TICKS: "!",
		TIMESTAMP: "@",
		W3C: "yy-mm-dd", // ISO 8601
	
		_ticksTo1970: ( ( ( 1970 - 1 ) * 365 + Math.floor( 1970 / 4 ) - Math.floor( 1970 / 100 ) +
			Math.floor( 1970 / 400 ) ) * 24 * 60 * 60 * 10000000 ),
	
		/* Format a date object into a string value.
		 * The format can be combinations of the following:
		 * d  - day of month (no leading zero)
		 * dd - day of month (two digit)
		 * o  - day of year (no leading zeros)
		 * oo - day of year (three digit)
		 * D  - day name short
		 * DD - day name long
		 * m  - month of year (no leading zero)
		 * mm - month of year (two digit)
		 * M  - month name short
		 * MM - month name long
		 * y  - year (two digit)
		 * yy - year (four digit)
		 * @ - Unix timestamp (ms since 01/01/1970)
		 * ! - Windows ticks (100ns since 01/01/0001)
		 * "..." - literal text
		 * '' - single quote
		 *
		 * @param  format string - the desired format of the date
		 * @param  date Date - the date value to format
		 * @param  settings Object - attributes include:
		 *					dayNamesShort	string[7] - abbreviated names of the days from Sunday (optional)
		 *					dayNames		string[7] - names of the days from Sunday (optional)
		 *					monthNamesShort string[12] - abbreviated names of the months (optional)
		 *					monthNames		string[12] - names of the months (optional)
		 * @return  string - the date in the above format
		 */
		formatDate: function( format, date, settings ) {
			if ( !date ) {
				return "";
			}
	
			var iFormat,
				dayNamesShort = ( settings ? settings.dayNamesShort : null ) || this._defaults.dayNamesShort,
				dayNames = ( settings ? settings.dayNames : null ) || this._defaults.dayNames,
				monthNamesShort = ( settings ? settings.monthNamesShort : null ) || this._defaults.monthNamesShort,
				monthNames = ( settings ? settings.monthNames : null ) || this._defaults.monthNames,
	
				// Check whether a format character is doubled
				lookAhead = function( match ) {
					var matches = ( iFormat + 1 < format.length && format.charAt( iFormat + 1 ) === match );
					if ( matches ) {
						iFormat++;
					}
					return matches;
				},
	
				// Format a number, with leading zero if necessary
				formatNumber = function( match, value, len ) {
					var num = "" + value;
					if ( lookAhead( match ) ) {
						while ( num.length < len ) {
							num = "0" + num;
						}
					}
					return num;
				},
	
				// Format a name, short or long as requested
				formatName = function( match, value, shortNames, longNames ) {
					return ( lookAhead( match ) ? longNames[ value ] : shortNames[ value ] );
				},
				output = "",
				literal = false;
	
			if ( date ) {
				for ( iFormat = 0; iFormat < format.length; iFormat++ ) {
					if ( literal ) {
						if ( format.charAt( iFormat ) === "'" && !lookAhead( "'" ) ) {
							literal = false;
						} else {
							output += format.charAt( iFormat );
						}
					} else {
						switch ( format.charAt( iFormat ) ) {
							case "d":
								output += formatNumber( "d", date.getDate(), 2 );
								break;
							case "D":
								output += formatName( "D", date.getDay(), dayNamesShort, dayNames );
								break;
							case "o":
								output += formatNumber( "o",
									Math.round( ( new Date( date.getFullYear(), date.getMonth(), date.getDate() ).getTime() - new Date( date.getFullYear(), 0, 0 ).getTime() ) / 86400000 ), 3 );
								break;
							case "m":
								output += formatNumber( "m", date.getMonth() + 1, 2 );
								break;
							case "M":
								output += formatName( "M", date.getMonth(), monthNamesShort, monthNames );
								break;
							case "y":
								output += ( lookAhead( "y" ) ? date.getFullYear() :
									( date.getFullYear() % 100 < 10 ? "0" : "" ) + date.getFullYear() % 100 );
								break;
							case "@":
								output += date.getTime();
								break;
							case "!":
								output += date.getTime() * 10000 + this._ticksTo1970;
								break;
							case "'":
								if ( lookAhead( "'" ) ) {
									output += "'";
								} else {
									literal = true;
								}
								break;
							default:
								output += format.charAt( iFormat );
						}
					}
				}
			}
			return output;
		},
	
		/* Extract all possible characters from the date format. */
		_possibleChars: function( format ) {
			var iFormat,
				chars = "",
				literal = false,
	
				// Check whether a format character is doubled
				lookAhead = function( match ) {
					var matches = ( iFormat + 1 < format.length && format.charAt( iFormat + 1 ) === match );
					if ( matches ) {
						iFormat++;
					}
					return matches;
				};
	
			for ( iFormat = 0; iFormat < format.length; iFormat++ ) {
				if ( literal ) {
					if ( format.charAt( iFormat ) === "'" && !lookAhead( "'" ) ) {
						literal = false;
					} else {
						chars += format.charAt( iFormat );
					}
				} else {
					switch ( format.charAt( iFormat ) ) {
						case "d": case "m": case "y": case "@":
							chars += "0123456789";
							break;
						case "D": case "M":
							return null; // Accept anything
						case "'":
							if ( lookAhead( "'" ) ) {
								chars += "'";
							} else {
								literal = true;
							}
							break;
						default:
							chars += format.charAt( iFormat );
					}
				}
			}
			return chars;
		},
	
		/* Get a setting value, defaulting if necessary. */
		_get: function( inst, name ) {
			return inst.settings[ name ] !== undefined ?
				inst.settings[ name ] : this._defaults[ name ];
		},
	
		/* Parse existing date and initialise date picker. */
		_setDateFromField: function( inst, noDefault ) {
			if ( inst.input.val() === inst.lastVal ) {
				return;
			}
	
			var dateFormat = this._get( inst, "dateFormat" ),
				dates = inst.lastVal = inst.input ? inst.input.val() : null,
				defaultDate = this._getDefaultDate( inst ),
				date = defaultDate,
				settings = this._getFormatConfig( inst );
	
			try {
				date = this.parseDate( dateFormat, dates, settings ) || defaultDate;
			} catch ( event ) {
				dates = ( noDefault ? "" : dates );
			}
			inst.selectedDay = date.getDate();
			inst.drawMonth = inst.selectedMonth = date.getMonth();
			inst.drawYear = inst.selectedYear = date.getFullYear();
			inst.currentDay = ( dates ? date.getDate() : 0 );
			inst.currentMonth = ( dates ? date.getMonth() : 0 );
			inst.currentYear = ( dates ? date.getFullYear() : 0 );
			this._adjustInstDate( inst );
		},
	
		/* Retrieve the default date shown on opening. */
		_getDefaultDate: function( inst ) {
			return this._restrictMinMax( inst,
				this._determineDate( inst, this._get( inst, "defaultDate" ), new Date() ) );
		},
	
		/* A date may be specified as an exact value or a relative one. */
		_determineDate: function( inst, date, defaultDate ) {
			var offsetNumeric = function( offset ) {
					var date = new Date();
					date.setDate( date.getDate() + offset );
					return date;
				},
				offsetString = function( offset ) {
					try {
						return $.datepicker.parseDate( $.datepicker._get( inst, "dateFormat" ),
							offset, $.datepicker._getFormatConfig( inst ) );
					}
					catch ( e ) {
	
						// Ignore
					}
	
					var date = ( offset.toLowerCase().match( /^c/ ) ?
						$.datepicker._getDate( inst ) : null ) || new Date(),
						year = date.getFullYear(),
						month = date.getMonth(),
						day = date.getDate(),
						pattern = /([+\-]?[0-9]+)\s*(d|D|w|W|m|M|y|Y)?/g,
						matches = pattern.exec( offset );
	
					while ( matches ) {
						switch ( matches[ 2 ] || "d" ) {
							case "d" : case "D" :
								day += parseInt( matches[ 1 ], 10 ); break;
							case "w" : case "W" :
								day += parseInt( matches[ 1 ], 10 ) * 7; break;
							case "m" : case "M" :
								month += parseInt( matches[ 1 ], 10 );
								day = Math.min( day, $.datepicker._getDaysInMonth( year, month ) );
								break;
							case "y": case "Y" :
								year += parseInt( matches[ 1 ], 10 );
								day = Math.min( day, $.datepicker._getDaysInMonth( year, month ) );
								break;
						}
						matches = pattern.exec( offset );
					}
					return new Date( year, month, day );
				},
				newDate = ( date == null || date === "" ? defaultDate : ( typeof date === "string" ? offsetString( date ) :
					( typeof date === "number" ? ( isNaN( date ) ? defaultDate : offsetNumeric( date ) ) : new Date( date.getTime() ) ) ) );
	
			newDate = ( newDate && newDate.toString() === "Invalid Date" ? defaultDate : newDate );
			if ( newDate ) {
				newDate.setHours( 0 );
				newDate.setMinutes( 0 );
				newDate.setSeconds( 0 );
				newDate.setMilliseconds( 0 );
			}
			return this._daylightSavingAdjust( newDate );
		},
	
		/* Handle switch to/from daylight saving.
		 * Hours may be non-zero on daylight saving cut-over:
		 * > 12 when midnight changeover, but then cannot generate
		 * midnight datetime, so jump to 1AM, otherwise reset.
		 * @param  date  (Date) the date to check
		 * @return  (Date) the corrected date
		 */
		_daylightSavingAdjust: function( date ) {
			if ( !date ) {
				return null;
			}
			date.setHours( date.getHours() > 12 ? date.getHours() + 2 : 0 );
			return date;
		},
	
		/* Set the date(s) directly. */
		_setDate: function( inst, date, noChange ) {
			var clear = !date,
				origMonth = inst.selectedMonth,
				origYear = inst.selectedYear,
				newDate = this._restrictMinMax( inst, this._determineDate( inst, date, new Date() ) );
	
			inst.selectedDay = inst.currentDay = newDate.getDate();
			inst.drawMonth = inst.selectedMonth = inst.currentMonth = newDate.getMonth();
			inst.drawYear = inst.selectedYear = inst.currentYear = newDate.getFullYear();
			if ( ( origMonth !== inst.selectedMonth || origYear !== inst.selectedYear ) && !noChange ) {
				this._notifyChange( inst );
			}
			this._adjustInstDate( inst );
			if ( inst.input ) {
				inst.input.val( clear ? "" : this._formatDate( inst ) );
			}
		},
	
		/* Retrieve the date(s) directly. */
		_getDate: function( inst ) {
			var startDate = ( !inst.currentYear || ( inst.input && inst.input.val() === "" ) ? null :
				this._daylightSavingAdjust( new Date(
				inst.currentYear, inst.currentMonth, inst.currentDay ) ) );
				return startDate;
		},
	
		/* Attach the onxxx handlers.  These are declared statically so
		 * they app with static code transformers like Caja.
		 */
		_attachHandlers: function( inst ) {
			var stepMonths = this._get( inst, "stepMonths" ),
				id = "#" + inst.id.replace( /\\\\/g, "\\" );
			inst.dpDiv.find( "[data-handler]" ).map( function() {
				var handler = {
					prev: function() {
						$.datepicker._adjustDate( id, -stepMonths, "M" );
					},
					next: function() {
						$.datepicker._adjustDate( id, +stepMonths, "M" );
					},
					hide: function() {
						$.datepicker._hideDatepicker();
					},
					today: function() {
						$.datepicker._gotoToday( id );
					},
					selectDay: function() {
						$.datepicker._selectDay( id, +this.getAttribute( "data-month" ), +this.getAttribute( "data-year" ), this );
						return false;
					},
					selectMonth: function() {
						$.datepicker._selectMonthYear( id, this, "M" );
						return false;
					},
					selectYear: function() {
						$.datepicker._selectMonthYear( id, this, "Y" );
						return false;
					}
				};
				$( this ).on( this.getAttribute( "data-event" ), handler[ this.getAttribute( "data-handler" ) ] );
			} );
		},
	
		/* Generate the HTML for the current state of the date picker. */
		_generateHTML: function( inst ) {
			var maxDraw, prevText, prev, nextText, next, currentText, gotoDate,
				controls, buttonPanel, firstDay, showWeek, dayNames, dayNamesMin,
				monthNames, monthNamesShort, beforeShowDay, showOtherMonths,
				selectOtherMonths, defaultDate, html, dow, row, group, col, selectedDate,
				cornerClass, calender, thead, day, daysInMonth, leadDays, curRows, numRows,
				printDate, dRow, tbody, daySettings, otherMonth, unselectable,
				tempDate = new Date(),
				today = this._daylightSavingAdjust(
					new Date( tempDate.getFullYear(), tempDate.getMonth(), tempDate.getDate() ) ), // clear time
				isRTL = this._get( inst, "isRTL" ),
				showButtonPanel = this._get( inst, "showButtonPanel" ),
				hideIfNoPrevNext = this._get( inst, "hideIfNoPrevNext" ),
				navigationAsDateFormat = this._get( inst, "navigationAsDateFormat" ),
				numMonths = this._getNumberOfMonths( inst ),
				showCurrentAtPos = this._get( inst, "showCurrentAtPos" ),
				stepMonths = this._get( inst, "stepMonths" ),
				isMultiMonth = ( numMonths[ 0 ] !== 1 || numMonths[ 1 ] !== 1 ),
				currentDate = this._daylightSavingAdjust( ( !inst.currentDay ? new Date( 9999, 9, 9 ) :
					new Date( inst.currentYear, inst.currentMonth, inst.currentDay ) ) ),
				minDate = this._getMinMaxDate( inst, "min" ),
				maxDate = this._getMinMaxDate( inst, "max" ),
				drawMonth = inst.drawMonth - showCurrentAtPos,
				drawYear = inst.drawYear;
	
			if ( drawMonth < 0 ) {
				drawMonth += 12;
				drawYear--;
			}
			if ( maxDate ) {
				maxDraw = this._daylightSavingAdjust( new Date( maxDate.getFullYear(),
					maxDate.getMonth() - ( numMonths[ 0 ] * numMonths[ 1 ] ) + 1, maxDate.getDate() ) );
				maxDraw = ( minDate && maxDraw < minDate ? minDate : maxDraw );
				while ( this._daylightSavingAdjust( new Date( drawYear, drawMonth, 1 ) ) > maxDraw ) {
					drawMonth--;
					if ( drawMonth < 0 ) {
						drawMonth = 11;
						drawYear--;
					}
				}
			}
			inst.drawMonth = drawMonth;
			inst.drawYear = drawYear;
	
			prevText = this._get( inst, "prevText" );
			prevText = ( !navigationAsDateFormat ? prevText : this.formatDate( prevText,
				this._daylightSavingAdjust( new Date( drawYear, drawMonth - stepMonths, 1 ) ),
				this._getFormatConfig( inst ) ) );
	
			prev = ( this._canAdjustMonth( inst, -1, drawYear, drawMonth ) ?
				"<a class='ui-datepicker-prev ui-corner-all' data-handler='prev' data-event='click'" +
				" title='" + prevText + "'><span class='ui-icon ui-icon-circle-triangle-" + ( isRTL ? "e" : "w" ) + "'>" + prevText + "</span></a>" :
				( hideIfNoPrevNext ? "" : "<a class='ui-datepicker-prev ui-corner-all ui-state-disabled' title='" + prevText + "'><span class='ui-icon ui-icon-circle-triangle-" + ( isRTL ? "e" : "w" ) + "'>" + prevText + "</span></a>" ) );
	
			nextText = this._get( inst, "nextText" );
			nextText = ( !navigationAsDateFormat ? nextText : this.formatDate( nextText,
				this._daylightSavingAdjust( new Date( drawYear, drawMonth + stepMonths, 1 ) ),
				this._getFormatConfig( inst ) ) );
	
			next = ( this._canAdjustMonth( inst, +1, drawYear, drawMonth ) ?
				"<a class='ui-datepicker-next ui-corner-all' data-handler='next' data-event='click'" +
				" title='" + nextText + "'><span class='ui-icon ui-icon-circle-triangle-" + ( isRTL ? "w" : "e" ) + "'>" + nextText + "</span></a>" :
				( hideIfNoPrevNext ? "" : "<a class='ui-datepicker-next ui-corner-all ui-state-disabled' title='" + nextText + "'><span class='ui-icon ui-icon-circle-triangle-" + ( isRTL ? "w" : "e" ) + "'>" + nextText + "</span></a>" ) );
	
			currentText = this._get( inst, "currentText" );
			gotoDate = ( this._get( inst, "gotoCurrent" ) && inst.currentDay ? currentDate : today );
			currentText = ( !navigationAsDateFormat ? currentText :
				this.formatDate( currentText, gotoDate, this._getFormatConfig( inst ) ) );
	
			controls = ( !inst.inline ? "<button type='button' class='ui-datepicker-close ui-state-default ui-priority-primary ui-corner-all' data-handler='hide' data-event='click'>" +
				this._get( inst, "closeText" ) + "</button>" : "" );
	
			buttonPanel = ( showButtonPanel ) ? "<div class='ui-datepicker-buttonpane ui-widget-content'>" + ( isRTL ? controls : "" ) +
				( this._isInRange( inst, gotoDate ) ? "<button type='button' class='ui-datepicker-current ui-state-default ui-priority-secondary ui-corner-all' data-handler='today' data-event='click'" +
				">" + currentText + "</button>" : "" ) + ( isRTL ? "" : controls ) + "</div>" : "";
	
			firstDay = parseInt( this._get( inst, "firstDay" ), 10 );
			firstDay = ( isNaN( firstDay ) ? 0 : firstDay );
	
			showWeek = this._get( inst, "showWeek" );
			dayNames = this._get( inst, "dayNames" );
			dayNamesMin = this._get( inst, "dayNamesMin" );
			monthNames = this._get( inst, "monthNames" );
			monthNamesShort = this._get( inst, "monthNamesShort" );
			beforeShowDay = this._get( inst, "beforeShowDay" );
			showOtherMonths = this._get( inst, "showOtherMonths" );
			selectOtherMonths = this._get( inst, "selectOtherMonths" );
			defaultDate = this._getDefaultDate( inst );
			html = "";
	
			for ( row = 0; row < numMonths[ 0 ]; row++ ) {
				group = "";
				this.maxRows = 4;
				for ( col = 0; col < numMonths[ 1 ]; col++ ) {
					selectedDate = this._daylightSavingAdjust( new Date( drawYear, drawMonth, inst.selectedDay ) );
					cornerClass = " ui-corner-all";
					calender = "";
					if ( isMultiMonth ) {
						calender += "<div class='ui-datepicker-group";
						if ( numMonths[ 1 ] > 1 ) {
							switch ( col ) {
								case 0: calender += " ui-datepicker-group-first";
									cornerClass = " ui-corner-" + ( isRTL ? "right" : "left" ); break;
								case numMonths[ 1 ] - 1: calender += " ui-datepicker-group-last";
									cornerClass = " ui-corner-" + ( isRTL ? "left" : "right" ); break;
								default: calender += " ui-datepicker-group-middle"; cornerClass = ""; break;
							}
						}
						calender += "'>";
					}
					calender += "<div class='ui-datepicker-header ui-widget-header ui-helper-clearfix" + cornerClass + "'>" +
						( /all|left/.test( cornerClass ) && row === 0 ? ( isRTL ? next : prev ) : "" ) +
						( /all|right/.test( cornerClass ) && row === 0 ? ( isRTL ? prev : next ) : "" ) +
						this._generateMonthYearHeader( inst, drawMonth, drawYear, minDate, maxDate,
						row > 0 || col > 0, monthNames, monthNamesShort ) + // draw month headers
						"</div><table class='ui-datepicker-calendar'><thead>" +
						"<tr>";
					thead = ( showWeek ? "<th class='ui-datepicker-week-col'>" + this._get( inst, "weekHeader" ) + "</th>" : "" );
					for ( dow = 0; dow < 7; dow++ ) { // days of the week
						day = ( dow + firstDay ) % 7;
						thead += "<th scope='col'" + ( ( dow + firstDay + 6 ) % 7 >= 5 ? " class='ui-datepicker-week-end'" : "" ) + ">" +
							"<span title='" + dayNames[ day ] + "'>" + dayNamesMin[ day ] + "</span></th>";
					}
					calender += thead + "</tr></thead><tbody>";
					daysInMonth = this._getDaysInMonth( drawYear, drawMonth );
					if ( drawYear === inst.selectedYear && drawMonth === inst.selectedMonth ) {
						inst.selectedDay = Math.min( inst.selectedDay, daysInMonth );
					}
					leadDays = ( this._getFirstDayOfMonth( drawYear, drawMonth ) - firstDay + 7 ) % 7;
					curRows = Math.ceil( ( leadDays + daysInMonth ) / 7 ); // calculate the number of rows to generate
					numRows = ( isMultiMonth ? this.maxRows > curRows ? this.maxRows : curRows : curRows ); //If multiple months, use the higher number of rows (see #7043)
					this.maxRows = numRows;
					printDate = this._daylightSavingAdjust( new Date( drawYear, drawMonth, 1 - leadDays ) );
					for ( dRow = 0; dRow < numRows; dRow++ ) { // create date picker rows
						calender += "<tr>";
						tbody = ( !showWeek ? "" : "<td class='ui-datepicker-week-col'>" +
							this._get( inst, "calculateWeek" )( printDate ) + "</td>" );
						for ( dow = 0; dow < 7; dow++ ) { // create date picker days
							daySettings = ( beforeShowDay ?
								beforeShowDay.apply( ( inst.input ? inst.input[ 0 ] : null ), [ printDate ] ) : [ true, "" ] );
							otherMonth = ( printDate.getMonth() !== drawMonth );
							unselectable = ( otherMonth && !selectOtherMonths ) || !daySettings[ 0 ] ||
								( minDate && printDate < minDate ) || ( maxDate && printDate > maxDate );
							tbody += "<td class='" +
								( ( dow + firstDay + 6 ) % 7 >= 5 ? " ui-datepicker-week-end" : "" ) + // highlight weekends
								( otherMonth ? " ui-datepicker-other-month" : "" ) + // highlight days from other months
								( ( printDate.getTime() === selectedDate.getTime() && drawMonth === inst.selectedMonth && inst._keyEvent ) || // user pressed key
								( defaultDate.getTime() === printDate.getTime() && defaultDate.getTime() === selectedDate.getTime() ) ?
	
								// or defaultDate is current printedDate and defaultDate is selectedDate
								" " + this._dayOverClass : "" ) + // highlight selected day
								( unselectable ? " " + this._unselectableClass + " ui-state-disabled" : "" ) +  // highlight unselectable days
								( otherMonth && !showOtherMonths ? "" : " " + daySettings[ 1 ] + // highlight custom dates
								( printDate.getTime() === currentDate.getTime() ? " " + this._currentClass : "" ) + // highlight selected day
								( printDate.getTime() === today.getTime() ? " ui-datepicker-today" : "" ) ) + "'" + // highlight today (if different)
								( ( !otherMonth || showOtherMonths ) && daySettings[ 2 ] ? " title='" + daySettings[ 2 ].replace( /'/g, "&#39;" ) + "'" : "" ) + // cell title
								( unselectable ? "" : " data-handler='selectDay' data-event='click' data-month='" + printDate.getMonth() + "' data-year='" + printDate.getFullYear() + "'" ) + ">" + // actions
								( otherMonth && !showOtherMonths ? "&#xa0;" : // display for other months
								( unselectable ? "<span class='ui-state-default'>" + printDate.getDate() + "</span>" : "<a class='ui-state-default" +
								( printDate.getTime() === today.getTime() ? " ui-state-highlight" : "" ) +
								( printDate.getTime() === currentDate.getTime() ? " ui-state-active" : "" ) + // highlight selected day
								( otherMonth ? " ui-priority-secondary" : "" ) + // distinguish dates from other months
								"' href='#'>" + printDate.getDate() + "</a>" ) ) + "</td>"; // display selectable date
							printDate.setDate( printDate.getDate() + 1 );
							printDate = this._daylightSavingAdjust( printDate );
						}
						calender += tbody + "</tr>";
					}
					drawMonth++;
					if ( drawMonth > 11 ) {
						drawMonth = 0;
						drawYear++;
					}
					calender += "</tbody></table>" + ( isMultiMonth ? "</div>" +
								( ( numMonths[ 0 ] > 0 && col === numMonths[ 1 ] - 1 ) ? "<div class='ui-datepicker-row-break'></div>" : "" ) : "" );
					group += calender;
				}
				html += group;
			}
			html += buttonPanel;
			inst._keyEvent = false;
			return html;
		},
	
		/* Generate the month and year header. */
		_generateMonthYearHeader: function( inst, drawMonth, drawYear, minDate, maxDate,
				secondary, monthNames, monthNamesShort ) {
	
			var inMinYear, inMaxYear, month, years, thisYear, determineYear, year, endYear,
				changeMonth = this._get( inst, "changeMonth" ),
				changeYear = this._get( inst, "changeYear" ),
				showMonthAfterYear = this._get( inst, "showMonthAfterYear" ),
				html = "<div class='ui-datepicker-title'>",
				monthHtml = "";
	
			// Month selection
			if ( secondary || !changeMonth ) {
				monthHtml += "<span class='ui-datepicker-month'>" + monthNames[ drawMonth ] + "</span>";
			} else {
				inMinYear = ( minDate && minDate.getFullYear() === drawYear );
				inMaxYear = ( maxDate && maxDate.getFullYear() === drawYear );
				monthHtml += "<select class='ui-datepicker-month' data-handler='selectMonth' data-event='change'>";
				for ( month = 0; month < 12; month++ ) {
					if ( ( !inMinYear || month >= minDate.getMonth() ) && ( !inMaxYear || month <= maxDate.getMonth() ) ) {
						monthHtml += "<option value='" + month + "'" +
							( month === drawMonth ? " selected='selected'" : "" ) +
							">" + monthNamesShort[ month ] + "</option>";
					}
				}
				monthHtml += "</select>";
			}
	
			if ( !showMonthAfterYear ) {
				html += monthHtml + ( secondary || !( changeMonth && changeYear ) ? "&#xa0;" : "" );
			}
	
			// Year selection
			if ( !inst.yearshtml ) {
				inst.yearshtml = "";
				if ( secondary || !changeYear ) {
					html += "<span class='ui-datepicker-year'>" + drawYear + "</span>";
				} else {
	
					// determine range of years to display
					years = this._get( inst, "yearRange" ).split( ":" );
					thisYear = new Date().getFullYear();
					determineYear = function( value ) {
						var year = ( value.match( /c[+\-].*/ ) ? drawYear + parseInt( value.substring( 1 ), 10 ) :
							( value.match( /[+\-].*/ ) ? thisYear + parseInt( value, 10 ) :
							parseInt( value, 10 ) ) );
						return ( isNaN( year ) ? thisYear : year );
					};
					year = determineYear( years[ 0 ] );
					endYear = Math.max( year, determineYear( years[ 1 ] || "" ) );
					year = ( minDate ? Math.max( year, minDate.getFullYear() ) : year );
					endYear = ( maxDate ? Math.min( endYear, maxDate.getFullYear() ) : endYear );
					inst.yearshtml += "<select class='ui-datepicker-year' data-handler='selectYear' data-event='change'>";
					for ( ; year <= endYear; year++ ) {
						inst.yearshtml += "<option value='" + year + "'" +
							( year === drawYear ? " selected='selected'" : "" ) +
							">" + year + "</option>";
					}
					inst.yearshtml += "</select>";
	
					html += inst.yearshtml;
					inst.yearshtml = null;
				}
			}
	
			html += this._get( inst, "yearSuffix" );
			if ( showMonthAfterYear ) {
				html += ( secondary || !( changeMonth && changeYear ) ? "&#xa0;" : "" ) + monthHtml;
			}
			html += "</div>"; // Close datepicker_header
			return html;
		},
	
		/* Adjust one of the date sub-fields. */
		_adjustInstDate: function( inst, offset, period ) {
			var year = inst.selectedYear + ( period === "Y" ? offset : 0 ),
				month = inst.selectedMonth + ( period === "M" ? offset : 0 ),
				day = Math.min( inst.selectedDay, this._getDaysInMonth( year, month ) ) + ( period === "D" ? offset : 0 ),
				date = this._restrictMinMax( inst, this._daylightSavingAdjust( new Date( year, month, day ) ) );
	
			inst.selectedDay = date.getDate();
			inst.drawMonth = inst.selectedMonth = date.getMonth();
			inst.drawYear = inst.selectedYear = date.getFullYear();
			if ( period === "M" || period === "Y" ) {
				this._notifyChange( inst );
			}
		},
	
		/* Ensure a date is within any min/max bounds. */
		_restrictMinMax: function( inst, date ) {
			var minDate = this._getMinMaxDate( inst, "min" ),
				maxDate = this._getMinMaxDate( inst, "max" ),
				newDate = ( minDate && date < minDate ? minDate : date );
			return ( maxDate && newDate > maxDate ? maxDate : newDate );
		},
	
		/* Notify change of month/year. */
		_notifyChange: function( inst ) {
			var onChange = this._get( inst, "onChangeMonthYear" );
			if ( onChange ) {
				onChange.apply( ( inst.input ? inst.input[ 0 ] : null ),
					[ inst.selectedYear, inst.selectedMonth + 1, inst ] );
			}
		},
	
		/* Determine the number of months to show. */
		_getNumberOfMonths: function( inst ) {
			var numMonths = this._get( inst, "numberOfMonths" );
			return ( numMonths == null ? [ 1, 1 ] : ( typeof numMonths === "number" ? [ 1, numMonths ] : numMonths ) );
		},
	
		/* Determine the current maximum date - ensure no time components are set. */
		_getMinMaxDate: function( inst, minMax ) {
			return this._determineDate( inst, this._get( inst, minMax + "Date" ), null );
		},
	
		/* Find the number of days in a given month. */
		_getDaysInMonth: function( year, month ) {
			return 32 - this._daylightSavingAdjust( new Date( year, month, 32 ) ).getDate();
		},
	
		/* Find the day of the week of the first of a month. */
		_getFirstDayOfMonth: function( year, month ) {
			return new Date( year, month, 1 ).getDay();
		},
	
		/* Determines if we should allow a "next/prev" month display change. */
		_canAdjustMonth: function( inst, offset, curYear, curMonth ) {
			var numMonths = this._getNumberOfMonths( inst ),
				date = this._daylightSavingAdjust( new Date( curYear,
				curMonth + ( offset < 0 ? offset : numMonths[ 0 ] * numMonths[ 1 ] ), 1 ) );
	
			if ( offset < 0 ) {
				date.setDate( this._getDaysInMonth( date.getFullYear(), date.getMonth() ) );
			}
			return this._isInRange( inst, date );
		},
	
		/* Is the given date in the accepted range? */
		_isInRange: function( inst, date ) {
			var yearSplit, currentYear,
				minDate = this._getMinMaxDate( inst, "min" ),
				maxDate = this._getMinMaxDate( inst, "max" ),
				minYear = null,
				maxYear = null,
				years = this._get( inst, "yearRange" );
				if ( years ) {
					yearSplit = years.split( ":" );
					currentYear = new Date().getFullYear();
					minYear = parseInt( yearSplit[ 0 ], 10 );
					maxYear = parseInt( yearSplit[ 1 ], 10 );
					if ( yearSplit[ 0 ].match( /[+\-].*/ ) ) {
						minYear += currentYear;
					}
					if ( yearSplit[ 1 ].match( /[+\-].*/ ) ) {
						maxYear += currentYear;
					}
				}
	
			return ( ( !minDate || date.getTime() >= minDate.getTime() ) &&
				( !maxDate || date.getTime() <= maxDate.getTime() ) &&
				( !minYear || date.getFullYear() >= minYear ) &&
				( !maxYear || date.getFullYear() <= maxYear ) );
		},
	
		/* Provide the configuration settings for formatting/parsing. */
		_getFormatConfig: function( inst ) {
			var shortYearCutoff = this._get( inst, "shortYearCutoff" );
			shortYearCutoff = ( typeof shortYearCutoff !== "string" ? shortYearCutoff :
				new Date().getFullYear() % 100 + parseInt( shortYearCutoff, 10 ) );
			return { shortYearCutoff: shortYearCutoff,
				dayNamesShort: this._get( inst, "dayNamesShort" ), dayNames: this._get( inst, "dayNames" ),
				monthNamesShort: this._get( inst, "monthNamesShort" ), monthNames: this._get( inst, "monthNames" ) };
		},
	
		/* Format the given date for display. */
		_formatDate: function( inst, day, month, year ) {
			if ( !day ) {
				inst.currentDay = inst.selectedDay;
				inst.currentMonth = inst.selectedMonth;
				inst.currentYear = inst.selectedYear;
			}
			var date = ( day ? ( typeof day === "object" ? day :
				this._daylightSavingAdjust( new Date( year, month, day ) ) ) :
				this._daylightSavingAdjust( new Date( inst.currentYear, inst.currentMonth, inst.currentDay ) ) );
			return this.formatDate( this._get( inst, "dateFormat" ), date, this._getFormatConfig( inst ) );
		}
	} );
	
	/*
	 * Bind hover events for datepicker elements.
	 * Done via delegate so the binding only occurs once in the lifetime of the parent div.
	 * Global datepicker_instActive, set by _updateDatepicker allows the handlers to find their way back to the active picker.
	 */
	function datepicker_bindHover( dpDiv ) {
		var selector = "button, .ui-datepicker-prev, .ui-datepicker-next, .ui-datepicker-calendar td a";
		return dpDiv.on( "mouseout", selector, function() {
				$( this ).removeClass( "ui-state-hover" );
				if ( this.className.indexOf( "ui-datepicker-prev" ) !== -1 ) {
					$( this ).removeClass( "ui-datepicker-prev-hover" );
				}
				if ( this.className.indexOf( "ui-datepicker-next" ) !== -1 ) {
					$( this ).removeClass( "ui-datepicker-next-hover" );
				}
			} )
			.on( "mouseover", selector, datepicker_handleMouseover );
	}
	
	function datepicker_handleMouseover() {
		if ( !$.datepicker._isDisabledDatepicker( datepicker_instActive.inline ? datepicker_instActive.dpDiv.parent()[ 0 ] : datepicker_instActive.input[ 0 ] ) ) {
			$( this ).parents( ".ui-datepicker-calendar" ).find( "a" ).removeClass( "ui-state-hover" );
			$( this ).addClass( "ui-state-hover" );
			if ( this.className.indexOf( "ui-datepicker-prev" ) !== -1 ) {
				$( this ).addClass( "ui-datepicker-prev-hover" );
			}
			if ( this.className.indexOf( "ui-datepicker-next" ) !== -1 ) {
				$( this ).addClass( "ui-datepicker-next-hover" );
			}
		}
	}
	
	/* jQuery extend now ignores nulls! */
	function datepicker_extendRemove( target, props ) {
		$.extend( target, props );
		for ( var name in props ) {
			if ( props[ name ] == null ) {
				target[ name ] = props[ name ];
			}
		}
		return target;
	}
	
	/* Invoke the datepicker functionality.
	   @param  options  string - a command, optionally followed by additional parameters or
						Object - settings for attaching new datepicker functionality
	   @return  jQuery object */
	$.fn.datepicker = function( options ) {
	
		/* Verify an empty collection wasn't passed - Fixes #6976 */
		if ( !this.length ) {
			return this;
		}
	
		/* Initialise the date picker. */
		if ( !$.datepicker.initialized ) {
			$( document ).on( "mousedown", $.datepicker._checkExternalClick );
			$.datepicker.initialized = true;
		}
	
		/* Append datepicker main container to body if not exist. */
		if ( $( "#" + $.datepicker._mainDivId ).length === 0 ) {
			$( "body" ).append( $.datepicker.dpDiv );
		}
	
		var otherArgs = Array.prototype.slice.call( arguments, 1 );
		if ( typeof options === "string" && ( options === "isDisabled" || options === "getDate" || options === "widget" ) ) {
			return $.datepicker[ "_" + options + "Datepicker" ].
				apply( $.datepicker, [ this[ 0 ] ].concat( otherArgs ) );
		}
		if ( options === "option" && arguments.length === 2 && typeof arguments[ 1 ] === "string" ) {
			return $.datepicker[ "_" + options + "Datepicker" ].
				apply( $.datepicker, [ this[ 0 ] ].concat( otherArgs ) );
		}
		return this.each( function() {
			typeof options === "string" ?
				$.datepicker[ "_" + options + "Datepicker" ].
					apply( $.datepicker, [ this ].concat( otherArgs ) ) :
				$.datepicker._attachDatepicker( this, options );
		} );
	};
	
	$.datepicker = new Datepicker(); // singleton instance
	$.datepicker.initialized = false;
	$.datepicker.uuid = new Date().getTime();
	$.datepicker.version = "1.12.0";
	
	var widgetsDatepicker = $.datepicker;
	
	
	/*!
	 * jQuery UI Effects 1.12.0
	 * http://jqueryui.com
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license.
	 * http://jquery.org/license
	 */
	
	//>>label: Effects Core
	//>>group: Effects
	// jscs:disable maximumLineLength
	//>>description: Extends the internal jQuery effects. Includes morphing and easing. Required by all other effects.
	// jscs:enable maximumLineLength
	//>>docs: http://api.jqueryui.com/category/effects-core/
	//>>demos: http://jqueryui.com/effect/
	
	
	
	var dataSpace = "ui-effects-",
		dataSpaceStyle = "ui-effects-style",
		dataSpaceAnimated = "ui-effects-animated",
	
		// Create a local jQuery because jQuery Color relies on it and the
		// global may not exist with AMD and a custom build (#10199)
		jQuery = $;
	
	$.effects = {
		effect: {}
	};
	
	/*!
	 * jQuery Color Animations v2.1.2
	 * https://github.com/jquery/jquery-color
	 *
	 * Copyright 2014 jQuery Foundation and other contributors
	 * Released under the MIT license.
	 * http://jquery.org/license
	 *
	 * Date: Wed Jan 16 08:47:09 2013 -0600
	 */
	( function( jQuery, undefined ) {
	
		var stepHooks = "backgroundColor borderBottomColor borderLeftColor borderRightColor " +
			"borderTopColor color columnRuleColor outlineColor textDecorationColor textEmphasisColor",
	
		// Plusequals test for += 100 -= 100
		rplusequals = /^([\-+])=\s*(\d+\.?\d*)/,
	
		// A set of RE's that can match strings and generate color tuples.
		stringParsers = [ {
				re: /rgba?\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
				parse: function( execResult ) {
					return [
						execResult[ 1 ],
						execResult[ 2 ],
						execResult[ 3 ],
						execResult[ 4 ]
					];
				}
			}, {
				re: /rgba?\(\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
				parse: function( execResult ) {
					return [
						execResult[ 1 ] * 2.55,
						execResult[ 2 ] * 2.55,
						execResult[ 3 ] * 2.55,
						execResult[ 4 ]
					];
				}
			}, {
	
				// This regex ignores A-F because it's compared against an already lowercased string
				re: /#([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})/,
				parse: function( execResult ) {
					return [
						parseInt( execResult[ 1 ], 16 ),
						parseInt( execResult[ 2 ], 16 ),
						parseInt( execResult[ 3 ], 16 )
					];
				}
			}, {
	
				// This regex ignores A-F because it's compared against an already lowercased string
				re: /#([a-f0-9])([a-f0-9])([a-f0-9])/,
				parse: function( execResult ) {
					return [
						parseInt( execResult[ 1 ] + execResult[ 1 ], 16 ),
						parseInt( execResult[ 2 ] + execResult[ 2 ], 16 ),
						parseInt( execResult[ 3 ] + execResult[ 3 ], 16 )
					];
				}
			}, {
				re: /hsla?\(\s*(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
				space: "hsla",
				parse: function( execResult ) {
					return [
						execResult[ 1 ],
						execResult[ 2 ] / 100,
						execResult[ 3 ] / 100,
						execResult[ 4 ]
					];
				}
			} ],
	
		// JQuery.Color( )
		color = jQuery.Color = function( color, green, blue, alpha ) {
			return new jQuery.Color.fn.parse( color, green, blue, alpha );
		},
		spaces = {
			rgba: {
				props: {
					red: {
						idx: 0,
						type: "byte"
					},
					green: {
						idx: 1,
						type: "byte"
					},
					blue: {
						idx: 2,
						type: "byte"
					}
				}
			},
	
			hsla: {
				props: {
					hue: {
						idx: 0,
						type: "degrees"
					},
					saturation: {
						idx: 1,
						type: "percent"
					},
					lightness: {
						idx: 2,
						type: "percent"
					}
				}
			}
		},
		propTypes = {
			"byte": {
				floor: true,
				max: 255
			},
			"percent": {
				max: 1
			},
			"degrees": {
				mod: 360,
				floor: true
			}
		},
		support = color.support = {},
	
		// Element for support tests
		supportElem = jQuery( "<p>" )[ 0 ],
	
		// Colors = jQuery.Color.names
		colors,
	
		// Local aliases of functions called often
		each = jQuery.each;
	
	// Determine rgba support immediately
	supportElem.style.cssText = "background-color:rgba(1,1,1,.5)";
	support.rgba = supportElem.style.backgroundColor.indexOf( "rgba" ) > -1;
	
	// Define cache name and alpha properties
	// for rgba and hsla spaces
	each( spaces, function( spaceName, space ) {
		space.cache = "_" + spaceName;
		space.props.alpha = {
			idx: 3,
			type: "percent",
			def: 1
		};
	} );
	
	function clamp( value, prop, allowEmpty ) {
		var type = propTypes[ prop.type ] || {};
	
		if ( value == null ) {
			return ( allowEmpty || !prop.def ) ? null : prop.def;
		}
	
		// ~~ is an short way of doing floor for positive numbers
		value = type.floor ? ~~value : parseFloat( value );
	
		// IE will pass in empty strings as value for alpha,
		// which will hit this case
		if ( isNaN( value ) ) {
			return prop.def;
		}
	
		if ( type.mod ) {
	
			// We add mod before modding to make sure that negatives values
			// get converted properly: -10 -> 350
			return ( value + type.mod ) % type.mod;
		}
	
		// For now all property types without mod have min and max
		return 0 > value ? 0 : type.max < value ? type.max : value;
	}
	
	function stringParse( string ) {
		var inst = color(),
			rgba = inst._rgba = [];
	
		string = string.toLowerCase();
	
		each( stringParsers, function( i, parser ) {
			var parsed,
				match = parser.re.exec( string ),
				values = match && parser.parse( match ),
				spaceName = parser.space || "rgba";
	
			if ( values ) {
				parsed = inst[ spaceName ]( values );
	
				// If this was an rgba parse the assignment might happen twice
				// oh well....
				inst[ spaces[ spaceName ].cache ] = parsed[ spaces[ spaceName ].cache ];
				rgba = inst._rgba = parsed._rgba;
	
				// Exit each( stringParsers ) here because we matched
				return false;
			}
		} );
	
		// Found a stringParser that handled it
		if ( rgba.length ) {
	
			// If this came from a parsed string, force "transparent" when alpha is 0
			// chrome, (and maybe others) return "transparent" as rgba(0,0,0,0)
			if ( rgba.join() === "0,0,0,0" ) {
				jQuery.extend( rgba, colors.transparent );
			}
			return inst;
		}
	
		// Named colors
		return colors[ string ];
	}
	
	color.fn = jQuery.extend( color.prototype, {
		parse: function( red, green, blue, alpha ) {
			if ( red === undefined ) {
				this._rgba = [ null, null, null, null ];
				return this;
			}
			if ( red.jquery || red.nodeType ) {
				red = jQuery( red ).css( green );
				green = undefined;
			}
	
			var inst = this,
				type = jQuery.type( red ),
				rgba = this._rgba = [];
	
			// More than 1 argument specified - assume ( red, green, blue, alpha )
			if ( green !== undefined ) {
				red = [ red, green, blue, alpha ];
				type = "array";
			}
	
			if ( type === "string" ) {
				return this.parse( stringParse( red ) || colors._default );
			}
	
			if ( type === "array" ) {
				each( spaces.rgba.props, function( key, prop ) {
					rgba[ prop.idx ] = clamp( red[ prop.idx ], prop );
				} );
				return this;
			}
	
			if ( type === "object" ) {
				if ( red instanceof color ) {
					each( spaces, function( spaceName, space ) {
						if ( red[ space.cache ] ) {
							inst[ space.cache ] = red[ space.cache ].slice();
						}
					} );
				} else {
					each( spaces, function( spaceName, space ) {
						var cache = space.cache;
						each( space.props, function( key, prop ) {
	
							// If the cache doesn't exist, and we know how to convert
							if ( !inst[ cache ] && space.to ) {
	
								// If the value was null, we don't need to copy it
								// if the key was alpha, we don't need to copy it either
								if ( key === "alpha" || red[ key ] == null ) {
									return;
								}
								inst[ cache ] = space.to( inst._rgba );
							}
	
							// This is the only case where we allow nulls for ALL properties.
							// call clamp with alwaysAllowEmpty
							inst[ cache ][ prop.idx ] = clamp( red[ key ], prop, true );
						} );
	
						// Everything defined but alpha?
						if ( inst[ cache ] &&
								jQuery.inArray( null, inst[ cache ].slice( 0, 3 ) ) < 0 ) {
	
							// Use the default of 1
							inst[ cache ][ 3 ] = 1;
							if ( space.from ) {
								inst._rgba = space.from( inst[ cache ] );
							}
						}
					} );
				}
				return this;
			}
		},
		is: function( compare ) {
			var is = color( compare ),
				same = true,
				inst = this;
	
			each( spaces, function( _, space ) {
				var localCache,
					isCache = is[ space.cache ];
				if ( isCache ) {
					localCache = inst[ space.cache ] || space.to && space.to( inst._rgba ) || [];
					each( space.props, function( _, prop ) {
						if ( isCache[ prop.idx ] != null ) {
							same = ( isCache[ prop.idx ] === localCache[ prop.idx ] );
							return same;
						}
					} );
				}
				return same;
			} );
			return same;
		},
		_space: function() {
			var used = [],
				inst = this;
			each( spaces, function( spaceName, space ) {
				if ( inst[ space.cache ] ) {
					used.push( spaceName );
				}
			} );
			return used.pop();
		},
		transition: function( other, distance ) {
			var end = color( other ),
				spaceName = end._space(),
				space = spaces[ spaceName ],
				startColor = this.alpha() === 0 ? color( "transparent" ) : this,
				start = startColor[ space.cache ] || space.to( startColor._rgba ),
				result = start.slice();
	
			end = end[ space.cache ];
			each( space.props, function( key, prop ) {
				var index = prop.idx,
					startValue = start[ index ],
					endValue = end[ index ],
					type = propTypes[ prop.type ] || {};
	
				// If null, don't override start value
				if ( endValue === null ) {
					return;
				}
	
				// If null - use end
				if ( startValue === null ) {
					result[ index ] = endValue;
				} else {
					if ( type.mod ) {
						if ( endValue - startValue > type.mod / 2 ) {
							startValue += type.mod;
						} else if ( startValue - endValue > type.mod / 2 ) {
							startValue -= type.mod;
						}
					}
					result[ index ] = clamp( ( endValue - startValue ) * distance + startValue, prop );
				}
			} );
			return this[ spaceName ]( result );
		},
		blend: function( opaque ) {
	
			// If we are already opaque - return ourself
			if ( this._rgba[ 3 ] === 1 ) {
				return this;
			}
	
			var rgb = this._rgba.slice(),
				a = rgb.pop(),
				blend = color( opaque )._rgba;
	
			return color( jQuery.map( rgb, function( v, i ) {
				return ( 1 - a ) * blend[ i ] + a * v;
			} ) );
		},
		toRgbaString: function() {
			var prefix = "rgba(",
				rgba = jQuery.map( this._rgba, function( v, i ) {
					return v == null ? ( i > 2 ? 1 : 0 ) : v;
				} );
	
			if ( rgba[ 3 ] === 1 ) {
				rgba.pop();
				prefix = "rgb(";
			}
	
			return prefix + rgba.join() + ")";
		},
		toHslaString: function() {
			var prefix = "hsla(",
				hsla = jQuery.map( this.hsla(), function( v, i ) {
					if ( v == null ) {
						v = i > 2 ? 1 : 0;
					}
	
					// Catch 1 and 2
					if ( i && i < 3 ) {
						v = Math.round( v * 100 ) + "%";
					}
					return v;
				} );
	
			if ( hsla[ 3 ] === 1 ) {
				hsla.pop();
				prefix = "hsl(";
			}
			return prefix + hsla.join() + ")";
		},
		toHexString: function( includeAlpha ) {
			var rgba = this._rgba.slice(),
				alpha = rgba.pop();
	
			if ( includeAlpha ) {
				rgba.push( ~~( alpha * 255 ) );
			}
	
			return "#" + jQuery.map( rgba, function( v ) {
	
				// Default to 0 when nulls exist
				v = ( v || 0 ).toString( 16 );
				return v.length === 1 ? "0" + v : v;
			} ).join( "" );
		},
		toString: function() {
			return this._rgba[ 3 ] === 0 ? "transparent" : this.toRgbaString();
		}
	} );
	color.fn.parse.prototype = color.fn;
	
	// Hsla conversions adapted from:
	// https://code.google.com/p/maashaack/source/browse/packages/graphics/trunk/src/graphics/colors/HUE2RGB.as?r=5021
	
	function hue2rgb( p, q, h ) {
		h = ( h + 1 ) % 1;
		if ( h * 6 < 1 ) {
			return p + ( q - p ) * h * 6;
		}
		if ( h * 2 < 1 ) {
			return q;
		}
		if ( h * 3 < 2 ) {
			return p + ( q - p ) * ( ( 2 / 3 ) - h ) * 6;
		}
		return p;
	}
	
	spaces.hsla.to = function( rgba ) {
		if ( rgba[ 0 ] == null || rgba[ 1 ] == null || rgba[ 2 ] == null ) {
			return [ null, null, null, rgba[ 3 ] ];
		}
		var r = rgba[ 0 ] / 255,
			g = rgba[ 1 ] / 255,
			b = rgba[ 2 ] / 255,
			a = rgba[ 3 ],
			max = Math.max( r, g, b ),
			min = Math.min( r, g, b ),
			diff = max - min,
			add = max + min,
			l = add * 0.5,
			h, s;
	
		if ( min === max ) {
			h = 0;
		} else if ( r === max ) {
			h = ( 60 * ( g - b ) / diff ) + 360;
		} else if ( g === max ) {
			h = ( 60 * ( b - r ) / diff ) + 120;
		} else {
			h = ( 60 * ( r - g ) / diff ) + 240;
		}
	
		// Chroma (diff) == 0 means greyscale which, by definition, saturation = 0%
		// otherwise, saturation is based on the ratio of chroma (diff) to lightness (add)
		if ( diff === 0 ) {
			s = 0;
		} else if ( l <= 0.5 ) {
			s = diff / add;
		} else {
			s = diff / ( 2 - add );
		}
		return [ Math.round( h ) % 360, s, l, a == null ? 1 : a ];
	};
	
	spaces.hsla.from = function( hsla ) {
		if ( hsla[ 0 ] == null || hsla[ 1 ] == null || hsla[ 2 ] == null ) {
			return [ null, null, null, hsla[ 3 ] ];
		}
		var h = hsla[ 0 ] / 360,
			s = hsla[ 1 ],
			l = hsla[ 2 ],
			a = hsla[ 3 ],
			q = l <= 0.5 ? l * ( 1 + s ) : l + s - l * s,
			p = 2 * l - q;
	
		return [
			Math.round( hue2rgb( p, q, h + ( 1 / 3 ) ) * 255 ),
			Math.round( hue2rgb( p, q, h ) * 255 ),
			Math.round( hue2rgb( p, q, h - ( 1 / 3 ) ) * 255 ),
			a
		];
	};
	
	each( spaces, function( spaceName, space ) {
		var props = space.props,
			cache = space.cache,
			to = space.to,
			from = space.from;
	
		// Makes rgba() and hsla()
		color.fn[ spaceName ] = function( value ) {
	
			// Generate a cache for this space if it doesn't exist
			if ( to && !this[ cache ] ) {
				this[ cache ] = to( this._rgba );
			}
			if ( value === undefined ) {
				return this[ cache ].slice();
			}
	
			var ret,
				type = jQuery.type( value ),
				arr = ( type === "array" || type === "object" ) ? value : arguments,
				local = this[ cache ].slice();
	
			each( props, function( key, prop ) {
				var val = arr[ type === "object" ? key : prop.idx ];
				if ( val == null ) {
					val = local[ prop.idx ];
				}
				local[ prop.idx ] = clamp( val, prop );
			} );
	
			if ( from ) {
				ret = color( from( local ) );
				ret[ cache ] = local;
				return ret;
			} else {
				return color( local );
			}
		};
	
		// Makes red() green() blue() alpha() hue() saturation() lightness()
		each( props, function( key, prop ) {
	
			// Alpha is included in more than one space
			if ( color.fn[ key ] ) {
				return;
			}
			color.fn[ key ] = function( value ) {
				var vtype = jQuery.type( value ),
					fn = ( key === "alpha" ? ( this._hsla ? "hsla" : "rgba" ) : spaceName ),
					local = this[ fn ](),
					cur = local[ prop.idx ],
					match;
	
				if ( vtype === "undefined" ) {
					return cur;
				}
	
				if ( vtype === "function" ) {
					value = value.call( this, cur );
					vtype = jQuery.type( value );
				}
				if ( value == null && prop.empty ) {
					return this;
				}
				if ( vtype === "string" ) {
					match = rplusequals.exec( value );
					if ( match ) {
						value = cur + parseFloat( match[ 2 ] ) * ( match[ 1 ] === "+" ? 1 : -1 );
					}
				}
				local[ prop.idx ] = value;
				return this[ fn ]( local );
			};
		} );
	} );
	
	// Add cssHook and .fx.step function for each named hook.
	// accept a space separated string of properties
	color.hook = function( hook ) {
		var hooks = hook.split( " " );
		each( hooks, function( i, hook ) {
			jQuery.cssHooks[ hook ] = {
				set: function( elem, value ) {
					var parsed, curElem,
						backgroundColor = "";
	
					if ( value !== "transparent" && ( jQuery.type( value ) !== "string" ||
							( parsed = stringParse( value ) ) ) ) {
						value = color( parsed || value );
						if ( !support.rgba && value._rgba[ 3 ] !== 1 ) {
							curElem = hook === "backgroundColor" ? elem.parentNode : elem;
							while (
								( backgroundColor === "" || backgroundColor === "transparent" ) &&
								curElem && curElem.style
							) {
								try {
									backgroundColor = jQuery.css( curElem, "backgroundColor" );
									curElem = curElem.parentNode;
								} catch ( e ) {
								}
							}
	
							value = value.blend( backgroundColor && backgroundColor !== "transparent" ?
								backgroundColor :
								"_default" );
						}
	
						value = value.toRgbaString();
					}
					try {
						elem.style[ hook ] = value;
					} catch ( e ) {
	
						// Wrapped to prevent IE from throwing errors on "invalid" values like
						// 'auto' or 'inherit'
					}
				}
			};
			jQuery.fx.step[ hook ] = function( fx ) {
				if ( !fx.colorInit ) {
					fx.start = color( fx.elem, hook );
					fx.end = color( fx.end );
					fx.colorInit = true;
				}
				jQuery.cssHooks[ hook ].set( fx.elem, fx.start.transition( fx.end, fx.pos ) );
			};
		} );
	
	};
	
	color.hook( stepHooks );
	
	jQuery.cssHooks.borderColor = {
		expand: function( value ) {
			var expanded = {};
	
			each( [ "Top", "Right", "Bottom", "Left" ], function( i, part ) {
				expanded[ "border" + part + "Color" ] = value;
			} );
			return expanded;
		}
	};
	
	// Basic color names only.
	// Usage of any of the other color names requires adding yourself or including
	// jquery.color.svg-names.js.
	colors = jQuery.Color.names = {
	
		// 4.1. Basic color keywords
		aqua: "#00ffff",
		black: "#000000",
		blue: "#0000ff",
		fuchsia: "#ff00ff",
		gray: "#808080",
		green: "#008000",
		lime: "#00ff00",
		maroon: "#800000",
		navy: "#000080",
		olive: "#808000",
		purple: "#800080",
		red: "#ff0000",
		silver: "#c0c0c0",
		teal: "#008080",
		white: "#ffffff",
		yellow: "#ffff00",
	
		// 4.2.3. "transparent" color keyword
		transparent: [ null, null, null, 0 ],
	
		_default: "#ffffff"
	};
	
	} )( jQuery );
	
	/******************************************************************************/
	/****************************** CLASS ANIMATIONS ******************************/
	/******************************************************************************/
	( function() {
	
	var classAnimationActions = [ "add", "remove", "toggle" ],
		shorthandStyles = {
			border: 1,
			borderBottom: 1,
			borderColor: 1,
			borderLeft: 1,
			borderRight: 1,
			borderTop: 1,
			borderWidth: 1,
			margin: 1,
			padding: 1
		};
	
	$.each(
		[ "borderLeftStyle", "borderRightStyle", "borderBottomStyle", "borderTopStyle" ],
		function( _, prop ) {
			$.fx.step[ prop ] = function( fx ) {
				if ( fx.end !== "none" && !fx.setAttr || fx.pos === 1 && !fx.setAttr ) {
					jQuery.style( fx.elem, prop, fx.end );
					fx.setAttr = true;
				}
			};
		}
	);
	
	function getElementStyles( elem ) {
		var key, len,
			style = elem.ownerDocument.defaultView ?
				elem.ownerDocument.defaultView.getComputedStyle( elem, null ) :
				elem.currentStyle,
			styles = {};
	
		if ( style && style.length && style[ 0 ] && style[ style[ 0 ] ] ) {
			len = style.length;
			while ( len-- ) {
				key = style[ len ];
				if ( typeof style[ key ] === "string" ) {
					styles[ $.camelCase( key ) ] = style[ key ];
				}
			}
	
		// Support: Opera, IE <9
		} else {
			for ( key in style ) {
				if ( typeof style[ key ] === "string" ) {
					styles[ key ] = style[ key ];
				}
			}
		}
	
		return styles;
	}
	
	function styleDifference( oldStyle, newStyle ) {
		var diff = {},
			name, value;
	
		for ( name in newStyle ) {
			value = newStyle[ name ];
			if ( oldStyle[ name ] !== value ) {
				if ( !shorthandStyles[ name ] ) {
					if ( $.fx.step[ name ] || !isNaN( parseFloat( value ) ) ) {
						diff[ name ] = value;
					}
				}
			}
		}
	
		return diff;
	}
	
	// Support: jQuery <1.8
	if ( !$.fn.addBack ) {
		$.fn.addBack = function( selector ) {
			return this.add( selector == null ?
				this.prevObject : this.prevObject.filter( selector )
			);
		};
	}
	
	$.effects.animateClass = function( value, duration, easing, callback ) {
		var o = $.speed( duration, easing, callback );
	
		return this.queue( function() {
			var animated = $( this ),
				baseClass = animated.attr( "class" ) || "",
				applyClassChange,
				allAnimations = o.children ? animated.find( "*" ).addBack() : animated;
	
			// Map the animated objects to store the original styles.
			allAnimations = allAnimations.map( function() {
				var el = $( this );
				return {
					el: el,
					start: getElementStyles( this )
				};
			} );
	
			// Apply class change
			applyClassChange = function() {
				$.each( classAnimationActions, function( i, action ) {
					if ( value[ action ] ) {
						animated[ action + "Class" ]( value[ action ] );
					}
				} );
			};
			applyClassChange();
	
			// Map all animated objects again - calculate new styles and diff
			allAnimations = allAnimations.map( function() {
				this.end = getElementStyles( this.el[ 0 ] );
				this.diff = styleDifference( this.start, this.end );
				return this;
			} );
	
			// Apply original class
			animated.attr( "class", baseClass );
	
			// Map all animated objects again - this time collecting a promise
			allAnimations = allAnimations.map( function() {
				var styleInfo = this,
					dfd = $.Deferred(),
					opts = $.extend( {}, o, {
						queue: false,
						complete: function() {
							dfd.resolve( styleInfo );
						}
					} );
	
				this.el.animate( this.diff, opts );
				return dfd.promise();
			} );
	
			// Once all animations have completed:
			$.when.apply( $, allAnimations.get() ).done( function() {
	
				// Set the final class
				applyClassChange();
	
				// For each animated element,
				// clear all css properties that were animated
				$.each( arguments, function() {
					var el = this.el;
					$.each( this.diff, function( key ) {
						el.css( key, "" );
					} );
				} );
	
				// This is guarnteed to be there if you use jQuery.speed()
				// it also handles dequeuing the next anim...
				o.complete.call( animated[ 0 ] );
			} );
		} );
	};
	
	$.fn.extend( {
		addClass: ( function( orig ) {
			return function( classNames, speed, easing, callback ) {
				return speed ?
					$.effects.animateClass.call( this,
						{ add: classNames }, speed, easing, callback ) :
					orig.apply( this, arguments );
			};
		} )( $.fn.addClass ),
	
		removeClass: ( function( orig ) {
			return function( classNames, speed, easing, callback ) {
				return arguments.length > 1 ?
					$.effects.animateClass.call( this,
						{ remove: classNames }, speed, easing, callback ) :
					orig.apply( this, arguments );
			};
		} )( $.fn.removeClass ),
	
		toggleClass: ( function( orig ) {
			return function( classNames, force, speed, easing, callback ) {
				if ( typeof force === "boolean" || force === undefined ) {
					if ( !speed ) {
	
						// Without speed parameter
						return orig.apply( this, arguments );
					} else {
						return $.effects.animateClass.call( this,
							( force ? { add: classNames } : { remove: classNames } ),
							speed, easing, callback );
					}
				} else {
	
					// Without force parameter
					return $.effects.animateClass.call( this,
						{ toggle: classNames }, force, speed, easing );
				}
			};
		} )( $.fn.toggleClass ),
	
		switchClass: function( remove, add, speed, easing, callback ) {
			return $.effects.animateClass.call( this, {
				add: add,
				remove: remove
			}, speed, easing, callback );
		}
	} );
	
	} )();
	
	/******************************************************************************/
	/*********************************** EFFECTS **********************************/
	/******************************************************************************/
	
	( function() {
	
	if ( $.expr && $.expr.filters && $.expr.filters.animated ) {
		$.expr.filters.animated = ( function( orig ) {
			return function( elem ) {
				return !!$( elem ).data( dataSpaceAnimated ) || orig( elem );
			};
		} )( $.expr.filters.animated );
	}
	
	if ( $.uiBackCompat !== false ) {
		$.extend( $.effects, {
	
			// Saves a set of properties in a data storage
			save: function( element, set ) {
				var i = 0, length = set.length;
				for ( ; i < length; i++ ) {
					if ( set[ i ] !== null ) {
						element.data( dataSpace + set[ i ], element[ 0 ].style[ set[ i ] ] );
					}
				}
			},
	
			// Restores a set of previously saved properties from a data storage
			restore: function( element, set ) {
				var val, i = 0, length = set.length;
				for ( ; i < length; i++ ) {
					if ( set[ i ] !== null ) {
						val = element.data( dataSpace + set[ i ] );
						element.css( set[ i ], val );
					}
				}
			},
	
			setMode: function( el, mode ) {
				if ( mode === "toggle" ) {
					mode = el.is( ":hidden" ) ? "show" : "hide";
				}
				return mode;
			},
	
			// Wraps the element around a wrapper that copies position properties
			createWrapper: function( element ) {
	
				// If the element is already wrapped, return it
				if ( element.parent().is( ".ui-effects-wrapper" ) ) {
					return element.parent();
				}
	
				// Wrap the element
				var props = {
						width: element.outerWidth( true ),
						height: element.outerHeight( true ),
						"float": element.css( "float" )
					},
					wrapper = $( "<div></div>" )
						.addClass( "ui-effects-wrapper" )
						.css( {
							fontSize: "100%",
							background: "transparent",
							border: "none",
							margin: 0,
							padding: 0
						} ),
	
					// Store the size in case width/height are defined in % - Fixes #5245
					size = {
						width: element.width(),
						height: element.height()
					},
					active = document.activeElement;
	
				// Support: Firefox
				// Firefox incorrectly exposes anonymous content
				// https://bugzilla.mozilla.org/show_bug.cgi?id=561664
				try {
					active.id;
				} catch ( e ) {
					active = document.body;
				}
	
				element.wrap( wrapper );
	
				// Fixes #7595 - Elements lose focus when wrapped.
				if ( element[ 0 ] === active || $.contains( element[ 0 ], active ) ) {
					$( active ).trigger( "focus" );
				}
	
				// Hotfix for jQuery 1.4 since some change in wrap() seems to actually
				// lose the reference to the wrapped element
				wrapper = element.parent();
	
				// Transfer positioning properties to the wrapper
				if ( element.css( "position" ) === "static" ) {
					wrapper.css( { position: "relative" } );
					element.css( { position: "relative" } );
				} else {
					$.extend( props, {
						position: element.css( "position" ),
						zIndex: element.css( "z-index" )
					} );
					$.each( [ "top", "left", "bottom", "right" ], function( i, pos ) {
						props[ pos ] = element.css( pos );
						if ( isNaN( parseInt( props[ pos ], 10 ) ) ) {
							props[ pos ] = "auto";
						}
					} );
					element.css( {
						position: "relative",
						top: 0,
						left: 0,
						right: "auto",
						bottom: "auto"
					} );
				}
				element.css( size );
	
				return wrapper.css( props ).show();
			},
	
			removeWrapper: function( element ) {
				var active = document.activeElement;
	
				if ( element.parent().is( ".ui-effects-wrapper" ) ) {
					element.parent().replaceWith( element );
	
					// Fixes #7595 - Elements lose focus when wrapped.
					if ( element[ 0 ] === active || $.contains( element[ 0 ], active ) ) {
						$( active ).trigger( "focus" );
					}
				}
	
				return element;
			}
		} );
	}
	
	$.extend( $.effects, {
		version: "1.12.0",
	
		define: function( name, mode, effect ) {
			if ( !effect ) {
				effect = mode;
				mode = "effect";
			}
	
			$.effects.effect[ name ] = effect;
			$.effects.effect[ name ].mode = mode;
	
			return effect;
		},
	
		scaledDimensions: function( element, percent, direction ) {
			if ( percent === 0 ) {
				return {
					height: 0,
					width: 0,
					outerHeight: 0,
					outerWidth: 0
				};
			}
	
			var x = direction !== "horizontal" ? ( ( percent || 100 ) / 100 ) : 1,
				y = direction !== "vertical" ? ( ( percent || 100 ) / 100 ) : 1;
	
			return {
				height: element.height() * y,
				width: element.width() * x,
				outerHeight: element.outerHeight() * y,
				outerWidth: element.outerWidth() * x
			};
	
		},
	
		clipToBox: function( animation ) {
			return {
				width: animation.clip.right - animation.clip.left,
				height: animation.clip.bottom - animation.clip.top,
				left: animation.clip.left,
				top: animation.clip.top
			};
		},
	
		// Injects recently queued functions to be first in line (after "inprogress")
		unshift: function( element, queueLength, count ) {
			var queue = element.queue();
	
			if ( queueLength > 1 ) {
				queue.splice.apply( queue,
					[ 1, 0 ].concat( queue.splice( queueLength, count ) ) );
			}
			element.dequeue();
		},
	
		saveStyle: function( element ) {
			element.data( dataSpaceStyle, element[ 0 ].style.cssText );
		},
	
		restoreStyle: function( element ) {
			element[ 0 ].style.cssText = element.data( dataSpaceStyle ) || "";
			element.removeData( dataSpaceStyle );
		},
	
		mode: function( element, mode ) {
			var hidden = element.is( ":hidden" );
	
			if ( mode === "toggle" ) {
				mode = hidden ? "show" : "hide";
			}
			if ( hidden ? mode === "hide" : mode === "show" ) {
				mode = "none";
			}
			return mode;
		},
	
		// Translates a [top,left] array into a baseline value
		getBaseline: function( origin, original ) {
			var y, x;
	
			switch ( origin[ 0 ] ) {
			case "top":
				y = 0;
				break;
			case "middle":
				y = 0.5;
				break;
			case "bottom":
				y = 1;
				break;
			default:
				y = origin[ 0 ] / original.height;
			}
	
			switch ( origin[ 1 ] ) {
			case "left":
				x = 0;
				break;
			case "center":
				x = 0.5;
				break;
			case "right":
				x = 1;
				break;
			default:
				x = origin[ 1 ] / original.width;
			}
	
			return {
				x: x,
				y: y
			};
		},
	
		// Creates a placeholder element so that the original element can be made absolute
		createPlaceholder: function( element ) {
			var placeholder,
				cssPosition = element.css( "position" ),
				position = element.position();
	
			// Lock in margins first to account for form elements, which
			// will change margin if you explicitly set height
			// see: http://jsfiddle.net/JZSMt/3/ https://bugs.webkit.org/show_bug.cgi?id=107380
			// Support: Safari
			element.css( {
				marginTop: element.css( "marginTop" ),
				marginBottom: element.css( "marginBottom" ),
				marginLeft: element.css( "marginLeft" ),
				marginRight: element.css( "marginRight" )
			} )
			.outerWidth( element.outerWidth() )
			.outerHeight( element.outerHeight() );
	
			if ( /^(static|relative)/.test( cssPosition ) ) {
				cssPosition = "absolute";
	
				placeholder = $( "<" + element[ 0 ].nodeName + ">" ).insertAfter( element ).css( {
	
					// Convert inline to inline block to account for inline elements
					// that turn to inline block based on content (like img)
					display: /^(inline|ruby)/.test( element.css( "display" ) ) ?
						"inline-block" :
						"block",
					visibility: "hidden",
	
					// Margins need to be set to account for margin collapse
					marginTop: element.css( "marginTop" ),
					marginBottom: element.css( "marginBottom" ),
					marginLeft: element.css( "marginLeft" ),
					marginRight: element.css( "marginRight" ),
					"float": element.css( "float" )
				} )
				.outerWidth( element.outerWidth() )
				.outerHeight( element.outerHeight() )
				.addClass( "ui-effects-placeholder" );
	
				element.data( dataSpace + "placeholder", placeholder );
			}
	
			element.css( {
				position: cssPosition,
				left: position.left,
				top: position.top
			} );
	
			return placeholder;
		},
	
		removePlaceholder: function( element ) {
			var dataKey = dataSpace + "placeholder",
					placeholder = element.data( dataKey );
	
			if ( placeholder ) {
				placeholder.remove();
				element.removeData( dataKey );
			}
		},
	
		// Removes a placeholder if it exists and restores
		// properties that were modified during placeholder creation
		cleanUp: function( element ) {
			$.effects.restoreStyle( element );
			$.effects.removePlaceholder( element );
		},
	
		setTransition: function( element, list, factor, value ) {
			value = value || {};
			$.each( list, function( i, x ) {
				var unit = element.cssUnit( x );
				if ( unit[ 0 ] > 0 ) {
					value[ x ] = unit[ 0 ] * factor + unit[ 1 ];
				}
			} );
			return value;
		}
	} );
	
	// Return an effect options object for the given parameters:
	function _normalizeArguments( effect, options, speed, callback ) {
	
		// Allow passing all options as the first parameter
		if ( $.isPlainObject( effect ) ) {
			options = effect;
			effect = effect.effect;
		}
	
		// Convert to an object
		effect = { effect: effect };
	
		// Catch (effect, null, ...)
		if ( options == null ) {
			options = {};
		}
	
		// Catch (effect, callback)
		if ( $.isFunction( options ) ) {
			callback = options;
			speed = null;
			options = {};
		}
	
		// Catch (effect, speed, ?)
		if ( typeof options === "number" || $.fx.speeds[ options ] ) {
			callback = speed;
			speed = options;
			options = {};
		}
	
		// Catch (effect, options, callback)
		if ( $.isFunction( speed ) ) {
			callback = speed;
			speed = null;
		}
	
		// Add options to effect
		if ( options ) {
			$.extend( effect, options );
		}
	
		speed = speed || options.duration;
		effect.duration = $.fx.off ? 0 :
			typeof speed === "number" ? speed :
			speed in $.fx.speeds ? $.fx.speeds[ speed ] :
			$.fx.speeds._default;
	
		effect.complete = callback || options.complete;
	
		return effect;
	}
	
	function standardAnimationOption( option ) {
	
		// Valid standard speeds (nothing, number, named speed)
		if ( !option || typeof option === "number" || $.fx.speeds[ option ] ) {
			return true;
		}
	
		// Invalid strings - treat as "normal" speed
		if ( typeof option === "string" && !$.effects.effect[ option ] ) {
			return true;
		}
	
		// Complete callback
		if ( $.isFunction( option ) ) {
			return true;
		}
	
		// Options hash (but not naming an effect)
		if ( typeof option === "object" && !option.effect ) {
			return true;
		}
	
		// Didn't match any standard API
		return false;
	}
	
	$.fn.extend( {
		effect: function( /* effect, options, speed, callback */ ) {
			var args = _normalizeArguments.apply( this, arguments ),
				effectMethod = $.effects.effect[ args.effect ],
				defaultMode = effectMethod.mode,
				queue = args.queue,
				queueName = queue || "fx",
				complete = args.complete,
				mode = args.mode,
				modes = [],
				prefilter = function( next ) {
					var el = $( this ),
						normalizedMode = $.effects.mode( el, mode ) || defaultMode;
	
					// Sentinel for duck-punching the :animated psuedo-selector
					el.data( dataSpaceAnimated, true );
	
					// Save effect mode for later use,
					// we can't just call $.effects.mode again later,
					// as the .show() below destroys the initial state
					modes.push( normalizedMode );
	
					// See $.uiBackCompat inside of run() for removal of defaultMode in 1.13
					if ( defaultMode && ( normalizedMode === "show" ||
							( normalizedMode === defaultMode && normalizedMode === "hide" ) ) ) {
						el.show();
					}
	
					if ( !defaultMode || normalizedMode !== "none" ) {
						$.effects.saveStyle( el );
					}
	
					if ( $.isFunction( next ) ) {
						next();
					}
				};
	
			if ( $.fx.off || !effectMethod ) {
	
				// Delegate to the original method (e.g., .show()) if possible
				if ( mode ) {
					return this[ mode ]( args.duration, complete );
				} else {
					return this.each( function() {
						if ( complete ) {
							complete.call( this );
						}
					} );
				}
			}
	
			function run( next ) {
				var elem = $( this );
	
				function cleanup() {
					elem.removeData( dataSpaceAnimated );
	
					$.effects.cleanUp( elem );
	
					if ( args.mode === "hide" ) {
						elem.hide();
					}
	
					done();
				}
	
				function done() {
					if ( $.isFunction( complete ) ) {
						complete.call( elem[ 0 ] );
					}
	
					if ( $.isFunction( next ) ) {
						next();
					}
				}
	
				// Override mode option on a per element basis,
				// as toggle can be either show or hide depending on element state
				args.mode = modes.shift();
	
				if ( $.uiBackCompat !== false && !defaultMode ) {
					if ( elem.is( ":hidden" ) ? mode === "hide" : mode === "show" ) {
	
						// Call the core method to track "olddisplay" properly
						elem[ mode ]();
						done();
					} else {
						effectMethod.call( elem[ 0 ], args, done );
					}
				} else {
					if ( args.mode === "none" ) {
	
						// Call the core method to track "olddisplay" properly
						elem[ mode ]();
						done();
					} else {
						effectMethod.call( elem[ 0 ], args, cleanup );
					}
				}
			}
	
			// Run prefilter on all elements first to ensure that
			// any showing or hiding happens before placeholder creation,
			// which ensures that any layout changes are correctly captured.
			return queue === false ?
				this.each( prefilter ).each( run ) :
				this.queue( queueName, prefilter ).queue( queueName, run );
		},
	
		show: ( function( orig ) {
			return function( option ) {
				if ( standardAnimationOption( option ) ) {
					return orig.apply( this, arguments );
				} else {
					var args = _normalizeArguments.apply( this, arguments );
					args.mode = "show";
					return this.effect.call( this, args );
				}
			};
		} )( $.fn.show ),
	
		hide: ( function( orig ) {
			return function( option ) {
				if ( standardAnimationOption( option ) ) {
					return orig.apply( this, arguments );
				} else {
					var args = _normalizeArguments.apply( this, arguments );
					args.mode = "hide";
					return this.effect.call( this, args );
				}
			};
		} )( $.fn.hide ),
	
		toggle: ( function( orig ) {
			return function( option ) {
				if ( standardAnimationOption( option ) || typeof option === "boolean" ) {
					return orig.apply( this, arguments );
				} else {
					var args = _normalizeArguments.apply( this, arguments );
					args.mode = "toggle";
					return this.effect.call( this, args );
				}
			};
		} )( $.fn.toggle ),
	
		cssUnit: function( key ) {
			var style = this.css( key ),
				val = [];
	
			$.each( [ "em", "px", "%", "pt" ], function( i, unit ) {
				if ( style.indexOf( unit ) > 0 ) {
					val = [ parseFloat( style ), unit ];
				}
			} );
			return val;
		},
	
		cssClip: function( clipObj ) {
			if ( clipObj ) {
				return this.css( "clip", "rect(" + clipObj.top + "px " + clipObj.right + "px " +
					clipObj.bottom + "px " + clipObj.left + "px)" );
			}
			return parseClip( this.css( "clip" ), this );
		},
	
		transfer: function( options, done ) {
			var element = $( this ),
				target = $( options.to ),
				targetFixed = target.css( "position" ) === "fixed",
				body = $( "body" ),
				fixTop = targetFixed ? body.scrollTop() : 0,
				fixLeft = targetFixed ? body.scrollLeft() : 0,
				endPosition = target.offset(),
				animation = {
					top: endPosition.top - fixTop,
					left: endPosition.left - fixLeft,
					height: target.innerHeight(),
					width: target.innerWidth()
				},
				startPosition = element.offset(),
				transfer = $( "<div class='ui-effects-transfer'></div>" )
					.appendTo( "body" )
					.addClass( options.className )
					.css( {
						top: startPosition.top - fixTop,
						left: startPosition.left - fixLeft,
						height: element.innerHeight(),
						width: element.innerWidth(),
						position: targetFixed ? "fixed" : "absolute"
					} )
					.animate( animation, options.duration, options.easing, function() {
						transfer.remove();
						if ( $.isFunction( done ) ) {
							done();
						}
					} );
		}
	} );
	
	function parseClip( str, element ) {
			var outerWidth = element.outerWidth(),
				outerHeight = element.outerHeight(),
				clipRegex = /^rect\((-?\d*\.?\d*px|-?\d+%|auto),?\s*(-?\d*\.?\d*px|-?\d+%|auto),?\s*(-?\d*\.?\d*px|-?\d+%|auto),?\s*(-?\d*\.?\d*px|-?\d+%|auto)\)$/,
				values = clipRegex.exec( str ) || [ "", 0, outerWidth, outerHeight, 0 ];
	
			return {
				top: parseFloat( values[ 1 ] ) || 0,
				right: values[ 2 ] === "auto" ? outerWidth : parseFloat( values[ 2 ] ),
				bottom: values[ 3 ] === "auto" ? outerHeight : parseFloat( values[ 3 ] ),
				left: parseFloat( values[ 4 ] ) || 0
			};
	}
	
	$.fx.step.clip = function( fx ) {
		if ( !fx.clipInit ) {
			fx.start = $( fx.elem ).cssClip();
			if ( typeof fx.end === "string" ) {
				fx.end = parseClip( fx.end, fx.elem );
			}
			fx.clipInit = true;
		}
	
		$( fx.elem ).cssClip( {
			top: fx.pos * ( fx.end.top - fx.start.top ) + fx.start.top,
			right: fx.pos * ( fx.end.right - fx.start.right ) + fx.start.right,
			bottom: fx.pos * ( fx.end.bottom - fx.start.bottom ) + fx.start.bottom,
			left: fx.pos * ( fx.end.left - fx.start.left ) + fx.start.left
		} );
	};
	
	} )();
	
	/******************************************************************************/
	/*********************************** EASING ***********************************/
	/******************************************************************************/
	
	( function() {
	
	// Based on easing equations from Robert Penner (http://www.robertpenner.com/easing)
	
	var baseEasings = {};
	
	$.each( [ "Quad", "Cubic", "Quart", "Quint", "Expo" ], function( i, name ) {
		baseEasings[ name ] = function( p ) {
			return Math.pow( p, i + 2 );
		};
	} );
	
	$.extend( baseEasings, {
		Sine: function( p ) {
			return 1 - Math.cos( p * Math.PI / 2 );
		},
		Circ: function( p ) {
			return 1 - Math.sqrt( 1 - p * p );
		},
		Elastic: function( p ) {
			return p === 0 || p === 1 ? p :
				-Math.pow( 2, 8 * ( p - 1 ) ) * Math.sin( ( ( p - 1 ) * 80 - 7.5 ) * Math.PI / 15 );
		},
		Back: function( p ) {
			return p * p * ( 3 * p - 2 );
		},
		Bounce: function( p ) {
			var pow2,
				bounce = 4;
	
			while ( p < ( ( pow2 = Math.pow( 2, --bounce ) ) - 1 ) / 11 ) {}
			return 1 / Math.pow( 4, 3 - bounce ) - 7.5625 * Math.pow( ( pow2 * 3 - 2 ) / 22 - p, 2 );
		}
	} );
	
	$.each( baseEasings, function( name, easeIn ) {
		$.easing[ "easeIn" + name ] = easeIn;
		$.easing[ "easeOut" + name ] = function( p ) {
			return 1 - easeIn( 1 - p );
		};
		$.easing[ "easeInOut" + name ] = function( p ) {
			return p < 0.5 ?
				easeIn( p * 2 ) / 2 :
				1 - easeIn( p * -2 + 2 ) / 2;
		};
	} );
	
	} )();
	
	var effect = $.effects;
	
	
	/*!
	 * jQuery UI Effects Blind 1.12.0
	 * http://jqueryui.com
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license.
	 * http://jquery.org/license
	 */
	
	//>>label: Blind Effect
	//>>group: Effects
	//>>description: Blinds the element.
	//>>docs: http://api.jqueryui.com/blind-effect/
	//>>demos: http://jqueryui.com/effect/
	
	
	
	var effectsEffectBlind = $.effects.define( "blind", "hide", function( options, done ) {
		var map = {
				up: [ "bottom", "top" ],
				vertical: [ "bottom", "top" ],
				down: [ "top", "bottom" ],
				left: [ "right", "left" ],
				horizontal: [ "right", "left" ],
				right: [ "left", "right" ]
			},
			element = $( this ),
			direction = options.direction || "up",
			start = element.cssClip(),
			animate = { clip: $.extend( {}, start ) },
			placeholder = $.effects.createPlaceholder( element );
	
		animate.clip[ map[ direction ][ 0 ] ] = animate.clip[ map[ direction ][ 1 ] ];
	
		if ( options.mode === "show" ) {
			element.cssClip( animate.clip );
			if ( placeholder ) {
				placeholder.css( $.effects.clipToBox( animate ) );
			}
	
			animate.clip = start;
		}
	
		if ( placeholder ) {
			placeholder.animate( $.effects.clipToBox( animate ), options.duration, options.easing );
		}
	
		element.animate( animate, {
			queue: false,
			duration: options.duration,
			easing: options.easing,
			complete: done
		} );
	} );
	
	
	/*!
	 * jQuery UI Effects Bounce 1.12.0
	 * http://jqueryui.com
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license.
	 * http://jquery.org/license
	 */
	
	//>>label: Bounce Effect
	//>>group: Effects
	//>>description: Bounces an element horizontally or vertically n times.
	//>>docs: http://api.jqueryui.com/bounce-effect/
	//>>demos: http://jqueryui.com/effect/
	
	
	
	var effectsEffectBounce = $.effects.define( "bounce", function( options, done ) {
		var upAnim, downAnim, refValue,
			element = $( this ),
	
			// Defaults:
			mode = options.mode,
			hide = mode === "hide",
			show = mode === "show",
			direction = options.direction || "up",
			distance = options.distance,
			times = options.times || 5,
	
			// Number of internal animations
			anims = times * 2 + ( show || hide ? 1 : 0 ),
			speed = options.duration / anims,
			easing = options.easing,
	
			// Utility:
			ref = ( direction === "up" || direction === "down" ) ? "top" : "left",
			motion = ( direction === "up" || direction === "left" ),
			i = 0,
	
			queuelen = element.queue().length;
	
		$.effects.createPlaceholder( element );
	
		refValue = element.css( ref );
	
		// Default distance for the BIGGEST bounce is the outer Distance / 3
		if ( !distance ) {
			distance = element[ ref === "top" ? "outerHeight" : "outerWidth" ]() / 3;
		}
	
		if ( show ) {
			downAnim = { opacity: 1 };
			downAnim[ ref ] = refValue;
	
			// If we are showing, force opacity 0 and set the initial position
			// then do the "first" animation
			element
				.css( "opacity", 0 )
				.css( ref, motion ? -distance * 2 : distance * 2 )
				.animate( downAnim, speed, easing );
		}
	
		// Start at the smallest distance if we are hiding
		if ( hide ) {
			distance = distance / Math.pow( 2, times - 1 );
		}
	
		downAnim = {};
		downAnim[ ref ] = refValue;
	
		// Bounces up/down/left/right then back to 0 -- times * 2 animations happen here
		for ( ; i < times; i++ ) {
			upAnim = {};
			upAnim[ ref ] = ( motion ? "-=" : "+=" ) + distance;
	
			element
				.animate( upAnim, speed, easing )
				.animate( downAnim, speed, easing );
	
			distance = hide ? distance * 2 : distance / 2;
		}
	
		// Last Bounce when Hiding
		if ( hide ) {
			upAnim = { opacity: 0 };
			upAnim[ ref ] = ( motion ? "-=" : "+=" ) + distance;
	
			element.animate( upAnim, speed, easing );
		}
	
		element.queue( done );
	
		$.effects.unshift( element, queuelen, anims + 1 );
	} );
	
	
	/*!
	 * jQuery UI Effects Clip 1.12.0
	 * http://jqueryui.com
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license.
	 * http://jquery.org/license
	 */
	
	//>>label: Clip Effect
	//>>group: Effects
	//>>description: Clips the element on and off like an old TV.
	//>>docs: http://api.jqueryui.com/clip-effect/
	//>>demos: http://jqueryui.com/effect/
	
	
	
	var effectsEffectClip = $.effects.define( "clip", "hide", function( options, done ) {
		var start,
			animate = {},
			element = $( this ),
			direction = options.direction || "vertical",
			both = direction === "both",
			horizontal = both || direction === "horizontal",
			vertical = both || direction === "vertical";
	
		start = element.cssClip();
		animate.clip = {
			top: vertical ? ( start.bottom - start.top ) / 2 : start.top,
			right: horizontal ? ( start.right - start.left ) / 2 : start.right,
			bottom: vertical ? ( start.bottom - start.top ) / 2 : start.bottom,
			left: horizontal ? ( start.right - start.left ) / 2 : start.left
		};
	
		$.effects.createPlaceholder( element );
	
		if ( options.mode === "show" ) {
			element.cssClip( animate.clip );
			animate.clip = start;
		}
	
		element.animate( animate, {
			queue: false,
			duration: options.duration,
			easing: options.easing,
			complete: done
		} );
	
	} );
	
	
	/*!
	 * jQuery UI Effects Drop 1.12.0
	 * http://jqueryui.com
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license.
	 * http://jquery.org/license
	 */
	
	//>>label: Drop Effect
	//>>group: Effects
	//>>description: Moves an element in one direction and hides it at the same time.
	//>>docs: http://api.jqueryui.com/drop-effect/
	//>>demos: http://jqueryui.com/effect/
	
	
	
	var effectsEffectDrop = $.effects.define( "drop", "hide", function( options, done ) {
	
		var distance,
			element = $( this ),
			mode = options.mode,
			show = mode === "show",
			direction = options.direction || "left",
			ref = ( direction === "up" || direction === "down" ) ? "top" : "left",
			motion = ( direction === "up" || direction === "left" ) ? "-=" : "+=",
			oppositeMotion = ( motion === "+=" ) ? "-=" : "+=",
			animation = {
				opacity: 0
			};
	
		$.effects.createPlaceholder( element );
	
		distance = options.distance ||
			element[ ref === "top" ? "outerHeight" : "outerWidth" ]( true ) / 2;
	
		animation[ ref ] = motion + distance;
	
		if ( show ) {
			element.css( animation );
	
			animation[ ref ] = oppositeMotion + distance;
			animation.opacity = 1;
		}
	
		// Animate
		element.animate( animation, {
			queue: false,
			duration: options.duration,
			easing: options.easing,
			complete: done
		} );
	} );
	
	
	/*!
	 * jQuery UI Effects Explode 1.12.0
	 * http://jqueryui.com
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license.
	 * http://jquery.org/license
	 */
	
	//>>label: Explode Effect
	//>>group: Effects
	// jscs:disable maximumLineLength
	//>>description: Explodes an element in all directions into n pieces. Implodes an element to its original wholeness.
	// jscs:enable maximumLineLength
	//>>docs: http://api.jqueryui.com/explode-effect/
	//>>demos: http://jqueryui.com/effect/
	
	
	
	var effectsEffectExplode = $.effects.define( "explode", "hide", function( options, done ) {
	
		var i, j, left, top, mx, my,
			rows = options.pieces ? Math.round( Math.sqrt( options.pieces ) ) : 3,
			cells = rows,
			element = $( this ),
			mode = options.mode,
			show = mode === "show",
	
			// Show and then visibility:hidden the element before calculating offset
			offset = element.show().css( "visibility", "hidden" ).offset(),
	
			// Width and height of a piece
			width = Math.ceil( element.outerWidth() / cells ),
			height = Math.ceil( element.outerHeight() / rows ),
			pieces = [];
	
		// Children animate complete:
		function childComplete() {
			pieces.push( this );
			if ( pieces.length === rows * cells ) {
				animComplete();
			}
		}
	
		// Clone the element for each row and cell.
		for ( i = 0; i < rows; i++ ) { // ===>
			top = offset.top + i * height;
			my = i - ( rows - 1 ) / 2;
	
			for ( j = 0; j < cells; j++ ) { // |||
				left = offset.left + j * width;
				mx = j - ( cells - 1 ) / 2;
	
				// Create a clone of the now hidden main element that will be absolute positioned
				// within a wrapper div off the -left and -top equal to size of our pieces
				element
					.clone()
					.appendTo( "body" )
					.wrap( "<div></div>" )
					.css( {
						position: "absolute",
						visibility: "visible",
						left: -j * width,
						top: -i * height
					} )
	
					// Select the wrapper - make it overflow: hidden and absolute positioned based on
					// where the original was located +left and +top equal to the size of pieces
					.parent()
						.addClass( "ui-effects-explode" )
						.css( {
							position: "absolute",
							overflow: "hidden",
							width: width,
							height: height,
							left: left + ( show ? mx * width : 0 ),
							top: top + ( show ? my * height : 0 ),
							opacity: show ? 0 : 1
						} )
						.animate( {
							left: left + ( show ? 0 : mx * width ),
							top: top + ( show ? 0 : my * height ),
							opacity: show ? 1 : 0
						}, options.duration || 500, options.easing, childComplete );
			}
		}
	
		function animComplete() {
			element.css( {
				visibility: "visible"
			} );
			$( pieces ).remove();
			done();
		}
	} );
	
	
	/*!
	 * jQuery UI Effects Fade 1.12.0
	 * http://jqueryui.com
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license.
	 * http://jquery.org/license
	 */
	
	//>>label: Fade Effect
	//>>group: Effects
	//>>description: Fades the element.
	//>>docs: http://api.jqueryui.com/fade-effect/
	//>>demos: http://jqueryui.com/effect/
	
	
	
	var effectsEffectFade = $.effects.define( "fade", "toggle", function( options, done ) {
		var show = options.mode === "show";
	
		$( this )
			.css( "opacity", show ? 0 : 1 )
			.animate( {
				opacity: show ? 1 : 0
			}, {
				queue: false,
				duration: options.duration,
				easing: options.easing,
				complete: done
			} );
	} );
	
	
	/*!
	 * jQuery UI Effects Fold 1.12.0
	 * http://jqueryui.com
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license.
	 * http://jquery.org/license
	 */
	
	//>>label: Fold Effect
	//>>group: Effects
	//>>description: Folds an element first horizontally and then vertically.
	//>>docs: http://api.jqueryui.com/fold-effect/
	//>>demos: http://jqueryui.com/effect/
	
	
	
	var effectsEffectFold = $.effects.define( "fold", "hide", function( options, done ) {
	
		// Create element
		var element = $( this ),
			mode = options.mode,
			show = mode === "show",
			hide = mode === "hide",
			size = options.size || 15,
			percent = /([0-9]+)%/.exec( size ),
			horizFirst = !!options.horizFirst,
			ref = horizFirst ? [ "right", "bottom" ] : [ "bottom", "right" ],
			duration = options.duration / 2,
	
			placeholder = $.effects.createPlaceholder( element ),
	
			start = element.cssClip(),
			animation1 = { clip: $.extend( {}, start ) },
			animation2 = { clip: $.extend( {}, start ) },
	
			distance = [ start[ ref[ 0 ] ], start[ ref[ 1 ] ] ],
	
			queuelen = element.queue().length;
	
		if ( percent ) {
			size = parseInt( percent[ 1 ], 10 ) / 100 * distance[ hide ? 0 : 1 ];
		}
		animation1.clip[ ref[ 0 ] ] = size;
		animation2.clip[ ref[ 0 ] ] = size;
		animation2.clip[ ref[ 1 ] ] = 0;
	
		if ( show ) {
			element.cssClip( animation2.clip );
			if ( placeholder ) {
				placeholder.css( $.effects.clipToBox( animation2 ) );
			}
	
			animation2.clip = start;
		}
	
		// Animate
		element
			.queue( function( next ) {
				if ( placeholder ) {
					placeholder
						.animate( $.effects.clipToBox( animation1 ), duration, options.easing )
						.animate( $.effects.clipToBox( animation2 ), duration, options.easing );
				}
	
				next();
			} )
			.animate( animation1, duration, options.easing )
			.animate( animation2, duration, options.easing )
			.queue( done );
	
		$.effects.unshift( element, queuelen, 4 );
	} );
	
	
	/*!
	 * jQuery UI Effects Highlight 1.12.0
	 * http://jqueryui.com
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license.
	 * http://jquery.org/license
	 */
	
	//>>label: Highlight Effect
	//>>group: Effects
	//>>description: Highlights the background of an element in a defined color for a custom duration.
	//>>docs: http://api.jqueryui.com/highlight-effect/
	//>>demos: http://jqueryui.com/effect/
	
	
	
	var effectsEffectHighlight = $.effects.define( "highlight", "show", function( options, done ) {
		var element = $( this ),
			animation = {
				backgroundColor: element.css( "backgroundColor" )
			};
	
		if ( options.mode === "hide" ) {
			animation.opacity = 0;
		}
	
		$.effects.saveStyle( element );
	
		element
			.css( {
				backgroundImage: "none",
				backgroundColor: options.color || "#ffff99"
			} )
			.animate( animation, {
				queue: false,
				duration: options.duration,
				easing: options.easing,
				complete: done
			} );
	} );
	
	
	/*!
	 * jQuery UI Effects Size 1.12.0
	 * http://jqueryui.com
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license.
	 * http://jquery.org/license
	 */
	
	//>>label: Size Effect
	//>>group: Effects
	//>>description: Resize an element to a specified width and height.
	//>>docs: http://api.jqueryui.com/size-effect/
	//>>demos: http://jqueryui.com/effect/
	
	
	
	var effectsEffectSize = $.effects.define( "size", function( options, done ) {
	
		// Create element
		var baseline, factor, temp,
			element = $( this ),
	
			// Copy for children
			cProps = [ "fontSize" ],
			vProps = [ "borderTopWidth", "borderBottomWidth", "paddingTop", "paddingBottom" ],
			hProps = [ "borderLeftWidth", "borderRightWidth", "paddingLeft", "paddingRight" ],
	
			// Set options
			mode = options.mode,
			restore = mode !== "effect",
			scale = options.scale || "both",
			origin = options.origin || [ "middle", "center" ],
			position = element.css( "position" ),
			pos = element.position(),
			original = $.effects.scaledDimensions( element ),
			from = options.from || original,
			to = options.to || $.effects.scaledDimensions( element, 0 );
	
		$.effects.createPlaceholder( element );
	
		if ( mode === "show" ) {
			temp = from;
			from = to;
			to = temp;
		}
	
		// Set scaling factor
		factor = {
			from: {
				y: from.height / original.height,
				x: from.width / original.width
			},
			to: {
				y: to.height / original.height,
				x: to.width / original.width
			}
		};
	
		// Scale the css box
		if ( scale === "box" || scale === "both" ) {
	
			// Vertical props scaling
			if ( factor.from.y !== factor.to.y ) {
				from = $.effects.setTransition( element, vProps, factor.from.y, from );
				to = $.effects.setTransition( element, vProps, factor.to.y, to );
			}
	
			// Horizontal props scaling
			if ( factor.from.x !== factor.to.x ) {
				from = $.effects.setTransition( element, hProps, factor.from.x, from );
				to = $.effects.setTransition( element, hProps, factor.to.x, to );
			}
		}
	
		// Scale the content
		if ( scale === "content" || scale === "both" ) {
	
			// Vertical props scaling
			if ( factor.from.y !== factor.to.y ) {
				from = $.effects.setTransition( element, cProps, factor.from.y, from );
				to = $.effects.setTransition( element, cProps, factor.to.y, to );
			}
		}
	
		// Adjust the position properties based on the provided origin points
		if ( origin ) {
			baseline = $.effects.getBaseline( origin, original );
			from.top = ( original.outerHeight - from.outerHeight ) * baseline.y + pos.top;
			from.left = ( original.outerWidth - from.outerWidth ) * baseline.x + pos.left;
			to.top = ( original.outerHeight - to.outerHeight ) * baseline.y + pos.top;
			to.left = ( original.outerWidth - to.outerWidth ) * baseline.x + pos.left;
		}
		element.css( from );
	
		// Animate the children if desired
		if ( scale === "content" || scale === "both" ) {
	
			vProps = vProps.concat( [ "marginTop", "marginBottom" ] ).concat( cProps );
			hProps = hProps.concat( [ "marginLeft", "marginRight" ] );
	
			// Only animate children with width attributes specified
			// TODO: is this right? should we include anything with css width specified as well
			element.find( "*[width]" ).each( function() {
				var child = $( this ),
					childOriginal = $.effects.scaledDimensions( child ),
					childFrom = {
						height: childOriginal.height * factor.from.y,
						width: childOriginal.width * factor.from.x,
						outerHeight: childOriginal.outerHeight * factor.from.y,
						outerWidth: childOriginal.outerWidth * factor.from.x
					},
					childTo = {
						height: childOriginal.height * factor.to.y,
						width: childOriginal.width * factor.to.x,
						outerHeight: childOriginal.height * factor.to.y,
						outerWidth: childOriginal.width * factor.to.x
					};
	
				// Vertical props scaling
				if ( factor.from.y !== factor.to.y ) {
					childFrom = $.effects.setTransition( child, vProps, factor.from.y, childFrom );
					childTo = $.effects.setTransition( child, vProps, factor.to.y, childTo );
				}
	
				// Horizontal props scaling
				if ( factor.from.x !== factor.to.x ) {
					childFrom = $.effects.setTransition( child, hProps, factor.from.x, childFrom );
					childTo = $.effects.setTransition( child, hProps, factor.to.x, childTo );
				}
	
				if ( restore ) {
					$.effects.saveStyle( child );
				}
	
				// Animate children
				child.css( childFrom );
				child.animate( childTo, options.duration, options.easing, function() {
	
					// Restore children
					if ( restore ) {
						$.effects.restoreStyle( child );
					}
				} );
			} );
		}
	
		// Animate
		element.animate( to, {
			queue: false,
			duration: options.duration,
			easing: options.easing,
			complete: function() {
	
				var offset = element.offset();
	
				if ( to.opacity === 0 ) {
					element.css( "opacity", from.opacity );
				}
	
				if ( !restore ) {
					element
						.css( "position", position === "static" ? "relative" : position )
						.offset( offset );
	
					// Need to save style here so that automatic style restoration
					// doesn't restore to the original styles from before the animation.
					$.effects.saveStyle( element );
				}
	
				done();
			}
		} );
	
	} );
	
	
	/*!
	 * jQuery UI Effects Scale 1.12.0
	 * http://jqueryui.com
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license.
	 * http://jquery.org/license
	 */
	
	//>>label: Scale Effect
	//>>group: Effects
	//>>description: Grows or shrinks an element and its content.
	//>>docs: http://api.jqueryui.com/scale-effect/
	//>>demos: http://jqueryui.com/effect/
	
	
	
	var effectsEffectScale = $.effects.define( "scale", function( options, done ) {
	
		// Create element
		var el = $( this ),
			mode = options.mode,
			percent = parseInt( options.percent, 10 ) ||
				( parseInt( options.percent, 10 ) === 0 ? 0 : ( mode !== "effect" ? 0 : 100 ) ),
	
			newOptions = $.extend( true, {
				from: $.effects.scaledDimensions( el ),
				to: $.effects.scaledDimensions( el, percent, options.direction || "both" ),
				origin: options.origin || [ "middle", "center" ]
			}, options );
	
		// Fade option to support puff
		if ( options.fade ) {
			newOptions.from.opacity = 1;
			newOptions.to.opacity = 0;
		}
	
		$.effects.effect.size.call( this, newOptions, done );
	} );
	
	
	/*!
	 * jQuery UI Effects Puff 1.12.0
	 * http://jqueryui.com
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license.
	 * http://jquery.org/license
	 */
	
	//>>label: Puff Effect
	//>>group: Effects
	//>>description: Creates a puff effect by scaling the element up and hiding it at the same time.
	//>>docs: http://api.jqueryui.com/puff-effect/
	//>>demos: http://jqueryui.com/effect/
	
	
	
	var effectsEffectPuff = $.effects.define( "puff", "hide", function( options, done ) {
		var newOptions = $.extend( true, {}, options, {
			fade: true,
			percent: parseInt( options.percent, 10 ) || 150
		} );
	
		$.effects.effect.scale.call( this, newOptions, done );
	} );
	
	
	/*!
	 * jQuery UI Effects Pulsate 1.12.0
	 * http://jqueryui.com
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license.
	 * http://jquery.org/license
	 */
	
	//>>label: Pulsate Effect
	//>>group: Effects
	//>>description: Pulsates an element n times by changing the opacity to zero and back.
	//>>docs: http://api.jqueryui.com/pulsate-effect/
	//>>demos: http://jqueryui.com/effect/
	
	
	
	var effectsEffectPulsate = $.effects.define( "pulsate", "show", function( options, done ) {
		var element = $( this ),
			mode = options.mode,
			show = mode === "show",
			hide = mode === "hide",
			showhide = show || hide,
	
			// Showing or hiding leaves off the "last" animation
			anims = ( ( options.times || 5 ) * 2 ) + ( showhide ? 1 : 0 ),
			duration = options.duration / anims,
			animateTo = 0,
			i = 1,
			queuelen = element.queue().length;
	
		if ( show || !element.is( ":visible" ) ) {
			element.css( "opacity", 0 ).show();
			animateTo = 1;
		}
	
		// Anims - 1 opacity "toggles"
		for ( ; i < anims; i++ ) {
			element.animate( { opacity: animateTo }, duration, options.easing );
			animateTo = 1 - animateTo;
		}
	
		element.animate( { opacity: animateTo }, duration, options.easing );
	
		element.queue( done );
	
		$.effects.unshift( element, queuelen, anims + 1 );
	} );
	
	
	/*!
	 * jQuery UI Effects Slide 1.12.0
	 * http://jqueryui.com
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license.
	 * http://jquery.org/license
	 */
	
	//>>label: Slide Effect
	//>>group: Effects
	//>>description: Slides an element in and out of the viewport.
	//>>docs: http://api.jqueryui.com/slide-effect/
	//>>demos: http://jqueryui.com/effect/
	
	
	
	var effectsEffectSlide = $.effects.define( "slide", "show", function( options, done ) {
		var startClip, startRef,
			element = $( this ),
			map = {
				up: [ "bottom", "top" ],
				down: [ "top", "bottom" ],
				left: [ "right", "left" ],
				right: [ "left", "right" ]
			},
			mode = options.mode,
			direction = options.direction || "left",
			ref = ( direction === "up" || direction === "down" ) ? "top" : "left",
			positiveMotion = ( direction === "up" || direction === "left" ),
			distance = options.distance ||
				element[ ref === "top" ? "outerHeight" : "outerWidth" ]( true ),
			animation = {};
	
		$.effects.createPlaceholder( element );
	
		startClip = element.cssClip();
		startRef = element.position()[ ref ];
	
		// Define hide animation
		animation[ ref ] = ( positiveMotion ? -1 : 1 ) * distance + startRef;
		animation.clip = element.cssClip();
		animation.clip[ map[ direction ][ 1 ] ] = animation.clip[ map[ direction ][ 0 ] ];
	
		// Reverse the animation if we're showing
		if ( mode === "show" ) {
			element.cssClip( animation.clip );
			element.css( ref, animation[ ref ] );
			animation.clip = startClip;
			animation[ ref ] = startRef;
		}
	
		// Actually animate
		element.animate( animation, {
			queue: false,
			duration: options.duration,
			easing: options.easing,
			complete: done
		} );
	} );
	
	
	/*!
	 * jQuery UI Effects Transfer 1.12.0
	 * http://jqueryui.com
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license.
	 * http://jquery.org/license
	 */
	
	//>>label: Transfer Effect
	//>>group: Effects
	//>>description: Displays a transfer effect from one element to another.
	//>>docs: http://api.jqueryui.com/transfer-effect/
	//>>demos: http://jqueryui.com/effect/
	
	
	
	var effect;
	if ( $.uiBackCompat !== false ) {
		effect = $.effects.define( "transfer", function( options, done ) {
			$( this ).transfer( options, done );
		} );
	}
	var effectsEffectTransfer = effect;
	
	
	
	
	}));

/***/ }),
/* 7 */
/***/ (function(module, exports) {

	module.exports = jQuery;

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(9);
	
	$('.chosen-select').chosen({
	    search_contains: true,
	    disable_search_threshold: 10,
	    no_results_text: "Ничего не найдено"
	});
	
	
	// remove placeholder-option if its mobile
	var selectAll = $('select');
	selectAll.each(function () {
	    var t = $(this),
	        firstOption = t.find('option').eq(0);
	
	    if ( t.is(':visible') ) {
	
	        if ( firstOption.text() == '' ) {
	            firstOption.remove();
	        }
	
	    }
	
	});
	
	
	$('.chosen-select-type-2').chosen({
	    disable_search_threshold: 10,
	    no_results_text: "Ничего не найдено",
	    width: '100%'
	});
	
	
	
	
	
	//function addSelectGradient () {
	//
	//    $('.wrapper-content').find('.chosen-container').each( function() {
	//
	//        var t = $(this),
	//            selfWidth = t.outerWidth(),
	//            span = t.find('span'),
	//            spanwidth = span.outerWidth();
	//
	//        if ( spanwidth >= selfWidth ) {
	//            t.addClass('cutoff');
	//        } else {
	//            t.removeClass('cutoff');
	//        }
	//
	//    });
	//
	//}
	//
	//addSelectGradient();
	
	// require('../../vendor/mCustomScrollbar.js');
	// $('.chosen-results').mCustomScrollbar();
	// $('.chosen-select').on('chosen:showing_dropdown', function() {
	//     console.log('fsd');
	//     setTimeout(function () {
	//         $('.chosen-results').mCustomScrollbar('update');
	//         console.log('aaa');
	//     }, 500)
	// });

/***/ }),
/* 9 */
/***/ (function(module, exports) {

	/* Chosen v1.5.1 | (c) 2011-2016 by Harvest | MIT License, https://github.com/harvesthq/chosen/blob/master/LICENSE.md */
	(function() {
	    var a, AbstractChosen, Chosen, SelectParser, b, c = {}.hasOwnProperty,
	        d = function(a, b) {
	            function d() {
	                this.constructor = a
	            }
	            for (var e in b) c.call(b, e) && (a[e] = b[e]);
	            return d.prototype = b.prototype, a.prototype = new d, a.__super__ = b.prototype, a
	        };
	    SelectParser = function() {
	        function SelectParser() {
	            this.options_index = 0, this.parsed = []
	        }
	        return SelectParser.prototype.add_node = function(a) {
	            return "OPTGROUP" === a.nodeName.toUpperCase() ? this.add_group(a) : this.add_option(a)
	        }, SelectParser.prototype.add_group = function(a) {
	            var b, c, d, e, f, g;
	            for (b = this.parsed.length, this.parsed.push({
	                    array_index: b,
	                    group: !0,
	                    label: this.escapeExpression(a.label),
	                    title: a.title ? a.title : void 0,
	                    children: 0,
	                    disabled: a.disabled,
	                    classes: a.className
	                }), f = a.childNodes, g = [], d = 0, e = f.length; e > d; d++) c = f[d], g.push(this.add_option(c, b, a.disabled));
	            return g
	        }, SelectParser.prototype.add_option = function(a, b, c) {
	            return "OPTION" === a.nodeName.toUpperCase() ? ("" !== a.text ? (null != b && (this.parsed[b].children += 1), this.parsed.push({
	                array_index: this.parsed.length,
	                options_index: this.options_index,
	                value: a.value,
	                text: a.text,
	                html: a.innerHTML,
	                title: a.title ? a.title : void 0,
	                selected: a.selected,
	                disabled: c === !0 ? c : a.disabled,
	                group_array_index: b,
	                group_label: null != b ? this.parsed[b].label : null,
	                classes: a.className,
	                style: a.style.cssText
	            })) : this.parsed.push({
	                array_index: this.parsed.length,
	                options_index: this.options_index,
	                empty: !0
	            }), this.options_index += 1) : void 0
	        }, SelectParser.prototype.escapeExpression = function(a) {
	            var b, c;
	            return null == a || a === !1 ? "" : /[\&\<\>\"\'\`]/.test(a) ? (b = {
	                "<": "&lt;",
	                ">": "&gt;",
	                '"': "&quot;",
	                "'": "&#x27;",
	                "`": "&#x60;"
	            }, c = /&(?!\w+;)|[\<\>\"\'\`]/g, a.replace(c, function(a) {
	                return b[a] || "&amp;"
	            })) : a
	        }, SelectParser
	    }(), SelectParser.select_to_array = function(a) {
	        var b, c, d, e, f;
	        for (c = new SelectParser, f = a.childNodes, d = 0, e = f.length; e > d; d++) b = f[d], c.add_node(b);
	        return c.parsed
	    }, AbstractChosen = function() {
	        function AbstractChosen(a, b) {
	            this.form_field = a, this.options = null != b ? b : {}, AbstractChosen.browser_is_supported() && (this.is_multiple = this.form_field.multiple, this.set_default_text(), this.set_default_values(), this.setup(), this.set_up_html(), this.register_observers(), this.on_ready())
	        }
	        return AbstractChosen.prototype.set_default_values = function() {
	            var a = this;
	            return this.click_test_action = function(b) {
	                return a.test_active_click(b)
	            }, this.activate_action = function(b) {
	                return a.activate_field(b)
	            }, this.active_field = !1, this.mouse_on_container = !1, this.results_showing = !1, this.result_highlighted = null, this.allow_single_deselect = null != this.options.allow_single_deselect && null != this.form_field.options[0] && "" === this.form_field.options[0].text ? this.options.allow_single_deselect : !1, this.disable_search_threshold = this.options.disable_search_threshold || 0, this.disable_search = this.options.disable_search || !1, this.enable_split_word_search = null != this.options.enable_split_word_search ? this.options.enable_split_word_search : !0, this.group_search = null != this.options.group_search ? this.options.group_search : !0, this.search_contains = this.options.search_contains || !1, this.single_backstroke_delete = null != this.options.single_backstroke_delete ? this.options.single_backstroke_delete : !0, this.max_selected_options = this.options.max_selected_options || 1 / 0, this.inherit_select_classes = this.options.inherit_select_classes || !1, this.display_selected_options = null != this.options.display_selected_options ? this.options.display_selected_options : !0, this.display_disabled_options = null != this.options.display_disabled_options ? this.options.display_disabled_options : !0, this.include_group_label_in_selected = this.options.include_group_label_in_selected || !1, this.max_shown_results = this.options.max_shown_results || Number.POSITIVE_INFINITY
	        }, AbstractChosen.prototype.set_default_text = function() {
	            return this.form_field.getAttribute("data-placeholder") ? this.default_text = this.form_field.getAttribute("data-placeholder") : this.is_multiple ? this.default_text = this.options.placeholder_text_multiple || this.options.placeholder_text || AbstractChosen.default_multiple_text : this.default_text = this.options.placeholder_text_single || this.options.placeholder_text || AbstractChosen.default_single_text, this.results_none_found = this.form_field.getAttribute("data-no_results_text") || this.options.no_results_text || AbstractChosen.default_no_result_text
	        }, AbstractChosen.prototype.choice_label = function(a) {
	            return this.include_group_label_in_selected && null != a.group_label ? "<b class='group-name'>" + a.group_label + "</b>" + a.html : a.html
	        }, AbstractChosen.prototype.mouse_enter = function() {
	            return this.mouse_on_container = !0
	        }, AbstractChosen.prototype.mouse_leave = function() {
	            return this.mouse_on_container = !1
	        }, AbstractChosen.prototype.input_focus = function(a) {
	            var b = this;
	            if (this.is_multiple) {
	                if (!this.active_field) return setTimeout(function() {
	                    return b.container_mousedown()
	                }, 50)
	            } else if (!this.active_field) return this.activate_field()
	        }, AbstractChosen.prototype.input_blur = function(a) {
	            var b = this;
	            return this.mouse_on_container ? void 0 : (this.active_field = !1, setTimeout(function() {
	                return b.blur_test()
	            }, 100))
	        }, AbstractChosen.prototype.results_option_build = function(a) {
	            var b, c, d, e, f, g, h;
	            for (b = "", e = 0, h = this.results_data, f = 0, g = h.length; g > f && (c = h[f], d = "", d = c.group ? this.result_add_group(c) : this.result_add_option(c), "" !== d && (e++, b += d), (null != a ? a.first : void 0) && (c.selected && this.is_multiple ? this.choice_build(c) : c.selected && !this.is_multiple && this.single_set_selected_text(this.choice_label(c))), !(e >= this.max_shown_results)); f++);
	            return b
	        }, AbstractChosen.prototype.result_add_option = function(a) {
	            var b, c;
	            return a.search_match && this.include_option_in_results(a) ? (b = [], a.disabled || a.selected && this.is_multiple || b.push("active-result"), !a.disabled || a.selected && this.is_multiple || b.push("disabled-result"), a.selected && b.push("result-selected"), null != a.group_array_index && b.push("group-option"), "" !== a.classes && b.push(a.classes), c = document.createElement("li"), c.className = b.join(" "), c.style.cssText = a.style, c.setAttribute("data-option-array-index", a.array_index), c.innerHTML = a.search_text, a.title && (c.title = a.title), this.outerHTML(c)) : ""
	        }, AbstractChosen.prototype.result_add_group = function(a) {
	            var b, c;
	            return (a.search_match || a.group_match) && a.active_options > 0 ? (b = [], b.push("group-result"), a.classes && b.push(a.classes), c = document.createElement("li"), c.className = b.join(" "), c.innerHTML = a.search_text, a.title && (c.title = a.title), this.outerHTML(c)) : ""
	        }, AbstractChosen.prototype.results_update_field = function() {
	            return this.set_default_text(), this.is_multiple || this.results_reset_cleanup(), this.result_clear_highlight(), this.results_build(), this.results_showing ? this.winnow_results() : void 0
	        }, AbstractChosen.prototype.reset_single_select_options = function() {
	            var a, b, c, d, e;
	            for (d = this.results_data, e = [], b = 0, c = d.length; c > b; b++) a = d[b], a.selected ? e.push(a.selected = !1) : e.push(void 0);
	            return e
	        }, AbstractChosen.prototype.results_toggle = function() {
	            return this.results_showing ? this.results_hide() : this.results_show()
	        }, AbstractChosen.prototype.results_search = function(a) {
	            return this.results_showing ? this.winnow_results() : this.results_show()
	        }, AbstractChosen.prototype.winnow_results = function() {
	            var a, b, c, d, e, f, g, h, i, j, k, l;
	            for (this.no_results_clear(), d = 0, f = this.get_search_text(), a = f.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&"), i = new RegExp(a, "i"), c = this.get_search_regex(a), l = this.results_data, j = 0, k = l.length; k > j; j++) b = l[j], b.search_match = !1, e = null, this.include_option_in_results(b) && (b.group && (b.group_match = !1, b.active_options = 0), null != b.group_array_index && this.results_data[b.group_array_index] && (e = this.results_data[b.group_array_index], 0 === e.active_options && e.search_match && (d += 1), e.active_options += 1), b.search_text = b.group ? b.label : b.html, (!b.group || this.group_search) && (b.search_match = this.search_string_match(b.search_text, c), b.search_match && !b.group && (d += 1), b.search_match ? (f.length && (g = b.search_text.search(i), h = b.search_text.substr(0, g + f.length) + "</em>" + b.search_text.substr(g + f.length), b.search_text = h.substr(0, g) + "<em>" + h.substr(g)), null != e && (e.group_match = !0)) : null != b.group_array_index && this.results_data[b.group_array_index].search_match && (b.search_match = !0)));
	            return this.result_clear_highlight(), 1 > d && f.length ? (this.update_results_content(""), this.no_results(f)) : (this.update_results_content(this.results_option_build()), this.winnow_results_set_highlight())
	        }, AbstractChosen.prototype.get_search_regex = function(a) {
	            var b;
	            return b = this.search_contains ? "" : "^", new RegExp(b + a, "i")
	        }, AbstractChosen.prototype.search_string_match = function(a, b) {
	            var c, d, e, f;
	            if (b.test(a)) return !0;
	            if (this.enable_split_word_search && (a.indexOf(" ") >= 0 || 0 === a.indexOf("[")) && (d = a.replace(/\[|\]/g, "").split(" "), d.length))
	                for (e = 0, f = d.length; f > e; e++)
	                    if (c = d[e], b.test(c)) return !0
	        }, AbstractChosen.prototype.choices_count = function() {
	            var a, b, c, d;
	            if (null != this.selected_option_count) return this.selected_option_count;
	            for (this.selected_option_count = 0, d = this.form_field.options, b = 0, c = d.length; c > b; b++) a = d[b], a.selected && (this.selected_option_count += 1);
	            return this.selected_option_count
	        }, AbstractChosen.prototype.choices_click = function(a) {
	            return a.preventDefault(), this.results_showing || this.is_disabled ? void 0 : this.results_show()
	        }, AbstractChosen.prototype.keyup_checker = function(a) {
	            var b, c;
	            switch (b = null != (c = a.which) ? c : a.keyCode, this.search_field_scale(), b) {
	                case 8:
	                    if (this.is_multiple && this.backstroke_length < 1 && this.choices_count() > 0) return this.keydown_backstroke();
	                    if (!this.pending_backstroke) return this.result_clear_highlight(), this.results_search();
	                    break;
	                case 13:
	                    if (a.preventDefault(), this.results_showing) return this.result_select(a);
	                    break;
	                case 27:
	                    return this.results_showing && this.results_hide(), !0;
	                case 9:
	                case 38:
	                case 40:
	                case 16:
	                case 91:
	                case 17:
	                case 18:
	                    break;
	                default:
	                    return this.results_search()
	            }
	        }, AbstractChosen.prototype.clipboard_event_checker = function(a) {
	            var b = this;
	            return setTimeout(function() {
	                return b.results_search()
	            }, 50)
	        }, AbstractChosen.prototype.container_width = function() {
	            return null != this.options.width ? this.options.width : "" + this.form_field.offsetWidth + "px"
	        }, AbstractChosen.prototype.include_option_in_results = function(a) {
	            return this.is_multiple && !this.display_selected_options && a.selected ? !1 : !this.display_disabled_options && a.disabled ? !1 : a.empty ? !1 : !0
	        }, AbstractChosen.prototype.search_results_touchstart = function(a) {
	            return this.touch_started = !0, this.search_results_mouseover(a)
	        }, AbstractChosen.prototype.search_results_touchmove = function(a) {
	            return this.touch_started = !1, this.search_results_mouseout(a)
	        }, AbstractChosen.prototype.search_results_touchend = function(a) {
	            return this.touch_started ? this.search_results_mouseup(a) : void 0
	        }, AbstractChosen.prototype.outerHTML = function(a) {
	            var b;
	            return a.outerHTML ? a.outerHTML : (b = document.createElement("div"), b.appendChild(a), b.innerHTML)
	        }, AbstractChosen.browser_is_supported = function() {
	            return /iP(od|hone)/i.test(window.navigator.userAgent) ? !1 : /Android/i.test(window.navigator.userAgent) && /Mobile/i.test(window.navigator.userAgent) ? !1 : /IEMobile/i.test(window.navigator.userAgent) ? !1 : /Windows Phone/i.test(window.navigator.userAgent) ? !1 : /BlackBerry/i.test(window.navigator.userAgent) ? !1 : /BB10/i.test(window.navigator.userAgent) ? !1 : "Microsoft Internet Explorer" === window.navigator.appName ? document.documentMode >= 8 : !0
	        }, AbstractChosen.default_multiple_text = "Select Some Options", AbstractChosen.default_single_text = "Select an Option", AbstractChosen.default_no_result_text = "No results match", AbstractChosen
	    }(), a = jQuery, a.fn.extend({
	        chosen: function(b) {
	            return AbstractChosen.browser_is_supported() ? this.each(function(c) {
	                var d, e;
	                return d = a(this), e = d.data("chosen"), "destroy" === b ? void(e instanceof Chosen && e.destroy()) : void(e instanceof Chosen || d.data("chosen", new Chosen(this, b)))
	            }) : this
	        }
	    }), Chosen = function(c) {
	        function Chosen() {
	            return b = Chosen.__super__.constructor.apply(this, arguments)
	        }
	        return d(Chosen, c), Chosen.prototype.setup = function() {
	            return this.form_field_jq = a(this.form_field), this.current_selectedIndex = this.form_field.selectedIndex, this.is_rtl = this.form_field_jq.hasClass("chosen-rtl")
	        }, Chosen.prototype.set_up_html = function() {
	            var b, c;
	            return b = ["chosen-container"], b.push("chosen-container-" + (this.is_multiple ? "multi" : "single")), this.inherit_select_classes && this.form_field.className && b.push(this.form_field.className), this.is_rtl && b.push("chosen-rtl"), c = {
	                "class": b.join(" "),
	                style: "width: " + this.container_width() + ";",
	                title: this.form_field.title
	            }, this.form_field.id.length && (c.id = this.form_field.id.replace(/[^\w]/g, "_") + "_chosen"), this.container = a("<div />", c), this.is_multiple ? this.container.html('<ul class="chosen-choices"><li class="search-field"><input type="text" value="' + this.default_text + '" class="default" autocomplete="off" style="width:25px;" /></li></ul><div class="chosen-drop"><ul class="chosen-results"></ul></div>') : this.container.html('<a class="chosen-single chosen-default"><span>' + this.default_text + '</span><div><b></b></div></a><div class="chosen-drop"><div class="chosen-search"><input type="text" autocomplete="off" /></div><ul class="chosen-results"></ul></div>'), this.form_field_jq.hide().after(this.container), this.dropdown = this.container.find("div.chosen-drop").first(), this.search_field = this.container.find("input").first(), this.search_results = this.container.find("ul.chosen-results").first(), this.search_field_scale(), this.search_no_results = this.container.find("li.no-results").first(), this.is_multiple ? (this.search_choices = this.container.find("ul.chosen-choices").first(), this.search_container = this.container.find("li.search-field").first()) : (this.search_container = this.container.find("div.chosen-search").first(), this.selected_item = this.container.find(".chosen-single").first()), this.results_build(), this.set_tab_index(), this.set_label_behavior()
	        }, Chosen.prototype.on_ready = function() {
	            return this.form_field_jq.trigger("chosen:ready", {
	                chosen: this
	            })
	        }, Chosen.prototype.register_observers = function() {
	            var a = this;
	            return this.container.bind("touchstart.chosen", function(b) {
	                return a.container_mousedown(b), b.preventDefault()
	            }), this.container.bind("touchend.chosen", function(b) {
	                return a.container_mouseup(b), b.preventDefault()
	            }), this.container.bind("mousedown.chosen", function(b) {
	                a.container_mousedown(b)
	            }), this.container.bind("mouseup.chosen", function(b) {
	                a.container_mouseup(b)
	            }), this.container.bind("mouseenter.chosen", function(b) {
	                a.mouse_enter(b)
	            }), this.container.bind("mouseleave.chosen", function(b) {
	                a.mouse_leave(b)
	            }), this.search_results.bind("mouseup.chosen", function(b) {
	                a.search_results_mouseup(b)
	            }), this.search_results.bind("mouseover.chosen", function(b) {
	                a.search_results_mouseover(b)
	            }), this.search_results.bind("mouseout.chosen", function(b) {
	                a.search_results_mouseout(b)
	            }), this.search_results.bind("mousewheel.chosen DOMMouseScroll.chosen", function(b) {
	                a.search_results_mousewheel(b)
	            }), this.search_results.bind("touchstart.chosen", function(b) {
	                a.search_results_touchstart(b)
	            }), this.search_results.bind("touchmove.chosen", function(b) {
	                a.search_results_touchmove(b)
	            }), this.search_results.bind("touchend.chosen", function(b) {
	                a.search_results_touchend(b)
	            }), this.form_field_jq.bind("chosen:updated.chosen", function(b) {
	                a.results_update_field(b)
	            }), this.form_field_jq.bind("chosen:activate.chosen", function(b) {
	                a.activate_field(b)
	            }), this.form_field_jq.bind("chosen:open.chosen", function(b) {
	                a.container_mousedown(b)
	            }), this.form_field_jq.bind("chosen:close.chosen", function(b) {
	                a.input_blur(b)
	            }), this.search_field.bind("blur.chosen", function(b) {
	                a.input_blur(b)
	            }), this.search_field.bind("keyup.chosen", function(b) {
	                a.keyup_checker(b)
	            }), this.search_field.bind("keydown.chosen", function(b) {
	                a.keydown_checker(b)
	            }), this.search_field.bind("focus.chosen", function(b) {
	                a.input_focus(b)
	            }), this.search_field.bind("cut.chosen", function(b) {
	                a.clipboard_event_checker(b)
	            }), this.search_field.bind("paste.chosen", function(b) {
	                a.clipboard_event_checker(b)
	            }), this.is_multiple ? this.search_choices.bind("click.chosen", function(b) {
	                a.choices_click(b)
	            }) : this.container.bind("click.chosen", function(a) {
	                a.preventDefault()
	            })
	        }, Chosen.prototype.destroy = function() {
	            return a(this.container[0].ownerDocument).unbind("click.chosen", this.click_test_action), this.search_field[0].tabIndex && (this.form_field_jq[0].tabIndex = this.search_field[0].tabIndex), this.container.remove(), this.form_field_jq.removeData("chosen"), this.form_field_jq.show()
	        }, Chosen.prototype.search_field_disabled = function() {
	            return this.is_disabled = this.form_field_jq[0].disabled, this.is_disabled ? (this.container.addClass("chosen-disabled"), this.search_field[0].disabled = !0, this.is_multiple || this.selected_item.unbind("focus.chosen", this.activate_action), this.close_field()) : (this.container.removeClass("chosen-disabled"), this.search_field[0].disabled = !1, this.is_multiple ? void 0 : this.selected_item.bind("focus.chosen", this.activate_action))
	        }, Chosen.prototype.container_mousedown = function(b) {
	            return this.is_disabled || (b && "mousedown" === b.type && !this.results_showing && b.preventDefault(), null != b && a(b.target).hasClass("search-choice-close")) ? void 0 : (this.active_field ? this.is_multiple || !b || a(b.target)[0] !== this.selected_item[0] && !a(b.target).parents("a.chosen-single").length || (b.preventDefault(), this.results_toggle()) : (this.is_multiple && this.search_field.val(""), a(this.container[0].ownerDocument).bind("click.chosen", this.click_test_action), this.results_show()), this.activate_field())
	        }, Chosen.prototype.container_mouseup = function(a) {
	            return "ABBR" !== a.target.nodeName || this.is_disabled ? void 0 : this.results_reset(a)
	        }, Chosen.prototype.search_results_mousewheel = function(a) {
	            var b;
	            return a.originalEvent && (b = a.originalEvent.deltaY || -a.originalEvent.wheelDelta || a.originalEvent.detail), null != b ? (a.preventDefault(), "DOMMouseScroll" === a.type && (b = 40 * b), this.search_results.scrollTop(b + this.search_results.scrollTop())) : void 0
	        }, Chosen.prototype.blur_test = function(a) {
	            return !this.active_field && this.container.hasClass("chosen-container-active") ? this.close_field() : void 0
	        }, Chosen.prototype.close_field = function() {
	            return a(this.container[0].ownerDocument).unbind("click.chosen", this.click_test_action), this.active_field = !1, this.results_hide(), this.container.removeClass("chosen-container-active"), this.clear_backstroke(), this.show_search_field_default(), this.search_field_scale()
	        }, Chosen.prototype.activate_field = function() {
	            return this.container.addClass("chosen-container-active"), this.active_field = !0, this.search_field.val(this.search_field.val()), this.search_field.focus()
	        }, Chosen.prototype.test_active_click = function(b) {
	            var c;
	            return c = a(b.target).closest(".chosen-container"), c.length && this.container[0] === c[0] ? this.active_field = !0 : this.close_field()
	        }, Chosen.prototype.results_build = function() {
	            return this.parsing = !0, this.selected_option_count = null, this.results_data = SelectParser.select_to_array(this.form_field), this.is_multiple ? this.search_choices.find("li.search-choice").remove() : this.is_multiple || (this.single_set_selected_text(), this.disable_search || this.form_field.options.length <= this.disable_search_threshold ? (this.search_field[0].readOnly = !0, this.container.addClass("chosen-container-single-nosearch")) : (this.search_field[0].readOnly = !1, this.container.removeClass("chosen-container-single-nosearch"))), this.update_results_content(this.results_option_build({
	                first: !0
	            })), this.search_field_disabled(), this.show_search_field_default(), this.search_field_scale(), this.parsing = !1
	        }, Chosen.prototype.result_do_highlight = function(a) {
	            var b, c, d, e, f;
	            if (a.length) {
	                if (this.result_clear_highlight(), this.result_highlight = a, this.result_highlight.addClass("highlighted"), d = parseInt(this.search_results.css("maxHeight"), 10), f = this.search_results.scrollTop(), e = d + f, c = this.result_highlight.position().top, b = c + this.result_highlight.outerHeight(), b >= e) return this.search_results.scrollTop(b - d > 0 ? b - d : 0);
	                if (f > c) return this.search_results.scrollTop(c)
	            }
	        }, Chosen.prototype.result_clear_highlight = function() {
	            return this.result_highlight && this.result_highlight.removeClass("highlighted"), this.result_highlight = null
	        }, Chosen.prototype.results_show = function() {
	            return this.is_multiple && this.max_selected_options <= this.choices_count() ? (this.form_field_jq.trigger("chosen:maxselected", {
	                chosen: this
	            }), !1) : (this.container.addClass("chosen-with-drop"), this.results_showing = !0, this.search_field.focus(), this.search_field.val(this.search_field.val()), this.winnow_results(), this.form_field_jq.trigger("chosen:showing_dropdown", {
	                chosen: this
	            }))
	        }, Chosen.prototype.update_results_content = function(a) {
	            return this.search_results.html(a)
	        }, Chosen.prototype.results_hide = function() {
	            return this.results_showing && (this.result_clear_highlight(), this.container.removeClass("chosen-with-drop"), this.form_field_jq.trigger("chosen:hiding_dropdown", {
	                chosen: this
	            })), this.results_showing = !1
	        }, Chosen.prototype.set_tab_index = function(a) {
	            var b;
	            return this.form_field.tabIndex ? (b = this.form_field.tabIndex, this.form_field.tabIndex = -1, this.search_field[0].tabIndex = b) : void 0
	        }, Chosen.prototype.set_label_behavior = function() {
	            var b = this;
	            return this.form_field_label = this.form_field_jq.parents("label"), !this.form_field_label.length && this.form_field.id.length && (this.form_field_label = a("label[for='" + this.form_field.id + "']")), this.form_field_label.length > 0 ? this.form_field_label.bind("click.chosen", function(a) {
	                return b.is_multiple ? b.container_mousedown(a) : b.activate_field()
	            }) : void 0
	        }, Chosen.prototype.show_search_field_default = function() {
	            return this.is_multiple && this.choices_count() < 1 && !this.active_field ? (this.search_field.val(this.default_text), this.search_field.addClass("default")) : (this.search_field.val(""), this.search_field.removeClass("default"))
	        }, Chosen.prototype.search_results_mouseup = function(b) {
	            var c;
	            return c = a(b.target).hasClass("active-result") ? a(b.target) : a(b.target).parents(".active-result").first(), c.length ? (this.result_highlight = c, this.result_select(b), this.search_field.focus()) : void 0
	        }, Chosen.prototype.search_results_mouseover = function(b) {
	            var c;
	            return c = a(b.target).hasClass("active-result") ? a(b.target) : a(b.target).parents(".active-result").first(), c ? this.result_do_highlight(c) : void 0
	        }, Chosen.prototype.search_results_mouseout = function(b) {
	            return a(b.target).hasClass("active-result") ? this.result_clear_highlight() : void 0
	        }, Chosen.prototype.choice_build = function(b) {
	            var c, d, e = this;
	            return c = a("<li />", {
	                "class": "search-choice"
	            }).html("<span>" + this.choice_label(b) + "</span>"), b.disabled ? c.addClass("search-choice-disabled") : (d = a("<a />", {
	                "class": "search-choice-close",
	                "data-option-array-index": b.array_index
	            }), d.bind("click.chosen", function(a) {
	                return e.choice_destroy_link_click(a)
	            }), c.append(d)), this.search_container.before(c)
	        }, Chosen.prototype.choice_destroy_link_click = function(b) {
	            return b.preventDefault(), b.stopPropagation(), this.is_disabled ? void 0 : this.choice_destroy(a(b.target))
	        }, Chosen.prototype.choice_destroy = function(a) {
	            return this.result_deselect(a[0].getAttribute("data-option-array-index")) ? (this.show_search_field_default(), this.is_multiple && this.choices_count() > 0 && this.search_field.val().length < 1 && this.results_hide(), a.parents("li").first().remove(), this.search_field_scale()) : void 0
	        }, Chosen.prototype.results_reset = function() {
	            return this.reset_single_select_options(), this.form_field.options[0].selected = !0, this.single_set_selected_text(), this.show_search_field_default(), this.results_reset_cleanup(), this.form_field_jq.trigger("change"), this.active_field ? this.results_hide() : void 0
	        }, Chosen.prototype.results_reset_cleanup = function() {
	            return this.current_selectedIndex = this.form_field.selectedIndex, this.selected_item.find("abbr").remove()
	        }, Chosen.prototype.result_select = function(a) {
	            var b, c;
	            return this.result_highlight ? (b = this.result_highlight, this.result_clear_highlight(), this.is_multiple && this.max_selected_options <= this.choices_count() ? (this.form_field_jq.trigger("chosen:maxselected", {
	                chosen: this
	            }), !1) : (this.is_multiple ? b.removeClass("active-result") : this.reset_single_select_options(), b.addClass("result-selected"), c = this.results_data[b[0].getAttribute("data-option-array-index")], c.selected = !0, this.form_field.options[c.options_index].selected = !0, this.selected_option_count = null, this.is_multiple ? this.choice_build(c) : this.single_set_selected_text(this.choice_label(c)), (a.metaKey || a.ctrlKey) && this.is_multiple || this.results_hide(), this.show_search_field_default(), (this.is_multiple || this.form_field.selectedIndex !== this.current_selectedIndex) && this.form_field_jq.trigger("change", {
	                selected: this.form_field.options[c.options_index].value
	            }), this.current_selectedIndex = this.form_field.selectedIndex, a.preventDefault(), this.search_field_scale())) : void 0
	        }, Chosen.prototype.single_set_selected_text = function(a) {
	            return null == a && (a = this.default_text), a === this.default_text ? this.selected_item.addClass("chosen-default") : (this.single_deselect_control_build(), this.selected_item.removeClass("chosen-default")), this.selected_item.find("span").html(a)
	        }, Chosen.prototype.result_deselect = function(a) {
	            var b;
	            return b = this.results_data[a], this.form_field.options[b.options_index].disabled ? !1 : (b.selected = !1, this.form_field.options[b.options_index].selected = !1, this.selected_option_count = null, this.result_clear_highlight(), this.results_showing && this.winnow_results(), this.form_field_jq.trigger("change", {
	                deselected: this.form_field.options[b.options_index].value
	            }), this.search_field_scale(), !0)
	        }, Chosen.prototype.single_deselect_control_build = function() {
	            return this.allow_single_deselect ? (this.selected_item.find("abbr").length || this.selected_item.find("span").first().after('<abbr class="search-choice-close"></abbr>'), this.selected_item.addClass("chosen-single-with-deselect")) : void 0
	        }, Chosen.prototype.get_search_text = function() {
	            return a("<div/>").text(a.trim(this.search_field.val())).html()
	        }, Chosen.prototype.winnow_results_set_highlight = function() {
	            var a, b;
	            return b = this.is_multiple ? [] : this.search_results.find(".result-selected.active-result"), a = b.length ? b.first() : this.search_results.find(".active-result").first(), null != a ? this.result_do_highlight(a) : void 0
	        }, Chosen.prototype.no_results = function(b) {
	            var c;
	            return c = a('<li class="no-results">' + this.results_none_found + ' "<span></span>"</li>'), c.find("span").first().html(b), this.search_results.append(c), this.form_field_jq.trigger("chosen:no_results", {
	                chosen: this
	            })
	        }, Chosen.prototype.no_results_clear = function() {
	            return this.search_results.find(".no-results").remove()
	        }, Chosen.prototype.keydown_arrow = function() {
	            var a;
	            return this.results_showing && this.result_highlight ? (a = this.result_highlight.nextAll("li.active-result").first()) ? this.result_do_highlight(a) : void 0 : this.results_show()
	        }, Chosen.prototype.keyup_arrow = function() {
	            var a;
	            return this.results_showing || this.is_multiple ? this.result_highlight ? (a = this.result_highlight.prevAll("li.active-result"), a.length ? this.result_do_highlight(a.first()) : (this.choices_count() > 0 && this.results_hide(), this.result_clear_highlight())) : void 0 : this.results_show()
	        }, Chosen.prototype.keydown_backstroke = function() {
	            var a;
	            return this.pending_backstroke ? (this.choice_destroy(this.pending_backstroke.find("a").first()), this.clear_backstroke()) : (a = this.search_container.siblings("li.search-choice").last(), a.length && !a.hasClass("search-choice-disabled") ? (this.pending_backstroke = a, this.single_backstroke_delete ? this.keydown_backstroke() : this.pending_backstroke.addClass("search-choice-focus")) : void 0)
	        }, Chosen.prototype.clear_backstroke = function() {
	            return this.pending_backstroke && this.pending_backstroke.removeClass("search-choice-focus"), this.pending_backstroke = null
	        }, Chosen.prototype.keydown_checker = function(a) {
	            var b, c;
	            switch (b = null != (c = a.which) ? c : a.keyCode, this.search_field_scale(), 8 !== b && this.pending_backstroke && this.clear_backstroke(), b) {
	                case 8:
	                    this.backstroke_length = this.search_field.val().length;
	                    break;
	                case 9:
	                    this.results_showing && !this.is_multiple && this.result_select(a), this.mouse_on_container = !1;
	                    break;
	                case 13:
	                    this.results_showing && a.preventDefault();
	                    break;
	                case 32:
	                    this.disable_search && a.preventDefault();
	                    break;
	                case 38:
	                    a.preventDefault(), this.keyup_arrow();
	                    break;
	                case 40:
	                    a.preventDefault(), this.keydown_arrow()
	            }
	        }, Chosen.prototype.search_field_scale = function() {
	            var b, c, d, e, f, g, h, i, j;
	            if (this.is_multiple) {
	                for (d = 0, h = 0, f = "position:absolute; left: -1000px; top: -1000px; display:none;", g = ["font-size", "font-style", "font-weight", "font-family", "line-height", "text-transform", "letter-spacing"], i = 0, j = g.length; j > i; i++) e = g[i], f += e + ":" + this.search_field.css(e) + ";";
	                return b = a("<div />", {
	                    style: f
	                }), b.text(this.search_field.val()), a("body").append(b), h = b.width() + 25, b.remove(), c = this.container.outerWidth(), h > c - 10 && (h = c - 10), this.search_field.css({
	                    width: h + "px"
	                })
	            }
	        }, Chosen
	    }(AbstractChosen)
	}).call(this);
	
	/*****************
	 ** WEBPACK FOOTER
	 ** ./js/vendor/chosen.jquery.min.js
	 ** module id = 6
	 ** module chunks = 0
	 **/

/***/ }),
/* 10 */
/***/ (function(module, exports) {

	// Chosen Order v1.2.1
	// This plugin allows you to handle the order of the selection for Chosen multiple <select> dropdowns
	// Full source at https://github.com/tristanjahier/chosen-order
	// Copyright (c) 2013 - Tristan Jahier, http://tristan-jahier.fr
	
	// DISCLAIMER
	// Chosen Order is not associated with Harvest in any way.
	// Chosen is an original software by Patrick Filler for Harvest, http://getharvest.com
	// Full source at https://github.com/harvesthq/chosen
	// Copyright (c) 2011 Harvest http://getharvest.com
	
	// This file is generated by `grunt build`, do not edit it by hand.
	(function() {
	  var $, AbstractChosenOrder, _ref,
	    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
	    __hasProp = {}.hasOwnProperty,
	    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
	
	  AbstractChosenOrder = (function() {
	    var ERRORS;
	
	    function AbstractChosenOrder() {}
	
	    ERRORS = {
	      invalid_select_element: "ChosenOrder::{{function}}: first argument must be a valid HTML Multiple Select element that has been Chosenified!",
	      invalid_selection_array: "ChosenOrder::{{function}}: second argument must be an Array!",
	      unreachable_chosen_container: "ChosenOrder::{{function}}: could not find the Chosen UI container! To solve the problem, try adding an \"id\" attribute to your <select> element.",
	      ordering_unselected_option: "ChosenOrder::{{function}}: ignoring option '{{option}}' which is not selected. Set optional parameter \"force\" to 'true' to get the ordered selection forced first."
	    };
	
	    AbstractChosenOrder.insertAt = function(node, index, parentNode) {
	      return parentNode.insertBefore(node, parentNode.children[index].nextSibling);
	    };
	
	    AbstractChosenOrder.getFlattenedOptionsAndGroups = function(select) {
	      var flattened_options, opt, options, sub_opt, sub_options, _i, _j, _len, _len1;
	      options = Array.prototype.filter.call(select.childNodes, function(o) {
	        var _ref;
	        return (_ref = o.nodeName.toUpperCase()) === 'OPTION' || _ref === 'OPTGROUP';
	      });
	      flattened_options = [];
	      for (_i = 0, _len = options.length; _i < _len; _i++) {
	        opt = options[_i];
	        flattened_options.push(opt);
	        if (opt.nodeName.toUpperCase() === 'OPTGROUP') {
	          sub_options = Array.prototype.filter.call(opt.childNodes, function(o) {
	            return o.nodeName.toUpperCase() === 'OPTION';
	          });
	          for (_j = 0, _len1 = sub_options.length; _j < _len1; _j++) {
	            sub_opt = sub_options[_j];
	            flattened_options.push(sub_opt);
	          }
	        }
	      }
	      return flattened_options;
	    };
	
	    AbstractChosenOrder.isValidMultipleSelectElement = function(element) {
	      return element !== null && typeof element !== "undefined" && element.nodeName === "SELECT" && element.multiple;
	    };
	
	    AbstractChosenOrder.getChosenUIContainer = function(select) {
	      if (select.id !== "") {
	        return document.getElementById(select.id.replace(/-/g, "_") + "_chosen");
	      } else {
	        return this.searchChosenUIContainer(select);
	      }
	    };
	
	    AbstractChosenOrder.isChosenified = function(select) {
	      return this.getChosenUIContainer(select) != null;
	    };
	
	    AbstractChosenOrder.forceSelection = function(select, selection) {
	      var i, opt, options, _ref;
	      options = this.getFlattenedOptionsAndGroups(select);
	      i = 0;
	      while (i < options.length) {
	        opt = options[i];
	        if (_ref = opt.getAttribute("value"), __indexOf.call(selection, _ref) >= 0) {
	          opt.selected = true;
	          opt.setAttribute("selected", "");
	        } else {
	          opt.selected = false;
	          opt.removeAttribute("selected");
	        }
	        i++;
	      }
	      return this.triggerEvent(select, "chosen:updated");
	    };
	
	    AbstractChosenOrder.getSelectionOrder = function(select) {
	      var chosen_options, chosen_ui, close_btn, opt, option, options, order, rel, _i, _len;
	      if (this.getDOMElement != null) {
	        select = this.getDOMElement(select);
	      }
	      order = [];
	      if (!this.isValidMultipleSelectElement(select)) {
	        console.error(ERRORS.invalid_select_element.replace('{{function}}', 'getSelectionOrder'));
	        return order;
	      }
	      chosen_ui = this.getChosenUIContainer(select);
	      if (chosen_ui == null) {
	        console.error(ERRORS.unreachable_chosen_container.replace('{{function}}', 'getSelectionOrder'));
	        return order;
	      }
	      chosen_options = chosen_ui.querySelectorAll('.search-choice');
	      options = this.getFlattenedOptionsAndGroups(select);
	      for (_i = 0, _len = chosen_options.length; _i < _len; _i++) {
	        opt = chosen_options[_i];
	        close_btn = opt.querySelectorAll('.search-choice-close')[0];
	        if (close_btn != null) {
	          rel = close_btn.getAttribute(this.relAttributeName);
	        }
	        option = options[rel];
	        order.push(option.value);
	      }
	      return order;
	    };
	
	    AbstractChosenOrder.setSelectionOrder = function(select, order, force) {
	      var chosen_choices, chosen_options, chosen_ui, i, j, opt, opt_val, option, options, rel, relAttributeName, _i, _j, _len, _len1, _results;
	      if (this.getDOMElement != null) {
	        select = this.getDOMElement(select);
	      }
	      if (!this.isValidMultipleSelectElement(select)) {
	        console.error(ERRORS.invalid_select_element.replace('{{function}}', 'setSelectionOrder'));
	        return;
	      }
	      chosen_ui = this.getChosenUIContainer(select);
	      if (chosen_ui == null) {
	        console.error(ERRORS.unreachable_chosen_container.replace('{{function}}', 'setSelectionOrder'));
	        return;
	      }
	      if (order instanceof Array) {
	        order = order.map(Function.prototype.call, String.prototype.trim);
	        options = this.getFlattenedOptionsAndGroups(select);
	        if ((force != null) && force === true) {
	          this.forceSelection(select, order);
	        }
	        _results = [];
	        for (i = _i = 0, _len = order.length; _i < _len; i = ++_i) {
	          opt_val = order[i];
	          rel = null;
	          for (j = _j = 0, _len1 = options.length; _j < _len1; j = ++_j) {
	            opt = options[j];
	            if (opt.value === opt_val) {
	              rel = j;
	            }
	          }
	          chosen_options = chosen_ui.querySelectorAll('.search-choice');
	          relAttributeName = this.relAttributeName;
	          option = Array.prototype.filter.call(chosen_options, function(o) {
	            return o.querySelector("a.search-choice-close[" + relAttributeName + "=\"" + rel + "\"]") != null;
	          })[0];
	          if (option == null) {
	            console.warn(ERRORS.ordering_unselected_option.replace('{{function}}', 'setSelectionOrder').replace('{{option}}', opt_val));
	            continue;
	          }
	          chosen_choices = chosen_ui.querySelector("ul.chosen-choices");
	          _results.push(this.insertAt(option, i, chosen_ui.querySelector('ul.chosen-choices')));
	        }
	        return _results;
	      } else {
	        return console.error(ERRORS.invalid_selection_array.replace('{{function}}', 'setSelectionOrder'));
	      }
	    };
	
	    return AbstractChosenOrder;
	
	  })();
	
	  $ = jQuery;
	
	  $.fn.extend({
	    getSelectionOrder: function() {
	      return ChosenOrder.getSelectionOrder(this);
	    },
	    setSelectionOrder: function(order, force) {
	      console.log(this)
	      return ChosenOrder.setSelectionOrder(this, order, force);
	    }
	  });
	
	
	
	  this.ChosenOrder = (function(_super) {
	    __extends(ChosenOrder, _super);
	
	    function ChosenOrder() {
	      _ref = ChosenOrder.__super__.constructor.apply(this, arguments);
	      return _ref;
	    }
	
	    ChosenOrder.relAttributeName = 'data-option-array-index';
	
	    ChosenOrder.isjQueryObject = function(obj) {
	      return (typeof jQuery !== "undefined" && jQuery !== null) && obj instanceof jQuery;
	    };
	
	    ChosenOrder.getDOMElement = function(element) {
	      if (this.isjQueryObject(element)) {
	        return element.get(0);
	      } else {
	        return element;
	      }
	    };
	
	    ChosenOrder.searchChosenUIContainer = function(element) {
	      if ($(element).data("chosen") != null) {
	        return $(element).data("chosen").container[0];
	      } else {
	        return $(element).next(".chosen-container.chosen-container-multi").get(0);
	      }
	    };
	
	    ChosenOrder.triggerEvent = function(target, event_name) {
	      return $(target).trigger(event_name);
	    };
	
	    return ChosenOrder;
	
	  })(AbstractChosenOrder);
	
	}).call(this);


/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(12);
	__webpack_require__(13);
	
	$('.custom-scroll').mCustomScrollbar({
		scrollInertia: 300
	 });

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * jQuery Mousewheel 3.1.13
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license
	 * http://jquery.org/license
	 */
	
	(function (factory) {
	    if ( true ) {
	        // AMD. Register as an anonymous module.
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(7)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    } else if (typeof exports === 'object') {
	        // Node/CommonJS style for Browserify
	        module.exports = factory;
	    } else {
	        // Browser globals
	        factory(jQuery);
	    }
	}(function ($) {
	
	    var toFix  = ['wheel', 'mousewheel', 'DOMMouseScroll', 'MozMousePixelScroll'],
	        toBind = ( 'onwheel' in document || document.documentMode >= 9 ) ?
	                    ['wheel'] : ['mousewheel', 'DomMouseScroll', 'MozMousePixelScroll'],
	        slice  = Array.prototype.slice,
	        nullLowestDeltaTimeout, lowestDelta;
	
	    if ( $.event.fixHooks ) {
	        for ( var i = toFix.length; i; ) {
	            $.event.fixHooks[ toFix[--i] ] = $.event.mouseHooks;
	        }
	    }
	
	    var special = $.event.special.mousewheel = {
	        version: '3.1.12',
	
	        setup: function() {
	            if ( this.addEventListener ) {
	                for ( var i = toBind.length; i; ) {
	                    this.addEventListener( toBind[--i], handler, false );
	                }
	            } else {
	                this.onmousewheel = handler;
	            }
	            // Store the line height and page height for this particular element
	            $.data(this, 'mousewheel-line-height', special.getLineHeight(this));
	            $.data(this, 'mousewheel-page-height', special.getPageHeight(this));
	        },
	
	        teardown: function() {
	            if ( this.removeEventListener ) {
	                for ( var i = toBind.length; i; ) {
	                    this.removeEventListener( toBind[--i], handler, false );
	                }
	            } else {
	                this.onmousewheel = null;
	            }
	            // Clean up the data we added to the element
	            $.removeData(this, 'mousewheel-line-height');
	            $.removeData(this, 'mousewheel-page-height');
	        },
	
	        getLineHeight: function(elem) {
	            var $elem = $(elem),
	                $parent = $elem['offsetParent' in $.fn ? 'offsetParent' : 'parent']();
	            if (!$parent.length) {
	                $parent = $('body');
	            }
	            return parseInt($parent.css('fontSize'), 10) || parseInt($elem.css('fontSize'), 10) || 16;
	        },
	
	        getPageHeight: function(elem) {
	            return $(elem).height();
	        },
	
	        settings: {
	            adjustOldDeltas: true, // see shouldAdjustOldDeltas() below
	            normalizeOffset: true  // calls getBoundingClientRect for each event
	        }
	    };
	
	    $.fn.extend({
	        mousewheel: function(fn) {
	            return fn ? this.bind('mousewheel', fn) : this.trigger('mousewheel');
	        },
	
	        unmousewheel: function(fn) {
	            return this.unbind('mousewheel', fn);
	        }
	    });
	
	
	    function handler(event) {
	        var orgEvent   = event || window.event,
	            args       = slice.call(arguments, 1),
	            delta      = 0,
	            deltaX     = 0,
	            deltaY     = 0,
	            absDelta   = 0,
	            offsetX    = 0,
	            offsetY    = 0;
	        event = $.event.fix(orgEvent);
	        event.type = 'mousewheel';
	
	        // Old school scrollwheel delta
	        if ( 'detail'      in orgEvent ) { deltaY = orgEvent.detail * -1;      }
	        if ( 'wheelDelta'  in orgEvent ) { deltaY = orgEvent.wheelDelta;       }
	        if ( 'wheelDeltaY' in orgEvent ) { deltaY = orgEvent.wheelDeltaY;      }
	        if ( 'wheelDeltaX' in orgEvent ) { deltaX = orgEvent.wheelDeltaX * -1; }
	
	        // Firefox < 17 horizontal scrolling related to DOMMouseScroll event
	        if ( 'axis' in orgEvent && orgEvent.axis === orgEvent.HORIZONTAL_AXIS ) {
	            deltaX = deltaY * -1;
	            deltaY = 0;
	        }
	
	        // Set delta to be deltaY or deltaX if deltaY is 0 for backwards compatabilitiy
	        delta = deltaY === 0 ? deltaX : deltaY;
	
	        // New school wheel delta (wheel event)
	        if ( 'deltaY' in orgEvent ) {
	            deltaY = orgEvent.deltaY * -1;
	            delta  = deltaY;
	        }
	        if ( 'deltaX' in orgEvent ) {
	            deltaX = orgEvent.deltaX;
	            if ( deltaY === 0 ) { delta  = deltaX * -1; }
	        }
	
	        // No change actually happened, no reason to go any further
	        if ( deltaY === 0 && deltaX === 0 ) { return; }
	
	        // Need to convert lines and pages to pixels if we aren't already in pixels
	        // There are three delta modes:
	        //   * deltaMode 0 is by pixels, nothing to do
	        //   * deltaMode 1 is by lines
	        //   * deltaMode 2 is by pages
	        if ( orgEvent.deltaMode === 1 ) {
	            var lineHeight = $.data(this, 'mousewheel-line-height');
	            delta  *= lineHeight;
	            deltaY *= lineHeight;
	            deltaX *= lineHeight;
	        } else if ( orgEvent.deltaMode === 2 ) {
	            var pageHeight = $.data(this, 'mousewheel-page-height');
	            delta  *= pageHeight;
	            deltaY *= pageHeight;
	            deltaX *= pageHeight;
	        }
	
	        // Store lowest absolute delta to normalize the delta values
	        absDelta = Math.max( Math.abs(deltaY), Math.abs(deltaX) );
	
	        if ( !lowestDelta || absDelta < lowestDelta ) {
	            lowestDelta = absDelta;
	
	            // Adjust older deltas if necessary
	            if ( shouldAdjustOldDeltas(orgEvent, absDelta) ) {
	                lowestDelta /= 40;
	            }
	        }
	
	        // Adjust older deltas if necessary
	        if ( shouldAdjustOldDeltas(orgEvent, absDelta) ) {
	            // Divide all the things by 40!
	            delta  /= 40;
	            deltaX /= 40;
	            deltaY /= 40;
	        }
	
	        // Get a whole, normalized value for the deltas
	        delta  = Math[ delta  >= 1 ? 'floor' : 'ceil' ](delta  / lowestDelta);
	        deltaX = Math[ deltaX >= 1 ? 'floor' : 'ceil' ](deltaX / lowestDelta);
	        deltaY = Math[ deltaY >= 1 ? 'floor' : 'ceil' ](deltaY / lowestDelta);
	
	        // Normalise offsetX and offsetY properties
	        if ( special.settings.normalizeOffset && this.getBoundingClientRect ) {
	            var boundingRect = this.getBoundingClientRect();
	            offsetX = event.clientX - boundingRect.left;
	            offsetY = event.clientY - boundingRect.top;
	        }
	
	        // Add information to the event object
	        event.deltaX = deltaX;
	        event.deltaY = deltaY;
	        event.deltaFactor = lowestDelta;
	        event.offsetX = offsetX;
	        event.offsetY = offsetY;
	        // Go ahead and set deltaMode to 0 since we converted to pixels
	        // Although this is a little odd since we overwrite the deltaX/Y
	        // properties with normalized deltas.
	        event.deltaMode = 0;
	
	        // Add event and delta to the front of the arguments
	        args.unshift(event, delta, deltaX, deltaY);
	
	        // Clearout lowestDelta after sometime to better
	        // handle multiple device types that give different
	        // a different lowestDelta
	        // Ex: trackpad = 3 and mouse wheel = 120
	        if (nullLowestDeltaTimeout) { clearTimeout(nullLowestDeltaTimeout); }
	        nullLowestDeltaTimeout = setTimeout(nullLowestDelta, 200);
	
	        return ($.event.dispatch || $.event.handle).apply(this, args);
	    }
	
	    function nullLowestDelta() {
	        lowestDelta = null;
	    }
	
	    function shouldAdjustOldDeltas(orgEvent, absDelta) {
	        // If this is an older event and the delta is divisable by 120,
	        // then we are assuming that the browser is treating this as an
	        // older mouse wheel event and that we should divide the deltas
	        // by 40 to try and get a more usable deltaFactor.
	        // Side note, this actually impacts the reported scroll distance
	        // in older browsers and can cause scrolling to be slower than native.
	        // Turn this off by setting $.event.special.mousewheel.settings.adjustOldDeltas to false.
	        return special.settings.adjustOldDeltas && orgEvent.type === 'mousewheel' && absDelta % 120 === 0;
	    }
	
	}));


/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	== malihu jquery custom scrollbar plugin == 
	Version: 3.1.5 
	Plugin URI: http://manos.malihu.gr/jquery-custom-content-scroller 
	Author: malihu
	Author URI: http://manos.malihu.gr
	License: MIT License (MIT)
	*/
	
	/*
	Copyright Manos Malihutsakis (email: manos@malihu.gr)
	
	Permission is hereby granted, free of charge, to any person obtaining a copy
	of this software and associated documentation files (the "Software"), to deal
	in the Software without restriction, including without limitation the rights
	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	copies of the Software, and to permit persons to whom the Software is
	furnished to do so, subject to the following conditions:
	
	The above copyright notice and this permission notice shall be included in
	all copies or substantial portions of the Software.
	
	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	THE SOFTWARE.
	*/
	
	/*
	The code below is fairly long, fully commented and should be normally used in development. 
	For production, use either the minified jquery.mCustomScrollbar.min.js script or 
	the production-ready jquery.mCustomScrollbar.concat.min.js which contains the plugin 
	and dependencies (minified). 
	*/
	
	(function(factory){
		if(true){
			!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(7)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		}else if(typeof module!=="undefined" && module.exports){
			module.exports=factory;
		}else{
			factory(jQuery,window,document);
		}
	}(function($){
	(function(init){
		var _rjs="function"==="function" && __webpack_require__(14), /* RequireJS */
			_njs=typeof module !== "undefined" && module.exports, /* NodeJS */
			_dlp=("https:"==document.location.protocol) ? "https:" : "http:", /* location protocol */
			_url="cdnjs.cloudflare.com/ajax/libs/jquery-mousewheel/3.1.13/jquery.mousewheel.min.js";
		if(!_rjs){
			if(_njs){
				__webpack_require__(15)($);
			}else{
				/* load jquery-mousewheel plugin (via CDN) if it's not present or not loaded via RequireJS 
				(works when mCustomScrollbar fn is called on window load) */
				$.event.special.mousewheel || $("head").append(decodeURI("%3Cscript src="+_dlp+"//"+_url+"%3E%3C/script%3E"));
			}
		}
		init();
	}(function(){
		
		/* 
		----------------------------------------
		PLUGIN NAMESPACE, PREFIX, DEFAULT SELECTOR(S) 
		----------------------------------------
		*/
		
		var pluginNS="mCustomScrollbar",
			pluginPfx="mCS",
			defaultSelector=".mCustomScrollbar",
		
		
			
		
		
		/* 
		----------------------------------------
		DEFAULT OPTIONS 
		----------------------------------------
		*/
		
			defaults={
				/*
				set element/content width/height programmatically 
				values: boolean, pixels, percentage 
					option						default
					-------------------------------------
					setWidth					false
					setHeight					false
				*/
				/*
				set the initial css top property of content  
				values: string (e.g. "-100px", "10%" etc.)
				*/
				setTop:0,
				/*
				set the initial css left property of content  
				values: string (e.g. "-100px", "10%" etc.)
				*/
				setLeft:0,
				/* 
				scrollbar axis (vertical and/or horizontal scrollbars) 
				values (string): "y", "x", "yx"
				*/
				axis:"y",
				/*
				position of scrollbar relative to content  
				values (string): "inside", "outside" ("outside" requires elements with position:relative)
				*/
				scrollbarPosition:"inside",
				/*
				scrolling inertia
				values: integer (milliseconds)
				*/
				scrollInertia:950,
				/* 
				auto-adjust scrollbar dragger length
				values: boolean
				*/
				autoDraggerLength:true,
				/*
				auto-hide scrollbar when idle 
				values: boolean
					option						default
					-------------------------------------
					autoHideScrollbar			false
				*/
				/*
				auto-expands scrollbar on mouse-over and dragging
				values: boolean
					option						default
					-------------------------------------
					autoExpandScrollbar			false
				*/
				/*
				always show scrollbar, even when there's nothing to scroll 
				values: integer (0=disable, 1=always show dragger rail and buttons, 2=always show dragger rail, dragger and buttons), boolean
				*/
				alwaysShowScrollbar:0,
				/*
				scrolling always snaps to a multiple of this number in pixels
				values: integer, array ([y,x])
					option						default
					-------------------------------------
					snapAmount					null
				*/
				/*
				when snapping, snap with this number in pixels as an offset 
				values: integer
				*/
				snapOffset:0,
				/* 
				mouse-wheel scrolling
				*/
				mouseWheel:{
					/* 
					enable mouse-wheel scrolling
					values: boolean
					*/
					enable:true,
					/* 
					scrolling amount in pixels
					values: "auto", integer 
					*/
					scrollAmount:"auto",
					/* 
					mouse-wheel scrolling axis 
					the default scrolling direction when both vertical and horizontal scrollbars are present 
					values (string): "y", "x" 
					*/
					axis:"y",
					/* 
					prevent the default behaviour which automatically scrolls the parent element(s) when end of scrolling is reached 
					values: boolean
						option						default
						-------------------------------------
						preventDefault				null
					*/
					/*
					the reported mouse-wheel delta value. The number of lines (translated to pixels) one wheel notch scrolls.  
					values: "auto", integer 
					"auto" uses the default OS/browser value 
					*/
					deltaFactor:"auto",
					/*
					normalize mouse-wheel delta to -1 or 1 (disables mouse-wheel acceleration) 
					values: boolean
						option						default
						-------------------------------------
						normalizeDelta				null
					*/
					/*
					invert mouse-wheel scrolling direction 
					values: boolean
						option						default
						-------------------------------------
						invert						null
					*/
					/*
					the tags that disable mouse-wheel when cursor is over them
					*/
					disableOver:["select","option","keygen","datalist","textarea"]
				},
				/* 
				scrollbar buttons
				*/
				scrollButtons:{ 
					/*
					enable scrollbar buttons
					values: boolean
						option						default
						-------------------------------------
						enable						null
					*/
					/*
					scrollbar buttons scrolling type 
					values (string): "stepless", "stepped"
					*/
					scrollType:"stepless",
					/*
					scrolling amount in pixels
					values: "auto", integer 
					*/
					scrollAmount:"auto"
					/*
					tabindex of the scrollbar buttons
					values: false, integer
						option						default
						-------------------------------------
						tabindex					null
					*/
				},
				/* 
				keyboard scrolling
				*/
				keyboard:{ 
					/*
					enable scrolling via keyboard
					values: boolean
					*/
					enable:true,
					/*
					keyboard scrolling type 
					values (string): "stepless", "stepped"
					*/
					scrollType:"stepless",
					/*
					scrolling amount in pixels
					values: "auto", integer 
					*/
					scrollAmount:"auto"
				},
				/*
				enable content touch-swipe scrolling 
				values: boolean, integer, string (number)
				integer values define the axis-specific minimum amount required for scrolling momentum
				*/
				contentTouchScroll:25,
				/*
				enable/disable document (default) touch-swipe scrolling 
				*/
				documentTouchScroll:true,
				/*
				advanced option parameters
				*/
				advanced:{
					/*
					auto-expand content horizontally (for "x" or "yx" axis) 
					values: boolean, integer (the value 2 forces the non scrollHeight/scrollWidth method, the value 3 forces the scrollHeight/scrollWidth method)
						option						default
						-------------------------------------
						autoExpandHorizontalScroll	null
					*/
					/*
					auto-scroll to elements with focus
					*/
					autoScrollOnFocus:"input,textarea,select,button,datalist,keygen,a[tabindex],area,object,[contenteditable='true']",
					/*
					auto-update scrollbars on content, element or viewport resize 
					should be true for fluid layouts/elements, adding/removing content dynamically, hiding/showing elements, content with images etc. 
					values: boolean
					*/
					updateOnContentResize:true,
					/*
					auto-update scrollbars each time each image inside the element is fully loaded 
					values: "auto", boolean
					*/
					updateOnImageLoad:"auto",
					/*
					auto-update scrollbars based on the amount and size changes of specific selectors 
					useful when you need to update the scrollbar(s) automatically, each time a type of element is added, removed or changes its size 
					values: boolean, string (e.g. "ul li" will auto-update scrollbars each time list-items inside the element are changed) 
					a value of true (boolean) will auto-update scrollbars each time any element is changed
						option						default
						-------------------------------------
						updateOnSelectorChange		null
					*/
					/*
					extra selectors that'll allow scrollbar dragging upon mousemove/up, pointermove/up, touchend etc. (e.g. "selector-1, selector-2")
						option						default
						-------------------------------------
						extraDraggableSelectors		null
					*/
					/*
					extra selectors that'll release scrollbar dragging upon mouseup, pointerup, touchend etc. (e.g. "selector-1, selector-2")
						option						default
						-------------------------------------
						releaseDraggableSelectors	null
					*/
					/*
					auto-update timeout 
					values: integer (milliseconds)
					*/
					autoUpdateTimeout:60
				},
				/* 
				scrollbar theme 
				values: string (see CSS/plugin URI for a list of ready-to-use themes)
				*/
				theme:"light",
				/*
				user defined callback functions
				*/
				callbacks:{
					/*
					Available callbacks: 
						callback					default
						-------------------------------------
						onCreate					null
						onInit						null
						onScrollStart				null
						onScroll					null
						onTotalScroll				null
						onTotalScrollBack			null
						whileScrolling				null
						onOverflowY					null
						onOverflowX					null
						onOverflowYNone				null
						onOverflowXNone				null
						onImageLoad					null
						onSelectorChange			null
						onBeforeUpdate				null
						onUpdate					null
					*/
					onTotalScrollOffset:0,
					onTotalScrollBackOffset:0,
					alwaysTriggerOffsets:true
				}
				/*
				add scrollbar(s) on all elements matching the current selector, now and in the future 
				values: boolean, string 
				string values: "on" (enable), "once" (disable after first invocation), "off" (disable)
				liveSelector values: string (selector)
					option						default
					-------------------------------------
					live						false
					liveSelector				null
				*/
			},
		
		
		
		
		
		/* 
		----------------------------------------
		VARS, CONSTANTS 
		----------------------------------------
		*/
		
			totalInstances=0, /* plugin instances amount */
			liveTimers={}, /* live option timers */
			oldIE=(window.attachEvent && !window.addEventListener) ? 1 : 0, /* detect IE < 9 */
			touchActive=false,touchable, /* global touch vars (for touch and pointer events) */
			/* general plugin classes */
			classes=[
				"mCSB_dragger_onDrag","mCSB_scrollTools_onDrag","mCS_img_loaded","mCS_disabled","mCS_destroyed","mCS_no_scrollbar",
				"mCS-autoHide","mCS-dir-rtl","mCS_no_scrollbar_y","mCS_no_scrollbar_x","mCS_y_hidden","mCS_x_hidden","mCSB_draggerContainer",
				"mCSB_buttonUp","mCSB_buttonDown","mCSB_buttonLeft","mCSB_buttonRight"
			],
			
		
		
		
		
		/* 
		----------------------------------------
		METHODS 
		----------------------------------------
		*/
		
			methods={
				
				/* 
				plugin initialization method 
				creates the scrollbar(s), plugin data object and options
				----------------------------------------
				*/
				
				init:function(options){
					
					var options=$.extend(true,{},defaults,options),
						selector=_selector.call(this); /* validate selector */
					
					/* 
					if live option is enabled, monitor for elements matching the current selector and 
					apply scrollbar(s) when found (now and in the future) 
					*/
					if(options.live){
						var liveSelector=options.liveSelector || this.selector || defaultSelector, /* live selector(s) */
							$liveSelector=$(liveSelector); /* live selector(s) as jquery object */
						if(options.live==="off"){
							/* 
							disable live if requested 
							usage: $(selector).mCustomScrollbar({live:"off"}); 
							*/
							removeLiveTimers(liveSelector);
							return;
						}
						liveTimers[liveSelector]=setTimeout(function(){
							/* call mCustomScrollbar fn on live selector(s) every half-second */
							$liveSelector.mCustomScrollbar(options);
							if(options.live==="once" && $liveSelector.length){
								/* disable live after first invocation */
								removeLiveTimers(liveSelector);
							}
						},500);
					}else{
						removeLiveTimers(liveSelector);
					}
					
					/* options backward compatibility (for versions < 3.0.0) and normalization */
					options.setWidth=(options.set_width) ? options.set_width : options.setWidth;
					options.setHeight=(options.set_height) ? options.set_height : options.setHeight;
					options.axis=(options.horizontalScroll) ? "x" : _findAxis(options.axis);
					options.scrollInertia=options.scrollInertia>0 && options.scrollInertia<17 ? 17 : options.scrollInertia;
					if(typeof options.mouseWheel!=="object" &&  options.mouseWheel==true){ /* old school mouseWheel option (non-object) */
						options.mouseWheel={enable:true,scrollAmount:"auto",axis:"y",preventDefault:false,deltaFactor:"auto",normalizeDelta:false,invert:false}
					}
					options.mouseWheel.scrollAmount=!options.mouseWheelPixels ? options.mouseWheel.scrollAmount : options.mouseWheelPixels;
					options.mouseWheel.normalizeDelta=!options.advanced.normalizeMouseWheelDelta ? options.mouseWheel.normalizeDelta : options.advanced.normalizeMouseWheelDelta;
					options.scrollButtons.scrollType=_findScrollButtonsType(options.scrollButtons.scrollType); 
					
					_theme(options); /* theme-specific options */
					
					/* plugin constructor */
					return $(selector).each(function(){
						
						var $this=$(this);
						
						if(!$this.data(pluginPfx)){ /* prevent multiple instantiations */
						
							/* store options and create objects in jquery data */
							$this.data(pluginPfx,{
								idx:++totalInstances, /* instance index */
								opt:options, /* options */
								scrollRatio:{y:null,x:null}, /* scrollbar to content ratio */
								overflowed:null, /* overflowed axis */
								contentReset:{y:null,x:null}, /* object to check when content resets */
								bindEvents:false, /* object to check if events are bound */
								tweenRunning:false, /* object to check if tween is running */
								sequential:{}, /* sequential scrolling object */
								langDir:$this.css("direction"), /* detect/store direction (ltr or rtl) */
								cbOffsets:null, /* object to check whether callback offsets always trigger */
								/* 
								object to check how scrolling events where last triggered 
								"internal" (default - triggered by this script), "external" (triggered by other scripts, e.g. via scrollTo method) 
								usage: object.data("mCS").trigger
								*/
								trigger:null,
								/* 
								object to check for changes in elements in order to call the update method automatically 
								*/
								poll:{size:{o:0,n:0},img:{o:0,n:0},change:{o:0,n:0}}
							});
							
							var d=$this.data(pluginPfx),o=d.opt,
								/* HTML data attributes */
								htmlDataAxis=$this.data("mcs-axis"),htmlDataSbPos=$this.data("mcs-scrollbar-position"),htmlDataTheme=$this.data("mcs-theme");
							 
							if(htmlDataAxis){o.axis=htmlDataAxis;} /* usage example: data-mcs-axis="y" */
							if(htmlDataSbPos){o.scrollbarPosition=htmlDataSbPos;} /* usage example: data-mcs-scrollbar-position="outside" */
							if(htmlDataTheme){ /* usage example: data-mcs-theme="minimal" */
								o.theme=htmlDataTheme;
								_theme(o); /* theme-specific options */
							}
							
							_pluginMarkup.call(this); /* add plugin markup */
							
							if(d && o.callbacks.onCreate && typeof o.callbacks.onCreate==="function"){o.callbacks.onCreate.call(this);} /* callbacks: onCreate */
							
							$("#mCSB_"+d.idx+"_container img:not(."+classes[2]+")").addClass(classes[2]); /* flag loaded images */
							
							methods.update.call(null,$this); /* call the update method */
						
						}
						
					});
					
				},
				/* ---------------------------------------- */
				
				
				
				/* 
				plugin update method 
				updates content and scrollbar(s) values, events and status 
				----------------------------------------
				usage: $(selector).mCustomScrollbar("update");
				*/
				
				update:function(el,cb){
					
					var selector=el || _selector.call(this); /* validate selector */
					
					return $(selector).each(function(){
						
						var $this=$(this);
						
						if($this.data(pluginPfx)){ /* check if plugin has initialized */
							
							var d=$this.data(pluginPfx),o=d.opt,
								mCSB_container=$("#mCSB_"+d.idx+"_container"),
								mCustomScrollBox=$("#mCSB_"+d.idx),
								mCSB_dragger=[$("#mCSB_"+d.idx+"_dragger_vertical"),$("#mCSB_"+d.idx+"_dragger_horizontal")];
							
							if(!mCSB_container.length){return;}
							
							if(d.tweenRunning){_stop($this);} /* stop any running tweens while updating */
							
							if(cb && d && o.callbacks.onBeforeUpdate && typeof o.callbacks.onBeforeUpdate==="function"){o.callbacks.onBeforeUpdate.call(this);} /* callbacks: onBeforeUpdate */
							
							/* if element was disabled or destroyed, remove class(es) */
							if($this.hasClass(classes[3])){$this.removeClass(classes[3]);}
							if($this.hasClass(classes[4])){$this.removeClass(classes[4]);}
							
							/* css flexbox fix, detect/set max-height */
							mCustomScrollBox.css("max-height","none");
							if(mCustomScrollBox.height()!==$this.height()){mCustomScrollBox.css("max-height",$this.height());}
							
							_expandContentHorizontally.call(this); /* expand content horizontally */
							
							if(o.axis!=="y" && !o.advanced.autoExpandHorizontalScroll){
								mCSB_container.css("width",_contentWidth(mCSB_container));
							}
							
							d.overflowed=_overflowed.call(this); /* determine if scrolling is required */
							
							_scrollbarVisibility.call(this); /* show/hide scrollbar(s) */
							
							/* auto-adjust scrollbar dragger length analogous to content */
							if(o.autoDraggerLength){_setDraggerLength.call(this);}
							
							_scrollRatio.call(this); /* calculate and store scrollbar to content ratio */
							
							_bindEvents.call(this); /* bind scrollbar events */
							
							/* reset scrolling position and/or events */
							var to=[Math.abs(mCSB_container[0].offsetTop),Math.abs(mCSB_container[0].offsetLeft)];
							if(o.axis!=="x"){ /* y/yx axis */
								if(!d.overflowed[0]){ /* y scrolling is not required */
									_resetContentPosition.call(this); /* reset content position */
									if(o.axis==="y"){
										_unbindEvents.call(this);
									}else if(o.axis==="yx" && d.overflowed[1]){
										_scrollTo($this,to[1].toString(),{dir:"x",dur:0,overwrite:"none"});
									}
								}else if(mCSB_dragger[0].height()>mCSB_dragger[0].parent().height()){
									_resetContentPosition.call(this); /* reset content position */
								}else{ /* y scrolling is required */
									_scrollTo($this,to[0].toString(),{dir:"y",dur:0,overwrite:"none"});
									d.contentReset.y=null;
								}
							}
							if(o.axis!=="y"){ /* x/yx axis */
								if(!d.overflowed[1]){ /* x scrolling is not required */
									_resetContentPosition.call(this); /* reset content position */
									if(o.axis==="x"){
										_unbindEvents.call(this);
									}else if(o.axis==="yx" && d.overflowed[0]){
										_scrollTo($this,to[0].toString(),{dir:"y",dur:0,overwrite:"none"});
									}
								}else if(mCSB_dragger[1].width()>mCSB_dragger[1].parent().width()){
									_resetContentPosition.call(this); /* reset content position */
								}else{ /* x scrolling is required */
									_scrollTo($this,to[1].toString(),{dir:"x",dur:0,overwrite:"none"});
									d.contentReset.x=null;
								}
							}
							
							/* callbacks: onImageLoad, onSelectorChange, onUpdate */
							if(cb && d){
								if(cb===2 && o.callbacks.onImageLoad && typeof o.callbacks.onImageLoad==="function"){
									o.callbacks.onImageLoad.call(this);
								}else if(cb===3 && o.callbacks.onSelectorChange && typeof o.callbacks.onSelectorChange==="function"){
									o.callbacks.onSelectorChange.call(this);
								}else if(o.callbacks.onUpdate && typeof o.callbacks.onUpdate==="function"){
									o.callbacks.onUpdate.call(this);
								}
							}
							
							_autoUpdate.call(this); /* initialize automatic updating (for dynamic content, fluid layouts etc.) */
							
						}
						
					});
					
				},
				/* ---------------------------------------- */
				
				
				
				/* 
				plugin scrollTo method 
				triggers a scrolling event to a specific value
				----------------------------------------
				usage: $(selector).mCustomScrollbar("scrollTo",value,options);
				*/
			
				scrollTo:function(val,options){
					
					/* prevent silly things like $(selector).mCustomScrollbar("scrollTo",undefined); */
					if(typeof val=="undefined" || val==null){return;}
					
					var selector=_selector.call(this); /* validate selector */
					
					return $(selector).each(function(){
						
						var $this=$(this);
						
						if($this.data(pluginPfx)){ /* check if plugin has initialized */
						
							var d=$this.data(pluginPfx),o=d.opt,
								/* method default options */
								methodDefaults={
									trigger:"external", /* method is by default triggered externally (e.g. from other scripts) */
									scrollInertia:o.scrollInertia, /* scrolling inertia (animation duration) */
									scrollEasing:"mcsEaseInOut", /* animation easing */
									moveDragger:false, /* move dragger instead of content */
									timeout:60, /* scroll-to delay */
									callbacks:true, /* enable/disable callbacks */
									onStart:true,
									onUpdate:true,
									onComplete:true
								},
								methodOptions=$.extend(true,{},methodDefaults,options),
								to=_arr.call(this,val),dur=methodOptions.scrollInertia>0 && methodOptions.scrollInertia<17 ? 17 : methodOptions.scrollInertia;
							
							/* translate yx values to actual scroll-to positions */
							to[0]=_to.call(this,to[0],"y");
							to[1]=_to.call(this,to[1],"x");
							
							/* 
							check if scroll-to value moves the dragger instead of content. 
							Only pixel values apply on dragger (e.g. 100, "100px", "-=100" etc.) 
							*/
							if(methodOptions.moveDragger){
								to[0]*=d.scrollRatio.y;
								to[1]*=d.scrollRatio.x;
							}
							
							methodOptions.dur=_isTabHidden() ? 0 : dur; //skip animations if browser tab is hidden
							
							setTimeout(function(){ 
								/* do the scrolling */
								if(to[0]!==null && typeof to[0]!=="undefined" && o.axis!=="x" && d.overflowed[0]){ /* scroll y */
									methodOptions.dir="y";
									methodOptions.overwrite="all";
									_scrollTo($this,to[0].toString(),methodOptions);
								}
								if(to[1]!==null && typeof to[1]!=="undefined" && o.axis!=="y" && d.overflowed[1]){ /* scroll x */
									methodOptions.dir="x";
									methodOptions.overwrite="none";
									_scrollTo($this,to[1].toString(),methodOptions);
								}
							},methodOptions.timeout);
							
						}
						
					});
					
				},
				/* ---------------------------------------- */
				
				
				
				/*
				plugin stop method 
				stops scrolling animation
				----------------------------------------
				usage: $(selector).mCustomScrollbar("stop");
				*/
				stop:function(){
					
					var selector=_selector.call(this); /* validate selector */
					
					return $(selector).each(function(){
						
						var $this=$(this);
						
						if($this.data(pluginPfx)){ /* check if plugin has initialized */
											
							_stop($this);
						
						}
						
					});
					
				},
				/* ---------------------------------------- */
				
				
				
				/*
				plugin disable method 
				temporarily disables the scrollbar(s) 
				----------------------------------------
				usage: $(selector).mCustomScrollbar("disable",reset); 
				reset (boolean): resets content position to 0 
				*/
				disable:function(r){
					
					var selector=_selector.call(this); /* validate selector */
					
					return $(selector).each(function(){
						
						var $this=$(this);
						
						if($this.data(pluginPfx)){ /* check if plugin has initialized */
							
							var d=$this.data(pluginPfx);
							
							_autoUpdate.call(this,"remove"); /* remove automatic updating */
							
							_unbindEvents.call(this); /* unbind events */
							
							if(r){_resetContentPosition.call(this);} /* reset content position */
							
							_scrollbarVisibility.call(this,true); /* show/hide scrollbar(s) */
							
							$this.addClass(classes[3]); /* add disable class */
						
						}
						
					});
					
				},
				/* ---------------------------------------- */
				
				
				
				/*
				plugin destroy method 
				completely removes the scrollbar(s) and returns the element to its original state
				----------------------------------------
				usage: $(selector).mCustomScrollbar("destroy"); 
				*/
				destroy:function(){
					
					var selector=_selector.call(this); /* validate selector */
					
					return $(selector).each(function(){
						
						var $this=$(this);
						
						if($this.data(pluginPfx)){ /* check if plugin has initialized */
						
							var d=$this.data(pluginPfx),o=d.opt,
								mCustomScrollBox=$("#mCSB_"+d.idx),
								mCSB_container=$("#mCSB_"+d.idx+"_container"),
								scrollbar=$(".mCSB_"+d.idx+"_scrollbar");
						
							if(o.live){removeLiveTimers(o.liveSelector || $(selector).selector);} /* remove live timers */
							
							_autoUpdate.call(this,"remove"); /* remove automatic updating */
							
							_unbindEvents.call(this); /* unbind events */
							
							_resetContentPosition.call(this); /* reset content position */
							
							$this.removeData(pluginPfx); /* remove plugin data object */
							
							_delete(this,"mcs"); /* delete callbacks object */
							
							/* remove plugin markup */
							scrollbar.remove(); /* remove scrollbar(s) first (those can be either inside or outside plugin's inner wrapper) */
							mCSB_container.find("img."+classes[2]).removeClass(classes[2]); /* remove loaded images flag */
							mCustomScrollBox.replaceWith(mCSB_container.contents()); /* replace plugin's inner wrapper with the original content */
							/* remove plugin classes from the element and add destroy class */
							$this.removeClass(pluginNS+" _"+pluginPfx+"_"+d.idx+" "+classes[6]+" "+classes[7]+" "+classes[5]+" "+classes[3]).addClass(classes[4]);
						
						}
						
					});
					
				}
				/* ---------------------------------------- */
				
			},
		
		
		
		
			
		/* 
		----------------------------------------
		FUNCTIONS
		----------------------------------------
		*/
		
			/* validates selector (if selector is invalid or undefined uses the default one) */
			_selector=function(){
				return (typeof $(this)!=="object" || $(this).length<1) ? defaultSelector : this;
			},
			/* -------------------- */
			
			
			/* changes options according to theme */
			_theme=function(obj){
				var fixedSizeScrollbarThemes=["rounded","rounded-dark","rounded-dots","rounded-dots-dark"],
					nonExpandedScrollbarThemes=["rounded-dots","rounded-dots-dark","3d","3d-dark","3d-thick","3d-thick-dark","inset","inset-dark","inset-2","inset-2-dark","inset-3","inset-3-dark"],
					disabledScrollButtonsThemes=["minimal","minimal-dark"],
					enabledAutoHideScrollbarThemes=["minimal","minimal-dark"],
					scrollbarPositionOutsideThemes=["minimal","minimal-dark"];
				obj.autoDraggerLength=$.inArray(obj.theme,fixedSizeScrollbarThemes) > -1 ? false : obj.autoDraggerLength;
				obj.autoExpandScrollbar=$.inArray(obj.theme,nonExpandedScrollbarThemes) > -1 ? false : obj.autoExpandScrollbar;
				obj.scrollButtons.enable=$.inArray(obj.theme,disabledScrollButtonsThemes) > -1 ? false : obj.scrollButtons.enable;
				obj.autoHideScrollbar=$.inArray(obj.theme,enabledAutoHideScrollbarThemes) > -1 ? true : obj.autoHideScrollbar;
				obj.scrollbarPosition=$.inArray(obj.theme,scrollbarPositionOutsideThemes) > -1 ? "outside" : obj.scrollbarPosition;
			},
			/* -------------------- */
			
			
			/* live option timers removal */
			removeLiveTimers=function(selector){
				if(liveTimers[selector]){
					clearTimeout(liveTimers[selector]);
					_delete(liveTimers,selector);
				}
			},
			/* -------------------- */
			
			
			/* normalizes axis option to valid values: "y", "x", "yx" */
			_findAxis=function(val){
				return (val==="yx" || val==="xy" || val==="auto") ? "yx" : (val==="x" || val==="horizontal") ? "x" : "y";
			},
			/* -------------------- */
			
			
			/* normalizes scrollButtons.scrollType option to valid values: "stepless", "stepped" */
			_findScrollButtonsType=function(val){
				return (val==="stepped" || val==="pixels" || val==="step" || val==="click") ? "stepped" : "stepless";
			},
			/* -------------------- */
			
			
			/* generates plugin markup */
			_pluginMarkup=function(){
				var $this=$(this),d=$this.data(pluginPfx),o=d.opt,
					expandClass=o.autoExpandScrollbar ? " "+classes[1]+"_expand" : "",
					scrollbar=["<div id='mCSB_"+d.idx+"_scrollbar_vertical' class='mCSB_scrollTools mCSB_"+d.idx+"_scrollbar mCS-"+o.theme+" mCSB_scrollTools_vertical"+expandClass+"'><div class='"+classes[12]+"'><div id='mCSB_"+d.idx+"_dragger_vertical' class='mCSB_dragger' style='position:absolute;'><div class='mCSB_dragger_bar' /></div><div class='mCSB_draggerRail' /></div></div>","<div id='mCSB_"+d.idx+"_scrollbar_horizontal' class='mCSB_scrollTools mCSB_"+d.idx+"_scrollbar mCS-"+o.theme+" mCSB_scrollTools_horizontal"+expandClass+"'><div class='"+classes[12]+"'><div id='mCSB_"+d.idx+"_dragger_horizontal' class='mCSB_dragger' style='position:absolute;'><div class='mCSB_dragger_bar' /></div><div class='mCSB_draggerRail' /></div></div>"],
					wrapperClass=o.axis==="yx" ? "mCSB_vertical_horizontal" : o.axis==="x" ? "mCSB_horizontal" : "mCSB_vertical",
					scrollbars=o.axis==="yx" ? scrollbar[0]+scrollbar[1] : o.axis==="x" ? scrollbar[1] : scrollbar[0],
					contentWrapper=o.axis==="yx" ? "<div id='mCSB_"+d.idx+"_container_wrapper' class='mCSB_container_wrapper' />" : "",
					autoHideClass=o.autoHideScrollbar ? " "+classes[6] : "",
					scrollbarDirClass=(o.axis!=="x" && d.langDir==="rtl") ? " "+classes[7] : "";
				if(o.setWidth){$this.css("width",o.setWidth);} /* set element width */
				if(o.setHeight){$this.css("height",o.setHeight);} /* set element height */
				o.setLeft=(o.axis!=="y" && d.langDir==="rtl") ? "989999px" : o.setLeft; /* adjust left position for rtl direction */
				$this.addClass(pluginNS+" _"+pluginPfx+"_"+d.idx+autoHideClass+scrollbarDirClass).wrapInner("<div id='mCSB_"+d.idx+"' class='mCustomScrollBox mCS-"+o.theme+" "+wrapperClass+"'><div id='mCSB_"+d.idx+"_container' class='mCSB_container' style='position:relative; top:"+o.setTop+"; left:"+o.setLeft+";' dir='"+d.langDir+"' /></div>");
				var mCustomScrollBox=$("#mCSB_"+d.idx),
					mCSB_container=$("#mCSB_"+d.idx+"_container");
				if(o.axis!=="y" && !o.advanced.autoExpandHorizontalScroll){
					mCSB_container.css("width",_contentWidth(mCSB_container));
				}
				if(o.scrollbarPosition==="outside"){
					if($this.css("position")==="static"){ /* requires elements with non-static position */
						$this.css("position","relative");
					}
					$this.css("overflow","visible");
					mCustomScrollBox.addClass("mCSB_outside").after(scrollbars);
				}else{
					mCustomScrollBox.addClass("mCSB_inside").append(scrollbars);
					mCSB_container.wrap(contentWrapper);
				}
				_scrollButtons.call(this); /* add scrollbar buttons */
				/* minimum dragger length */
				var mCSB_dragger=[$("#mCSB_"+d.idx+"_dragger_vertical"),$("#mCSB_"+d.idx+"_dragger_horizontal")];
				mCSB_dragger[0].css("min-height",mCSB_dragger[0].height());
				mCSB_dragger[1].css("min-width",mCSB_dragger[1].width());
			},
			/* -------------------- */
			
			
			/* calculates content width */
			_contentWidth=function(el){
				var val=[el[0].scrollWidth,Math.max.apply(Math,el.children().map(function(){return $(this).outerWidth(true);}).get())],w=el.parent().width();
				return val[0]>w ? val[0] : val[1]>w ? val[1] : "100%";
			},
			/* -------------------- */
			
			
			/* expands content horizontally */
			_expandContentHorizontally=function(){
				var $this=$(this),d=$this.data(pluginPfx),o=d.opt,
					mCSB_container=$("#mCSB_"+d.idx+"_container");
				if(o.advanced.autoExpandHorizontalScroll && o.axis!=="y"){
					/* calculate scrollWidth */
					mCSB_container.css({"width":"auto","min-width":0,"overflow-x":"scroll"});
					var w=Math.ceil(mCSB_container[0].scrollWidth);
					if(o.advanced.autoExpandHorizontalScroll===3 || (o.advanced.autoExpandHorizontalScroll!==2 && w>mCSB_container.parent().width())){
						mCSB_container.css({"width":w,"min-width":"100%","overflow-x":"inherit"});
					}else{
						/* 
						wrap content with an infinite width div and set its position to absolute and width to auto. 
						Setting width to auto before calculating the actual width is important! 
						We must let the browser set the width as browser zoom values are impossible to calculate.
						*/
						mCSB_container.css({"overflow-x":"inherit","position":"absolute"})
							.wrap("<div class='mCSB_h_wrapper' style='position:relative; left:0; width:999999px;' />")
							.css({ /* set actual width, original position and un-wrap */
								/* 
								get the exact width (with decimals) and then round-up. 
								Using jquery outerWidth() will round the width value which will mess up with inner elements that have non-integer width
								*/
								"width":(Math.ceil(mCSB_container[0].getBoundingClientRect().right+0.4)-Math.floor(mCSB_container[0].getBoundingClientRect().left)),
								"min-width":"100%",
								"position":"relative"
							}).unwrap();
					}
				}
			},
			/* -------------------- */
			
			
			/* adds scrollbar buttons */
			_scrollButtons=function(){
				var $this=$(this),d=$this.data(pluginPfx),o=d.opt,
					mCSB_scrollTools=$(".mCSB_"+d.idx+"_scrollbar:first"),
					tabindex=!_isNumeric(o.scrollButtons.tabindex) ? "" : "tabindex='"+o.scrollButtons.tabindex+"'",
					btnHTML=[
						"<a href='#' class='"+classes[13]+"' "+tabindex+" />",
						"<a href='#' class='"+classes[14]+"' "+tabindex+" />",
						"<a href='#' class='"+classes[15]+"' "+tabindex+" />",
						"<a href='#' class='"+classes[16]+"' "+tabindex+" />"
					],
					btn=[(o.axis==="x" ? btnHTML[2] : btnHTML[0]),(o.axis==="x" ? btnHTML[3] : btnHTML[1]),btnHTML[2],btnHTML[3]];
				if(o.scrollButtons.enable){
					mCSB_scrollTools.prepend(btn[0]).append(btn[1]).next(".mCSB_scrollTools").prepend(btn[2]).append(btn[3]);
				}
			},
			/* -------------------- */
			
			
			/* auto-adjusts scrollbar dragger length */
			_setDraggerLength=function(){
				var $this=$(this),d=$this.data(pluginPfx),
					mCustomScrollBox=$("#mCSB_"+d.idx),
					mCSB_container=$("#mCSB_"+d.idx+"_container"),
					mCSB_dragger=[$("#mCSB_"+d.idx+"_dragger_vertical"),$("#mCSB_"+d.idx+"_dragger_horizontal")],
					ratio=[mCustomScrollBox.height()/mCSB_container.outerHeight(false),mCustomScrollBox.width()/mCSB_container.outerWidth(false)],
					l=[
						parseInt(mCSB_dragger[0].css("min-height")),Math.round(ratio[0]*mCSB_dragger[0].parent().height()),
						parseInt(mCSB_dragger[1].css("min-width")),Math.round(ratio[1]*mCSB_dragger[1].parent().width())
					],
					h=oldIE && (l[1]<l[0]) ? l[0] : l[1],w=oldIE && (l[3]<l[2]) ? l[2] : l[3];
				mCSB_dragger[0].css({
					"height":h,"max-height":(mCSB_dragger[0].parent().height()-10)
				}).find(".mCSB_dragger_bar").css({"line-height":l[0]+"px"});
				mCSB_dragger[1].css({
					"width":w,"max-width":(mCSB_dragger[1].parent().width()-10)
				});
			},
			/* -------------------- */
			
			
			/* calculates scrollbar to content ratio */
			_scrollRatio=function(){
				var $this=$(this),d=$this.data(pluginPfx),
					mCustomScrollBox=$("#mCSB_"+d.idx),
					mCSB_container=$("#mCSB_"+d.idx+"_container"),
					mCSB_dragger=[$("#mCSB_"+d.idx+"_dragger_vertical"),$("#mCSB_"+d.idx+"_dragger_horizontal")],
					scrollAmount=[mCSB_container.outerHeight(false)-mCustomScrollBox.height(),mCSB_container.outerWidth(false)-mCustomScrollBox.width()],
					ratio=[
						scrollAmount[0]/(mCSB_dragger[0].parent().height()-mCSB_dragger[0].height()),
						scrollAmount[1]/(mCSB_dragger[1].parent().width()-mCSB_dragger[1].width())
					];
				d.scrollRatio={y:ratio[0],x:ratio[1]};
			},
			/* -------------------- */
			
			
			/* toggles scrolling classes */
			_onDragClasses=function(el,action,xpnd){
				var expandClass=xpnd ? classes[0]+"_expanded" : "",
					scrollbar=el.closest(".mCSB_scrollTools");
				if(action==="active"){
					el.toggleClass(classes[0]+" "+expandClass); scrollbar.toggleClass(classes[1]); 
					el[0]._draggable=el[0]._draggable ? 0 : 1;
				}else{
					if(!el[0]._draggable){
						if(action==="hide"){
							el.removeClass(classes[0]); scrollbar.removeClass(classes[1]);
						}else{
							el.addClass(classes[0]); scrollbar.addClass(classes[1]);
						}
					}
				}
			},
			/* -------------------- */
			
			
			/* checks if content overflows its container to determine if scrolling is required */
			_overflowed=function(){
				var $this=$(this),d=$this.data(pluginPfx),
					mCustomScrollBox=$("#mCSB_"+d.idx),
					mCSB_container=$("#mCSB_"+d.idx+"_container"),
					contentHeight=d.overflowed==null ? mCSB_container.height() : mCSB_container.outerHeight(false),
					contentWidth=d.overflowed==null ? mCSB_container.width() : mCSB_container.outerWidth(false),
					h=mCSB_container[0].scrollHeight,w=mCSB_container[0].scrollWidth;
				if(h>contentHeight){contentHeight=h;}
				if(w>contentWidth){contentWidth=w;}
				return [contentHeight>mCustomScrollBox.height(),contentWidth>mCustomScrollBox.width()];
			},
			/* -------------------- */
			
			
			/* resets content position to 0 */
			_resetContentPosition=function(){
				var $this=$(this),d=$this.data(pluginPfx),o=d.opt,
					mCustomScrollBox=$("#mCSB_"+d.idx),
					mCSB_container=$("#mCSB_"+d.idx+"_container"),
					mCSB_dragger=[$("#mCSB_"+d.idx+"_dragger_vertical"),$("#mCSB_"+d.idx+"_dragger_horizontal")];
				_stop($this); /* stop any current scrolling before resetting */
				if((o.axis!=="x" && !d.overflowed[0]) || (o.axis==="y" && d.overflowed[0])){ /* reset y */
					mCSB_dragger[0].add(mCSB_container).css("top",0);
					_scrollTo($this,"_resetY");
				}
				if((o.axis!=="y" && !d.overflowed[1]) || (o.axis==="x" && d.overflowed[1])){ /* reset x */
					var cx=dx=0;
					if(d.langDir==="rtl"){ /* adjust left position for rtl direction */
						cx=mCustomScrollBox.width()-mCSB_container.outerWidth(false);
						dx=Math.abs(cx/d.scrollRatio.x);
					}
					mCSB_container.css("left",cx);
					mCSB_dragger[1].css("left",dx);
					_scrollTo($this,"_resetX");
				}
			},
			/* -------------------- */
			
			
			/* binds scrollbar events */
			_bindEvents=function(){
				var $this=$(this),d=$this.data(pluginPfx),o=d.opt;
				if(!d.bindEvents){ /* check if events are already bound */
					_draggable.call(this);
					if(o.contentTouchScroll){_contentDraggable.call(this);}
					_selectable.call(this);
					if(o.mouseWheel.enable){ /* bind mousewheel fn when plugin is available */
						function _mwt(){
							mousewheelTimeout=setTimeout(function(){
								if(!$.event.special.mousewheel){
									_mwt();
								}else{
									clearTimeout(mousewheelTimeout);
									_mousewheel.call($this[0]);
								}
							},100);
						}
						var mousewheelTimeout;
						_mwt();
					}
					_draggerRail.call(this);
					_wrapperScroll.call(this);
					if(o.advanced.autoScrollOnFocus){_focus.call(this);}
					if(o.scrollButtons.enable){_buttons.call(this);}
					if(o.keyboard.enable){_keyboard.call(this);}
					d.bindEvents=true;
				}
			},
			/* -------------------- */
			
			
			/* unbinds scrollbar events */
			_unbindEvents=function(){
				var $this=$(this),d=$this.data(pluginPfx),o=d.opt,
					namespace=pluginPfx+"_"+d.idx,
					sb=".mCSB_"+d.idx+"_scrollbar",
					sel=$("#mCSB_"+d.idx+",#mCSB_"+d.idx+"_container,#mCSB_"+d.idx+"_container_wrapper,"+sb+" ."+classes[12]+",#mCSB_"+d.idx+"_dragger_vertical,#mCSB_"+d.idx+"_dragger_horizontal,"+sb+">a"),
					mCSB_container=$("#mCSB_"+d.idx+"_container");
				if(o.advanced.releaseDraggableSelectors){sel.add($(o.advanced.releaseDraggableSelectors));}
				if(o.advanced.extraDraggableSelectors){sel.add($(o.advanced.extraDraggableSelectors));}
				if(d.bindEvents){ /* check if events are bound */
					/* unbind namespaced events from document/selectors */
					$(document).add($(!_canAccessIFrame() || top.document)).unbind("."+namespace);
					sel.each(function(){
						$(this).unbind("."+namespace);
					});
					/* clear and delete timeouts/objects */
					clearTimeout($this[0]._focusTimeout); _delete($this[0],"_focusTimeout");
					clearTimeout(d.sequential.step); _delete(d.sequential,"step");
					clearTimeout(mCSB_container[0].onCompleteTimeout); _delete(mCSB_container[0],"onCompleteTimeout");
					d.bindEvents=false;
				}
			},
			/* -------------------- */
			
			
			/* toggles scrollbar visibility */
			_scrollbarVisibility=function(disabled){
				var $this=$(this),d=$this.data(pluginPfx),o=d.opt,
					contentWrapper=$("#mCSB_"+d.idx+"_container_wrapper"),
					content=contentWrapper.length ? contentWrapper : $("#mCSB_"+d.idx+"_container"),
					scrollbar=[$("#mCSB_"+d.idx+"_scrollbar_vertical"),$("#mCSB_"+d.idx+"_scrollbar_horizontal")],
					mCSB_dragger=[scrollbar[0].find(".mCSB_dragger"),scrollbar[1].find(".mCSB_dragger")];
				if(o.axis!=="x"){
					if(d.overflowed[0] && !disabled){
						scrollbar[0].add(mCSB_dragger[0]).add(scrollbar[0].children("a")).css("display","block");
						content.removeClass(classes[8]+" "+classes[10]);
					}else{
						if(o.alwaysShowScrollbar){
							if(o.alwaysShowScrollbar!==2){mCSB_dragger[0].css("display","none");}
							content.removeClass(classes[10]);
						}else{
							scrollbar[0].css("display","none");
							content.addClass(classes[10]);
						}
						content.addClass(classes[8]);
					}
				}
				if(o.axis!=="y"){
					if(d.overflowed[1] && !disabled){
						scrollbar[1].add(mCSB_dragger[1]).add(scrollbar[1].children("a")).css("display","block");
						content.removeClass(classes[9]+" "+classes[11]);
					}else{
						if(o.alwaysShowScrollbar){
							if(o.alwaysShowScrollbar!==2){mCSB_dragger[1].css("display","none");}
							content.removeClass(classes[11]);
						}else{
							scrollbar[1].css("display","none");
							content.addClass(classes[11]);
						}
						content.addClass(classes[9]);
					}
				}
				if(!d.overflowed[0] && !d.overflowed[1]){
					$this.addClass(classes[5]);
				}else{
					$this.removeClass(classes[5]);
				}
			},
			/* -------------------- */
			
			
			/* returns input coordinates of pointer, touch and mouse events (relative to document) */
			_coordinates=function(e){
				var t=e.type,o=e.target.ownerDocument!==document && frameElement!==null ? [$(frameElement).offset().top,$(frameElement).offset().left] : null,
					io=_canAccessIFrame() && e.target.ownerDocument!==top.document && frameElement!==null ? [$(e.view.frameElement).offset().top,$(e.view.frameElement).offset().left] : [0,0];
				switch(t){
					case "pointerdown": case "MSPointerDown": case "pointermove": case "MSPointerMove": case "pointerup": case "MSPointerUp":
						return o ? [e.originalEvent.pageY-o[0]+io[0],e.originalEvent.pageX-o[1]+io[1],false] : [e.originalEvent.pageY,e.originalEvent.pageX,false];
						break;
					case "touchstart": case "touchmove": case "touchend":
						var touch=e.originalEvent.touches[0] || e.originalEvent.changedTouches[0],
							touches=e.originalEvent.touches.length || e.originalEvent.changedTouches.length;
						return e.target.ownerDocument!==document ? [touch.screenY,touch.screenX,touches>1] : [touch.pageY,touch.pageX,touches>1];
						break;
					default:
						return o ? [e.pageY-o[0]+io[0],e.pageX-o[1]+io[1],false] : [e.pageY,e.pageX,false];
				}
			},
			/* -------------------- */
			
			
			/* 
			SCROLLBAR DRAG EVENTS
			scrolls content via scrollbar dragging 
			*/
			_draggable=function(){
				var $this=$(this),d=$this.data(pluginPfx),o=d.opt,
					namespace=pluginPfx+"_"+d.idx,
					draggerId=["mCSB_"+d.idx+"_dragger_vertical","mCSB_"+d.idx+"_dragger_horizontal"],
					mCSB_container=$("#mCSB_"+d.idx+"_container"),
					mCSB_dragger=$("#"+draggerId[0]+",#"+draggerId[1]),
					draggable,dragY,dragX,
					rds=o.advanced.releaseDraggableSelectors ? mCSB_dragger.add($(o.advanced.releaseDraggableSelectors)) : mCSB_dragger,
					eds=o.advanced.extraDraggableSelectors ? $(!_canAccessIFrame() || top.document).add($(o.advanced.extraDraggableSelectors)) : $(!_canAccessIFrame() || top.document);
				mCSB_dragger.bind("contextmenu."+namespace,function(e){
					e.preventDefault(); //prevent right click
				}).bind("mousedown."+namespace+" touchstart."+namespace+" pointerdown."+namespace+" MSPointerDown."+namespace,function(e){
					e.stopImmediatePropagation();
					e.preventDefault();
					if(!_mouseBtnLeft(e)){return;} /* left mouse button only */
					touchActive=true;
					if(oldIE){document.onselectstart=function(){return false;}} /* disable text selection for IE < 9 */
					_iframe.call(mCSB_container,false); /* enable scrollbar dragging over iframes by disabling their events */
					_stop($this);
					draggable=$(this);
					var offset=draggable.offset(),y=_coordinates(e)[0]-offset.top,x=_coordinates(e)[1]-offset.left,
						h=draggable.height()+offset.top,w=draggable.width()+offset.left;
					if(y<h && y>0 && x<w && x>0){
						dragY=y; 
						dragX=x;
					}
					_onDragClasses(draggable,"active",o.autoExpandScrollbar); 
				}).bind("touchmove."+namespace,function(e){
					e.stopImmediatePropagation();
					e.preventDefault();
					var offset=draggable.offset(),y=_coordinates(e)[0]-offset.top,x=_coordinates(e)[1]-offset.left;
					_drag(dragY,dragX,y,x);
				});
				$(document).add(eds).bind("mousemove."+namespace+" pointermove."+namespace+" MSPointerMove."+namespace,function(e){
					if(draggable){
						var offset=draggable.offset(),y=_coordinates(e)[0]-offset.top,x=_coordinates(e)[1]-offset.left;
						if(dragY===y && dragX===x){return;} /* has it really moved? */
						_drag(dragY,dragX,y,x);
					}
				}).add(rds).bind("mouseup."+namespace+" touchend."+namespace+" pointerup."+namespace+" MSPointerUp."+namespace,function(e){
					if(draggable){
						_onDragClasses(draggable,"active",o.autoExpandScrollbar); 
						draggable=null;
					}
					touchActive=false;
					if(oldIE){document.onselectstart=null;} /* enable text selection for IE < 9 */
					_iframe.call(mCSB_container,true); /* enable iframes events */
				});
				function _drag(dragY,dragX,y,x){
					mCSB_container[0].idleTimer=o.scrollInertia<233 ? 250 : 0;
					if(draggable.attr("id")===draggerId[1]){
						var dir="x",to=((draggable[0].offsetLeft-dragX)+x)*d.scrollRatio.x;
					}else{
						var dir="y",to=((draggable[0].offsetTop-dragY)+y)*d.scrollRatio.y;
					}
					_scrollTo($this,to.toString(),{dir:dir,drag:true});
				}
			},
			/* -------------------- */
			
			
			/* 
			TOUCH SWIPE EVENTS
			scrolls content via touch swipe 
			Emulates the native touch-swipe scrolling with momentum found in iOS, Android and WP devices 
			*/
			_contentDraggable=function(){
				var $this=$(this),d=$this.data(pluginPfx),o=d.opt,
					namespace=pluginPfx+"_"+d.idx,
					mCustomScrollBox=$("#mCSB_"+d.idx),
					mCSB_container=$("#mCSB_"+d.idx+"_container"),
					mCSB_dragger=[$("#mCSB_"+d.idx+"_dragger_vertical"),$("#mCSB_"+d.idx+"_dragger_horizontal")],
					draggable,dragY,dragX,touchStartY,touchStartX,touchMoveY=[],touchMoveX=[],startTime,runningTime,endTime,distance,speed,amount,
					durA=0,durB,overwrite=o.axis==="yx" ? "none" : "all",touchIntent=[],touchDrag,docDrag,
					iframe=mCSB_container.find("iframe"),
					events=[
						"touchstart."+namespace+" pointerdown."+namespace+" MSPointerDown."+namespace, //start
						"touchmove."+namespace+" pointermove."+namespace+" MSPointerMove."+namespace, //move
						"touchend."+namespace+" pointerup."+namespace+" MSPointerUp."+namespace //end
					],
					touchAction=document.body.style.touchAction!==undefined && document.body.style.touchAction!=="";
				mCSB_container.bind(events[0],function(e){
					_onTouchstart(e);
				}).bind(events[1],function(e){
					_onTouchmove(e);
				});
				mCustomScrollBox.bind(events[0],function(e){
					_onTouchstart2(e);
				}).bind(events[2],function(e){
					_onTouchend(e);
				});
				if(iframe.length){
					iframe.each(function(){
						$(this).bind("load",function(){
							/* bind events on accessible iframes */
							if(_canAccessIFrame(this)){
								$(this.contentDocument || this.contentWindow.document).bind(events[0],function(e){
									_onTouchstart(e);
									_onTouchstart2(e);
								}).bind(events[1],function(e){
									_onTouchmove(e);
								}).bind(events[2],function(e){
									_onTouchend(e);
								});
							}
						});
					});
				}
				function _onTouchstart(e){
					if(!_pointerTouch(e) || touchActive || _coordinates(e)[2]){touchable=0; return;}
					touchable=1; touchDrag=0; docDrag=0; draggable=1;
					$this.removeClass("mCS_touch_action");
					var offset=mCSB_container.offset();
					dragY=_coordinates(e)[0]-offset.top;
					dragX=_coordinates(e)[1]-offset.left;
					touchIntent=[_coordinates(e)[0],_coordinates(e)[1]];
				}
				function _onTouchmove(e){
					if(!_pointerTouch(e) || touchActive || _coordinates(e)[2]){return;}
					if(!o.documentTouchScroll){e.preventDefault();} 
					e.stopImmediatePropagation();
					if(docDrag && !touchDrag){return;}
					if(draggable){
						runningTime=_getTime();
						var offset=mCustomScrollBox.offset(),y=_coordinates(e)[0]-offset.top,x=_coordinates(e)[1]-offset.left,
							easing="mcsLinearOut";
						touchMoveY.push(y);
						touchMoveX.push(x);
						touchIntent[2]=Math.abs(_coordinates(e)[0]-touchIntent[0]); touchIntent[3]=Math.abs(_coordinates(e)[1]-touchIntent[1]);
						if(d.overflowed[0]){
							var limit=mCSB_dragger[0].parent().height()-mCSB_dragger[0].height(),
								prevent=((dragY-y)>0 && (y-dragY)>-(limit*d.scrollRatio.y) && (touchIntent[3]*2<touchIntent[2] || o.axis==="yx"));
						}
						if(d.overflowed[1]){
							var limitX=mCSB_dragger[1].parent().width()-mCSB_dragger[1].width(),
								preventX=((dragX-x)>0 && (x-dragX)>-(limitX*d.scrollRatio.x) && (touchIntent[2]*2<touchIntent[3] || o.axis==="yx"));
						}
						if(prevent || preventX){ /* prevent native document scrolling */
							if(!touchAction){e.preventDefault();} 
							touchDrag=1;
						}else{
							docDrag=1;
							$this.addClass("mCS_touch_action");
						}
						if(touchAction){e.preventDefault();} 
						amount=o.axis==="yx" ? [(dragY-y),(dragX-x)] : o.axis==="x" ? [null,(dragX-x)] : [(dragY-y),null];
						mCSB_container[0].idleTimer=250;
						if(d.overflowed[0]){_drag(amount[0],durA,easing,"y","all",true);}
						if(d.overflowed[1]){_drag(amount[1],durA,easing,"x",overwrite,true);}
					}
				}
				function _onTouchstart2(e){
					if(!_pointerTouch(e) || touchActive || _coordinates(e)[2]){touchable=0; return;}
					touchable=1;
					e.stopImmediatePropagation();
					_stop($this);
					startTime=_getTime();
					var offset=mCustomScrollBox.offset();
					touchStartY=_coordinates(e)[0]-offset.top;
					touchStartX=_coordinates(e)[1]-offset.left;
					touchMoveY=[]; touchMoveX=[];
				}
				function _onTouchend(e){
					if(!_pointerTouch(e) || touchActive || _coordinates(e)[2]){return;}
					draggable=0;
					e.stopImmediatePropagation();
					touchDrag=0; docDrag=0;
					endTime=_getTime();
					var offset=mCustomScrollBox.offset(),y=_coordinates(e)[0]-offset.top,x=_coordinates(e)[1]-offset.left;
					if((endTime-runningTime)>30){return;}
					speed=1000/(endTime-startTime);
					var easing="mcsEaseOut",slow=speed<2.5,
						diff=slow ? [touchMoveY[touchMoveY.length-2],touchMoveX[touchMoveX.length-2]] : [0,0];
					distance=slow ? [(y-diff[0]),(x-diff[1])] : [y-touchStartY,x-touchStartX];
					var absDistance=[Math.abs(distance[0]),Math.abs(distance[1])];
					speed=slow ? [Math.abs(distance[0]/4),Math.abs(distance[1]/4)] : [speed,speed];
					var a=[
						Math.abs(mCSB_container[0].offsetTop)-(distance[0]*_m((absDistance[0]/speed[0]),speed[0])),
						Math.abs(mCSB_container[0].offsetLeft)-(distance[1]*_m((absDistance[1]/speed[1]),speed[1]))
					];
					amount=o.axis==="yx" ? [a[0],a[1]] : o.axis==="x" ? [null,a[1]] : [a[0],null];
					durB=[(absDistance[0]*4)+o.scrollInertia,(absDistance[1]*4)+o.scrollInertia];
					var md=parseInt(o.contentTouchScroll) || 0; /* absolute minimum distance required */
					amount[0]=absDistance[0]>md ? amount[0] : 0;
					amount[1]=absDistance[1]>md ? amount[1] : 0;
					if(d.overflowed[0]){_drag(amount[0],durB[0],easing,"y",overwrite,false);}
					if(d.overflowed[1]){_drag(amount[1],durB[1],easing,"x",overwrite,false);}
				}
				function _m(ds,s){
					var r=[s*1.5,s*2,s/1.5,s/2];
					if(ds>90){
						return s>4 ? r[0] : r[3];
					}else if(ds>60){
						return s>3 ? r[3] : r[2];
					}else if(ds>30){
						return s>8 ? r[1] : s>6 ? r[0] : s>4 ? s : r[2];
					}else{
						return s>8 ? s : r[3];
					}
				}
				function _drag(amount,dur,easing,dir,overwrite,drag){
					if(!amount){return;}
					_scrollTo($this,amount.toString(),{dur:dur,scrollEasing:easing,dir:dir,overwrite:overwrite,drag:drag});
				}
			},
			/* -------------------- */
			
			
			/* 
			SELECT TEXT EVENTS 
			scrolls content when text is selected 
			*/
			_selectable=function(){
				var $this=$(this),d=$this.data(pluginPfx),o=d.opt,seq=d.sequential,
					namespace=pluginPfx+"_"+d.idx,
					mCSB_container=$("#mCSB_"+d.idx+"_container"),
					wrapper=mCSB_container.parent(),
					action;
				mCSB_container.bind("mousedown."+namespace,function(e){
					if(touchable){return;}
					if(!action){action=1; touchActive=true;}
				}).add(document).bind("mousemove."+namespace,function(e){
					if(!touchable && action && _sel()){
						var offset=mCSB_container.offset(),
							y=_coordinates(e)[0]-offset.top+mCSB_container[0].offsetTop,x=_coordinates(e)[1]-offset.left+mCSB_container[0].offsetLeft;
						if(y>0 && y<wrapper.height() && x>0 && x<wrapper.width()){
							if(seq.step){_seq("off",null,"stepped");}
						}else{
							if(o.axis!=="x" && d.overflowed[0]){
								if(y<0){
									_seq("on",38);
								}else if(y>wrapper.height()){
									_seq("on",40);
								}
							}
							if(o.axis!=="y" && d.overflowed[1]){
								if(x<0){
									_seq("on",37);
								}else if(x>wrapper.width()){
									_seq("on",39);
								}
							}
						}
					}
				}).bind("mouseup."+namespace+" dragend."+namespace,function(e){
					if(touchable){return;}
					if(action){action=0; _seq("off",null);}
					touchActive=false;
				});
				function _sel(){
					return 	window.getSelection ? window.getSelection().toString() : 
							document.selection && document.selection.type!="Control" ? document.selection.createRange().text : 0;
				}
				function _seq(a,c,s){
					seq.type=s && action ? "stepped" : "stepless";
					seq.scrollAmount=10;
					_sequentialScroll($this,a,c,"mcsLinearOut",s ? 60 : null);
				}
			},
			/* -------------------- */
			
			
			/* 
			MOUSE WHEEL EVENT
			scrolls content via mouse-wheel 
			via mouse-wheel plugin (https://github.com/brandonaaron/jquery-mousewheel)
			*/
			_mousewheel=function(){
				if(!$(this).data(pluginPfx)){return;} /* Check if the scrollbar is ready to use mousewheel events (issue: #185) */
				var $this=$(this),d=$this.data(pluginPfx),o=d.opt,
					namespace=pluginPfx+"_"+d.idx,
					mCustomScrollBox=$("#mCSB_"+d.idx),
					mCSB_dragger=[$("#mCSB_"+d.idx+"_dragger_vertical"),$("#mCSB_"+d.idx+"_dragger_horizontal")],
					iframe=$("#mCSB_"+d.idx+"_container").find("iframe");
				if(iframe.length){
					iframe.each(function(){
						$(this).bind("load",function(){
							/* bind events on accessible iframes */
							if(_canAccessIFrame(this)){
								$(this.contentDocument || this.contentWindow.document).bind("mousewheel."+namespace,function(e,delta){
									_onMousewheel(e,delta);
								});
							}
						});
					});
				}
				mCustomScrollBox.bind("mousewheel."+namespace,function(e,delta){
					_onMousewheel(e,delta);
				});
				function _onMousewheel(e,delta){
					_stop($this);
					if(_disableMousewheel($this,e.target)){return;} /* disables mouse-wheel when hovering specific elements */
					var deltaFactor=o.mouseWheel.deltaFactor!=="auto" ? parseInt(o.mouseWheel.deltaFactor) : (oldIE && e.deltaFactor<100) ? 100 : e.deltaFactor || 100,
						dur=o.scrollInertia;
					if(o.axis==="x" || o.mouseWheel.axis==="x"){
						var dir="x",
							px=[Math.round(deltaFactor*d.scrollRatio.x),parseInt(o.mouseWheel.scrollAmount)],
							amount=o.mouseWheel.scrollAmount!=="auto" ? px[1] : px[0]>=mCustomScrollBox.width() ? mCustomScrollBox.width()*0.9 : px[0],
							contentPos=Math.abs($("#mCSB_"+d.idx+"_container")[0].offsetLeft),
							draggerPos=mCSB_dragger[1][0].offsetLeft,
							limit=mCSB_dragger[1].parent().width()-mCSB_dragger[1].width(),
							dlt=o.mouseWheel.axis==="y" ? (e.deltaY || delta) : e.deltaX;
					}else{
						var dir="y",
							px=[Math.round(deltaFactor*d.scrollRatio.y),parseInt(o.mouseWheel.scrollAmount)],
							amount=o.mouseWheel.scrollAmount!=="auto" ? px[1] : px[0]>=mCustomScrollBox.height() ? mCustomScrollBox.height()*0.9 : px[0],
							contentPos=Math.abs($("#mCSB_"+d.idx+"_container")[0].offsetTop),
							draggerPos=mCSB_dragger[0][0].offsetTop,
							limit=mCSB_dragger[0].parent().height()-mCSB_dragger[0].height(),
							dlt=e.deltaY || delta;
					}
					if((dir==="y" && !d.overflowed[0]) || (dir==="x" && !d.overflowed[1])){return;}
					if(o.mouseWheel.invert || e.webkitDirectionInvertedFromDevice){dlt=-dlt;}
					if(o.mouseWheel.normalizeDelta){dlt=dlt<0 ? -1 : 1;}
					if((dlt>0 && draggerPos!==0) || (dlt<0 && draggerPos!==limit) || o.mouseWheel.preventDefault){
						e.stopImmediatePropagation();
						e.preventDefault();
					}
					if(e.deltaFactor<5 && !o.mouseWheel.normalizeDelta){
						//very low deltaFactor values mean some kind of delta acceleration (e.g. osx trackpad), so adjusting scrolling accordingly
						amount=e.deltaFactor; dur=17;
					}
					_scrollTo($this,(contentPos-(dlt*amount)).toString(),{dir:dir,dur:dur});
				}
			},
			/* -------------------- */
			
			
			/* checks if iframe can be accessed */
			_canAccessIFrameCache=new Object(),
			_canAccessIFrame=function(iframe){
			    var result=false,cacheKey=false,html=null;
			    if(iframe===undefined){
					cacheKey="#empty";
			    }else if($(iframe).attr("id")!==undefined){
					cacheKey=$(iframe).attr("id");
			    }
				if(cacheKey!==false && _canAccessIFrameCache[cacheKey]!==undefined){
					return _canAccessIFrameCache[cacheKey];
				}
				if(!iframe){
					try{
						var doc=top.document;
						html=doc.body.innerHTML;
					}catch(err){/* do nothing */}
					result=(html!==null);
				}else{
					try{
						var doc=iframe.contentDocument || iframe.contentWindow.document;
						html=doc.body.innerHTML;
					}catch(err){/* do nothing */}
					result=(html!==null);
				}
				if(cacheKey!==false){_canAccessIFrameCache[cacheKey]=result;}
				return result;
			},
			/* -------------------- */
			
			
			/* switches iframe's pointer-events property (drag, mousewheel etc. over cross-domain iframes) */
			_iframe=function(evt){
				var el=this.find("iframe");
				if(!el.length){return;} /* check if content contains iframes */
				var val=!evt ? "none" : "auto";
				el.css("pointer-events",val); /* for IE11, iframe's display property should not be "block" */
			},
			/* -------------------- */
			
			
			/* disables mouse-wheel when hovering specific elements like select, datalist etc. */
			_disableMousewheel=function(el,target){
				var tag=target.nodeName.toLowerCase(),
					tags=el.data(pluginPfx).opt.mouseWheel.disableOver,
					/* elements that require focus */
					focusTags=["select","textarea"];
				return $.inArray(tag,tags) > -1 && !($.inArray(tag,focusTags) > -1 && !$(target).is(":focus"));
			},
			/* -------------------- */
			
			
			/* 
			DRAGGER RAIL CLICK EVENT
			scrolls content via dragger rail 
			*/
			_draggerRail=function(){
				var $this=$(this),d=$this.data(pluginPfx),
					namespace=pluginPfx+"_"+d.idx,
					mCSB_container=$("#mCSB_"+d.idx+"_container"),
					wrapper=mCSB_container.parent(),
					mCSB_draggerContainer=$(".mCSB_"+d.idx+"_scrollbar ."+classes[12]),
					clickable;
				mCSB_draggerContainer.bind("mousedown."+namespace+" touchstart."+namespace+" pointerdown."+namespace+" MSPointerDown."+namespace,function(e){
					touchActive=true;
					if(!$(e.target).hasClass("mCSB_dragger")){clickable=1;}
				}).bind("touchend."+namespace+" pointerup."+namespace+" MSPointerUp."+namespace,function(e){
					touchActive=false;
				}).bind("click."+namespace,function(e){
					if(!clickable){return;}
					clickable=0;
					if($(e.target).hasClass(classes[12]) || $(e.target).hasClass("mCSB_draggerRail")){
						_stop($this);
						var el=$(this),mCSB_dragger=el.find(".mCSB_dragger");
						if(el.parent(".mCSB_scrollTools_horizontal").length>0){
							if(!d.overflowed[1]){return;}
							var dir="x",
								clickDir=e.pageX>mCSB_dragger.offset().left ? -1 : 1,
								to=Math.abs(mCSB_container[0].offsetLeft)-(clickDir*(wrapper.width()*0.9));
						}else{
							if(!d.overflowed[0]){return;}
							var dir="y",
								clickDir=e.pageY>mCSB_dragger.offset().top ? -1 : 1,
								to=Math.abs(mCSB_container[0].offsetTop)-(clickDir*(wrapper.height()*0.9));
						}
						_scrollTo($this,to.toString(),{dir:dir,scrollEasing:"mcsEaseInOut"});
					}
				});
			},
			/* -------------------- */
			
			
			/* 
			FOCUS EVENT
			scrolls content via element focus (e.g. clicking an input, pressing TAB key etc.)
			*/
			_focus=function(){
				var $this=$(this),d=$this.data(pluginPfx),o=d.opt,
					namespace=pluginPfx+"_"+d.idx,
					mCSB_container=$("#mCSB_"+d.idx+"_container"),
					wrapper=mCSB_container.parent();
				mCSB_container.bind("focusin."+namespace,function(e){
					var el=$(document.activeElement),
						nested=mCSB_container.find(".mCustomScrollBox").length,
						dur=0;
					if(!el.is(o.advanced.autoScrollOnFocus)){return;}
					_stop($this);
					clearTimeout($this[0]._focusTimeout);
					$this[0]._focusTimer=nested ? (dur+17)*nested : 0;
					$this[0]._focusTimeout=setTimeout(function(){
						var	to=[_childPos(el)[0],_childPos(el)[1]],
							contentPos=[mCSB_container[0].offsetTop,mCSB_container[0].offsetLeft],
							isVisible=[
								(contentPos[0]+to[0]>=0 && contentPos[0]+to[0]<wrapper.height()-el.outerHeight(false)),
								(contentPos[1]+to[1]>=0 && contentPos[0]+to[1]<wrapper.width()-el.outerWidth(false))
							],
							overwrite=(o.axis==="yx" && !isVisible[0] && !isVisible[1]) ? "none" : "all";
						if(o.axis!=="x" && !isVisible[0]){
							_scrollTo($this,to[0].toString(),{dir:"y",scrollEasing:"mcsEaseInOut",overwrite:overwrite,dur:dur});
						}
						if(o.axis!=="y" && !isVisible[1]){
							_scrollTo($this,to[1].toString(),{dir:"x",scrollEasing:"mcsEaseInOut",overwrite:overwrite,dur:dur});
						}
					},$this[0]._focusTimer);
				});
			},
			/* -------------------- */
			
			
			/* sets content wrapper scrollTop/scrollLeft always to 0 */
			_wrapperScroll=function(){
				var $this=$(this),d=$this.data(pluginPfx),
					namespace=pluginPfx+"_"+d.idx,
					wrapper=$("#mCSB_"+d.idx+"_container").parent();
				wrapper.bind("scroll."+namespace,function(e){
					if(wrapper.scrollTop()!==0 || wrapper.scrollLeft()!==0){
						$(".mCSB_"+d.idx+"_scrollbar").css("visibility","hidden"); /* hide scrollbar(s) */
					}
				});
			},
			/* -------------------- */
			
			
			/* 
			BUTTONS EVENTS
			scrolls content via up, down, left and right buttons 
			*/
			_buttons=function(){
				var $this=$(this),d=$this.data(pluginPfx),o=d.opt,seq=d.sequential,
					namespace=pluginPfx+"_"+d.idx,
					sel=".mCSB_"+d.idx+"_scrollbar",
					btn=$(sel+">a");
				btn.bind("contextmenu."+namespace,function(e){
					e.preventDefault(); //prevent right click
				}).bind("mousedown."+namespace+" touchstart."+namespace+" pointerdown."+namespace+" MSPointerDown."+namespace+" mouseup."+namespace+" touchend."+namespace+" pointerup."+namespace+" MSPointerUp."+namespace+" mouseout."+namespace+" pointerout."+namespace+" MSPointerOut."+namespace+" click."+namespace,function(e){
					e.preventDefault();
					if(!_mouseBtnLeft(e)){return;} /* left mouse button only */
					var btnClass=$(this).attr("class");
					seq.type=o.scrollButtons.scrollType;
					switch(e.type){
						case "mousedown": case "touchstart": case "pointerdown": case "MSPointerDown":
							if(seq.type==="stepped"){return;}
							touchActive=true;
							d.tweenRunning=false;
							_seq("on",btnClass);
							break;
						case "mouseup": case "touchend": case "pointerup": case "MSPointerUp":
						case "mouseout": case "pointerout": case "MSPointerOut":
							if(seq.type==="stepped"){return;}
							touchActive=false;
							if(seq.dir){_seq("off",btnClass);}
							break;
						case "click":
							if(seq.type!=="stepped" || d.tweenRunning){return;}
							_seq("on",btnClass);
							break;
					}
					function _seq(a,c){
						seq.scrollAmount=o.scrollButtons.scrollAmount;
						_sequentialScroll($this,a,c);
					}
				});
			},
			/* -------------------- */
			
			
			/* 
			KEYBOARD EVENTS
			scrolls content via keyboard 
			Keys: up arrow, down arrow, left arrow, right arrow, PgUp, PgDn, Home, End
			*/
			_keyboard=function(){
				var $this=$(this),d=$this.data(pluginPfx),o=d.opt,seq=d.sequential,
					namespace=pluginPfx+"_"+d.idx,
					mCustomScrollBox=$("#mCSB_"+d.idx),
					mCSB_container=$("#mCSB_"+d.idx+"_container"),
					wrapper=mCSB_container.parent(),
					editables="input,textarea,select,datalist,keygen,[contenteditable='true']",
					iframe=mCSB_container.find("iframe"),
					events=["blur."+namespace+" keydown."+namespace+" keyup."+namespace];
				if(iframe.length){
					iframe.each(function(){
						$(this).bind("load",function(){
							/* bind events on accessible iframes */
							if(_canAccessIFrame(this)){
								$(this.contentDocument || this.contentWindow.document).bind(events[0],function(e){
									_onKeyboard(e);
								});
							}
						});
					});
				}
				mCustomScrollBox.attr("tabindex","0").bind(events[0],function(e){
					_onKeyboard(e);
				});
				function _onKeyboard(e){
					switch(e.type){
						case "blur":
							if(d.tweenRunning && seq.dir){_seq("off",null);}
							break;
						case "keydown": case "keyup":
							var code=e.keyCode ? e.keyCode : e.which,action="on";
							if((o.axis!=="x" && (code===38 || code===40)) || (o.axis!=="y" && (code===37 || code===39))){
								/* up (38), down (40), left (37), right (39) arrows */
								if(((code===38 || code===40) && !d.overflowed[0]) || ((code===37 || code===39) && !d.overflowed[1])){return;}
								if(e.type==="keyup"){action="off";}
								if(!$(document.activeElement).is(editables)){
									e.preventDefault();
									e.stopImmediatePropagation();
									_seq(action,code);
								}
							}else if(code===33 || code===34){
								/* PgUp (33), PgDn (34) */
								if(d.overflowed[0] || d.overflowed[1]){
									e.preventDefault();
									e.stopImmediatePropagation();
								}
								if(e.type==="keyup"){
									_stop($this);
									var keyboardDir=code===34 ? -1 : 1;
									if(o.axis==="x" || (o.axis==="yx" && d.overflowed[1] && !d.overflowed[0])){
										var dir="x",to=Math.abs(mCSB_container[0].offsetLeft)-(keyboardDir*(wrapper.width()*0.9));
									}else{
										var dir="y",to=Math.abs(mCSB_container[0].offsetTop)-(keyboardDir*(wrapper.height()*0.9));
									}
									_scrollTo($this,to.toString(),{dir:dir,scrollEasing:"mcsEaseInOut"});
								}
							}else if(code===35 || code===36){
								/* End (35), Home (36) */
								if(!$(document.activeElement).is(editables)){
									if(d.overflowed[0] || d.overflowed[1]){
										e.preventDefault();
										e.stopImmediatePropagation();
									}
									if(e.type==="keyup"){
										if(o.axis==="x" || (o.axis==="yx" && d.overflowed[1] && !d.overflowed[0])){
											var dir="x",to=code===35 ? Math.abs(wrapper.width()-mCSB_container.outerWidth(false)) : 0;
										}else{
											var dir="y",to=code===35 ? Math.abs(wrapper.height()-mCSB_container.outerHeight(false)) : 0;
										}
										_scrollTo($this,to.toString(),{dir:dir,scrollEasing:"mcsEaseInOut"});
									}
								}
							}
							break;
					}
					function _seq(a,c){
						seq.type=o.keyboard.scrollType;
						seq.scrollAmount=o.keyboard.scrollAmount;
						if(seq.type==="stepped" && d.tweenRunning){return;}
						_sequentialScroll($this,a,c);
					}
				}
			},
			/* -------------------- */
			
			
			/* scrolls content sequentially (used when scrolling via buttons, keyboard arrows etc.) */
			_sequentialScroll=function(el,action,trigger,e,s){
				var d=el.data(pluginPfx),o=d.opt,seq=d.sequential,
					mCSB_container=$("#mCSB_"+d.idx+"_container"),
					once=seq.type==="stepped" ? true : false,
					steplessSpeed=o.scrollInertia < 26 ? 26 : o.scrollInertia, /* 26/1.5=17 */
					steppedSpeed=o.scrollInertia < 1 ? 17 : o.scrollInertia;
				switch(action){
					case "on":
						seq.dir=[
							(trigger===classes[16] || trigger===classes[15] || trigger===39 || trigger===37 ? "x" : "y"),
							(trigger===classes[13] || trigger===classes[15] || trigger===38 || trigger===37 ? -1 : 1)
						];
						_stop(el);
						if(_isNumeric(trigger) && seq.type==="stepped"){return;}
						_on(once);
						break;
					case "off":
						_off();
						if(once || (d.tweenRunning && seq.dir)){
							_on(true);
						}
						break;
				}
				
				/* starts sequence */
				function _on(once){
					if(o.snapAmount){seq.scrollAmount=!(o.snapAmount instanceof Array) ? o.snapAmount : seq.dir[0]==="x" ? o.snapAmount[1] : o.snapAmount[0];} /* scrolling snapping */
					var c=seq.type!=="stepped", /* continuous scrolling */
						t=s ? s : !once ? 1000/60 : c ? steplessSpeed/1.5 : steppedSpeed, /* timer */
						m=!once ? 2.5 : c ? 7.5 : 40, /* multiplier */
						contentPos=[Math.abs(mCSB_container[0].offsetTop),Math.abs(mCSB_container[0].offsetLeft)],
						ratio=[d.scrollRatio.y>10 ? 10 : d.scrollRatio.y,d.scrollRatio.x>10 ? 10 : d.scrollRatio.x],
						amount=seq.dir[0]==="x" ? contentPos[1]+(seq.dir[1]*(ratio[1]*m)) : contentPos[0]+(seq.dir[1]*(ratio[0]*m)),
						px=seq.dir[0]==="x" ? contentPos[1]+(seq.dir[1]*parseInt(seq.scrollAmount)) : contentPos[0]+(seq.dir[1]*parseInt(seq.scrollAmount)),
						to=seq.scrollAmount!=="auto" ? px : amount,
						easing=e ? e : !once ? "mcsLinear" : c ? "mcsLinearOut" : "mcsEaseInOut",
						onComplete=!once ? false : true;
					if(once && t<17){
						to=seq.dir[0]==="x" ? contentPos[1] : contentPos[0];
					}
					_scrollTo(el,to.toString(),{dir:seq.dir[0],scrollEasing:easing,dur:t,onComplete:onComplete});
					if(once){
						seq.dir=false;
						return;
					}
					clearTimeout(seq.step);
					seq.step=setTimeout(function(){
						_on();
					},t);
				}
				/* stops sequence */
				function _off(){
					clearTimeout(seq.step);
					_delete(seq,"step");
					_stop(el);
				}
			},
			/* -------------------- */
			
			
			/* returns a yx array from value */
			_arr=function(val){
				var o=$(this).data(pluginPfx).opt,vals=[];
				if(typeof val==="function"){val=val();} /* check if the value is a single anonymous function */
				/* check if value is object or array, its length and create an array with yx values */
				if(!(val instanceof Array)){ /* object value (e.g. {y:"100",x:"100"}, 100 etc.) */
					vals[0]=val.y ? val.y : val.x || o.axis==="x" ? null : val;
					vals[1]=val.x ? val.x : val.y || o.axis==="y" ? null : val;
				}else{ /* array value (e.g. [100,100]) */
					vals=val.length>1 ? [val[0],val[1]] : o.axis==="x" ? [null,val[0]] : [val[0],null];
				}
				/* check if array values are anonymous functions */
				if(typeof vals[0]==="function"){vals[0]=vals[0]();}
				if(typeof vals[1]==="function"){vals[1]=vals[1]();}
				return vals;
			},
			/* -------------------- */
			
			
			/* translates values (e.g. "top", 100, "100px", "#id") to actual scroll-to positions */
			_to=function(val,dir){
				if(val==null || typeof val=="undefined"){return;}
				var $this=$(this),d=$this.data(pluginPfx),o=d.opt,
					mCSB_container=$("#mCSB_"+d.idx+"_container"),
					wrapper=mCSB_container.parent(),
					t=typeof val;
				if(!dir){dir=o.axis==="x" ? "x" : "y";}
				var contentLength=dir==="x" ? mCSB_container.outerWidth(false)-wrapper.width() : mCSB_container.outerHeight(false)-wrapper.height(),
					contentPos=dir==="x" ? mCSB_container[0].offsetLeft : mCSB_container[0].offsetTop,
					cssProp=dir==="x" ? "left" : "top";
				switch(t){
					case "function": /* this currently is not used. Consider removing it */
						return val();
						break;
					case "object": /* js/jquery object */
						var obj=val.jquery ? val : $(val);
						if(!obj.length){return;}
						return dir==="x" ? _childPos(obj)[1] : _childPos(obj)[0];
						break;
					case "string": case "number":
						if(_isNumeric(val)){ /* numeric value */
							return Math.abs(val);
						}else if(val.indexOf("%")!==-1){ /* percentage value */
							return Math.abs(contentLength*parseInt(val)/100);
						}else if(val.indexOf("-=")!==-1){ /* decrease value */
							return Math.abs(contentPos-parseInt(val.split("-=")[1]));
						}else if(val.indexOf("+=")!==-1){ /* inrease value */
							var p=(contentPos+parseInt(val.split("+=")[1]));
							return p>=0 ? 0 : Math.abs(p);
						}else if(val.indexOf("px")!==-1 && _isNumeric(val.split("px")[0])){ /* pixels string value (e.g. "100px") */
							return Math.abs(val.split("px")[0]);
						}else{
							if(val==="top" || val==="left"){ /* special strings */
								return 0;
							}else if(val==="bottom"){
								return Math.abs(wrapper.height()-mCSB_container.outerHeight(false));
							}else if(val==="right"){
								return Math.abs(wrapper.width()-mCSB_container.outerWidth(false));
							}else if(val==="first" || val==="last"){
								var obj=mCSB_container.find(":"+val);
								return dir==="x" ? _childPos(obj)[1] : _childPos(obj)[0];
							}else{
								if($(val).length){ /* jquery selector */
									return dir==="x" ? _childPos($(val))[1] : _childPos($(val))[0];
								}else{ /* other values (e.g. "100em") */
									mCSB_container.css(cssProp,val);
									methods.update.call(null,$this[0]);
									return;
								}
							}
						}
						break;
				}
			},
			/* -------------------- */
			
			
			/* calls the update method automatically */
			_autoUpdate=function(rem){
				var $this=$(this),d=$this.data(pluginPfx),o=d.opt,
					mCSB_container=$("#mCSB_"+d.idx+"_container");
				if(rem){
					/* 
					removes autoUpdate timer 
					usage: _autoUpdate.call(this,"remove");
					*/
					clearTimeout(mCSB_container[0].autoUpdate);
					_delete(mCSB_container[0],"autoUpdate");
					return;
				}
				upd();
				function upd(){
					clearTimeout(mCSB_container[0].autoUpdate);
					if($this.parents("html").length===0){
						/* check element in dom tree */
						$this=null;
						return;
					}
					mCSB_container[0].autoUpdate=setTimeout(function(){
						/* update on specific selector(s) length and size change */
						if(o.advanced.updateOnSelectorChange){
							d.poll.change.n=sizesSum();
							if(d.poll.change.n!==d.poll.change.o){
								d.poll.change.o=d.poll.change.n;
								doUpd(3);
								return;
							}
						}
						/* update on main element and scrollbar size changes */
						if(o.advanced.updateOnContentResize){
							d.poll.size.n=$this[0].scrollHeight+$this[0].scrollWidth+mCSB_container[0].offsetHeight+$this[0].offsetHeight+$this[0].offsetWidth;
							if(d.poll.size.n!==d.poll.size.o){
								d.poll.size.o=d.poll.size.n;
								doUpd(1);
								return;
							}
						}
						/* update on image load */
						if(o.advanced.updateOnImageLoad){
							if(!(o.advanced.updateOnImageLoad==="auto" && o.axis==="y")){ //by default, it doesn't run on vertical content
								d.poll.img.n=mCSB_container.find("img").length;
								if(d.poll.img.n!==d.poll.img.o){
									d.poll.img.o=d.poll.img.n;
									mCSB_container.find("img").each(function(){
										imgLoader(this);
									});
									return;
								}
							}
						}
						if(o.advanced.updateOnSelectorChange || o.advanced.updateOnContentResize || o.advanced.updateOnImageLoad){upd();}
					},o.advanced.autoUpdateTimeout);
				}
				/* a tiny image loader */
				function imgLoader(el){
					if($(el).hasClass(classes[2])){doUpd(); return;}
					var img=new Image();
					function createDelegate(contextObject,delegateMethod){
						return function(){return delegateMethod.apply(contextObject,arguments);}
					}
					function imgOnLoad(){
						this.onload=null;
						$(el).addClass(classes[2]);
						doUpd(2);
					}
					img.onload=createDelegate(img,imgOnLoad);
					img.src=el.src;
				}
				/* returns the total height and width sum of all elements matching the selector */
				function sizesSum(){
					if(o.advanced.updateOnSelectorChange===true){o.advanced.updateOnSelectorChange="*";}
					var total=0,sel=mCSB_container.find(o.advanced.updateOnSelectorChange);
					if(o.advanced.updateOnSelectorChange && sel.length>0){sel.each(function(){total+=this.offsetHeight+this.offsetWidth;});}
					return total;
				}
				/* calls the update method */
				function doUpd(cb){
					clearTimeout(mCSB_container[0].autoUpdate);
					methods.update.call(null,$this[0],cb);
				}
			},
			/* -------------------- */
			
			
			/* snaps scrolling to a multiple of a pixels number */
			_snapAmount=function(to,amount,offset){
				return (Math.round(to/amount)*amount-offset); 
			},
			/* -------------------- */
			
			
			/* stops content and scrollbar animations */
			_stop=function(el){
				var d=el.data(pluginPfx),
					sel=$("#mCSB_"+d.idx+"_container,#mCSB_"+d.idx+"_container_wrapper,#mCSB_"+d.idx+"_dragger_vertical,#mCSB_"+d.idx+"_dragger_horizontal");
				sel.each(function(){
					_stopTween.call(this);
				});
			},
			/* -------------------- */
			
			
			/* 
			ANIMATES CONTENT 
			This is where the actual scrolling happens
			*/
			_scrollTo=function(el,to,options){
				var d=el.data(pluginPfx),o=d.opt,
					defaults={
						trigger:"internal",
						dir:"y",
						scrollEasing:"mcsEaseOut",
						drag:false,
						dur:o.scrollInertia,
						overwrite:"all",
						callbacks:true,
						onStart:true,
						onUpdate:true,
						onComplete:true
					},
					options=$.extend(defaults,options),
					dur=[options.dur,(options.drag ? 0 : options.dur)],
					mCustomScrollBox=$("#mCSB_"+d.idx),
					mCSB_container=$("#mCSB_"+d.idx+"_container"),
					wrapper=mCSB_container.parent(),
					totalScrollOffsets=o.callbacks.onTotalScrollOffset ? _arr.call(el,o.callbacks.onTotalScrollOffset) : [0,0],
					totalScrollBackOffsets=o.callbacks.onTotalScrollBackOffset ? _arr.call(el,o.callbacks.onTotalScrollBackOffset) : [0,0];
				d.trigger=options.trigger;
				if(wrapper.scrollTop()!==0 || wrapper.scrollLeft()!==0){ /* always reset scrollTop/Left */
					$(".mCSB_"+d.idx+"_scrollbar").css("visibility","visible");
					wrapper.scrollTop(0).scrollLeft(0);
				}
				if(to==="_resetY" && !d.contentReset.y){
					/* callbacks: onOverflowYNone */
					if(_cb("onOverflowYNone")){o.callbacks.onOverflowYNone.call(el[0]);}
					d.contentReset.y=1;
				}
				if(to==="_resetX" && !d.contentReset.x){
					/* callbacks: onOverflowXNone */
					if(_cb("onOverflowXNone")){o.callbacks.onOverflowXNone.call(el[0]);}
					d.contentReset.x=1;
				}
				if(to==="_resetY" || to==="_resetX"){return;}
				if((d.contentReset.y || !el[0].mcs) && d.overflowed[0]){
					/* callbacks: onOverflowY */
					if(_cb("onOverflowY")){o.callbacks.onOverflowY.call(el[0]);}
					d.contentReset.x=null;
				}
				if((d.contentReset.x || !el[0].mcs) && d.overflowed[1]){
					/* callbacks: onOverflowX */
					if(_cb("onOverflowX")){o.callbacks.onOverflowX.call(el[0]);}
					d.contentReset.x=null;
				}
				if(o.snapAmount){ /* scrolling snapping */
					var snapAmount=!(o.snapAmount instanceof Array) ? o.snapAmount : options.dir==="x" ? o.snapAmount[1] : o.snapAmount[0];
					to=_snapAmount(to,snapAmount,o.snapOffset);
				}
				switch(options.dir){
					case "x":
						var mCSB_dragger=$("#mCSB_"+d.idx+"_dragger_horizontal"),
							property="left",
							contentPos=mCSB_container[0].offsetLeft,
							limit=[
								mCustomScrollBox.width()-mCSB_container.outerWidth(false),
								mCSB_dragger.parent().width()-mCSB_dragger.width()
							],
							scrollTo=[to,to===0 ? 0 : (to/d.scrollRatio.x)],
							tso=totalScrollOffsets[1],
							tsbo=totalScrollBackOffsets[1],
							totalScrollOffset=tso>0 ? tso/d.scrollRatio.x : 0,
							totalScrollBackOffset=tsbo>0 ? tsbo/d.scrollRatio.x : 0;
						break;
					case "y":
						var mCSB_dragger=$("#mCSB_"+d.idx+"_dragger_vertical"),
							property="top",
							contentPos=mCSB_container[0].offsetTop,
							limit=[
								mCustomScrollBox.height()-mCSB_container.outerHeight(false),
								mCSB_dragger.parent().height()-mCSB_dragger.height()
							],
							scrollTo=[to,to===0 ? 0 : (to/d.scrollRatio.y)],
							tso=totalScrollOffsets[0],
							tsbo=totalScrollBackOffsets[0],
							totalScrollOffset=tso>0 ? tso/d.scrollRatio.y : 0,
							totalScrollBackOffset=tsbo>0 ? tsbo/d.scrollRatio.y : 0;
						break;
				}
				if(scrollTo[1]<0 || (scrollTo[0]===0 && scrollTo[1]===0)){
					scrollTo=[0,0];
				}else if(scrollTo[1]>=limit[1]){
					scrollTo=[limit[0],limit[1]];
				}else{
					scrollTo[0]=-scrollTo[0];
				}
				if(!el[0].mcs){
					_mcs();  /* init mcs object (once) to make it available before callbacks */
					if(_cb("onInit")){o.callbacks.onInit.call(el[0]);} /* callbacks: onInit */
				}
				clearTimeout(mCSB_container[0].onCompleteTimeout);
				_tweenTo(mCSB_dragger[0],property,Math.round(scrollTo[1]),dur[1],options.scrollEasing);
				if(!d.tweenRunning && ((contentPos===0 && scrollTo[0]>=0) || (contentPos===limit[0] && scrollTo[0]<=limit[0]))){return;}
				_tweenTo(mCSB_container[0],property,Math.round(scrollTo[0]),dur[0],options.scrollEasing,options.overwrite,{
					onStart:function(){
						if(options.callbacks && options.onStart && !d.tweenRunning){
							/* callbacks: onScrollStart */
							if(_cb("onScrollStart")){_mcs(); o.callbacks.onScrollStart.call(el[0]);}
							d.tweenRunning=true;
							_onDragClasses(mCSB_dragger);
							d.cbOffsets=_cbOffsets();
						}
					},onUpdate:function(){
						if(options.callbacks && options.onUpdate){
							/* callbacks: whileScrolling */
							if(_cb("whileScrolling")){_mcs(); o.callbacks.whileScrolling.call(el[0]);}
						}
					},onComplete:function(){
						if(options.callbacks && options.onComplete){
							if(o.axis==="yx"){clearTimeout(mCSB_container[0].onCompleteTimeout);}
							var t=mCSB_container[0].idleTimer || 0;
							mCSB_container[0].onCompleteTimeout=setTimeout(function(){
								/* callbacks: onScroll, onTotalScroll, onTotalScrollBack */
								if(_cb("onScroll")){_mcs(); o.callbacks.onScroll.call(el[0]);}
								if(_cb("onTotalScroll") && scrollTo[1]>=limit[1]-totalScrollOffset && d.cbOffsets[0]){_mcs(); o.callbacks.onTotalScroll.call(el[0]);}
								if(_cb("onTotalScrollBack") && scrollTo[1]<=totalScrollBackOffset && d.cbOffsets[1]){_mcs(); o.callbacks.onTotalScrollBack.call(el[0]);}
								d.tweenRunning=false;
								mCSB_container[0].idleTimer=0;
								_onDragClasses(mCSB_dragger,"hide");
							},t);
						}
					}
				});
				/* checks if callback function exists */
				function _cb(cb){
					return d && o.callbacks[cb] && typeof o.callbacks[cb]==="function";
				}
				/* checks whether callback offsets always trigger */
				function _cbOffsets(){
					return [o.callbacks.alwaysTriggerOffsets || contentPos>=limit[0]+tso,o.callbacks.alwaysTriggerOffsets || contentPos<=-tsbo];
				}
				/* 
				populates object with useful values for the user 
				values: 
					content: this.mcs.content
					content top position: this.mcs.top 
					content left position: this.mcs.left 
					dragger top position: this.mcs.draggerTop 
					dragger left position: this.mcs.draggerLeft 
					scrolling y percentage: this.mcs.topPct 
					scrolling x percentage: this.mcs.leftPct 
					scrolling direction: this.mcs.direction
				*/
				function _mcs(){
					var cp=[mCSB_container[0].offsetTop,mCSB_container[0].offsetLeft], /* content position */
						dp=[mCSB_dragger[0].offsetTop,mCSB_dragger[0].offsetLeft], /* dragger position */
						cl=[mCSB_container.outerHeight(false),mCSB_container.outerWidth(false)], /* content length */
						pl=[mCustomScrollBox.height(),mCustomScrollBox.width()]; /* content parent length */
					el[0].mcs={
						content:mCSB_container, /* original content wrapper as jquery object */
						top:cp[0],left:cp[1],draggerTop:dp[0],draggerLeft:dp[1],
						topPct:Math.round((100*Math.abs(cp[0]))/(Math.abs(cl[0])-pl[0])),leftPct:Math.round((100*Math.abs(cp[1]))/(Math.abs(cl[1])-pl[1])),
						direction:options.dir
					};
					/* 
					this refers to the original element containing the scrollbar(s)
					usage: this.mcs.top, this.mcs.leftPct etc. 
					*/
				}
			},
			/* -------------------- */
			
			
			/* 
			CUSTOM JAVASCRIPT ANIMATION TWEEN 
			Lighter and faster than jquery animate() and css transitions 
			Animates top/left properties and includes easings 
			*/
			_tweenTo=function(el,prop,to,duration,easing,overwrite,callbacks){
				if(!el._mTween){el._mTween={top:{},left:{}};}
				var callbacks=callbacks || {},
					onStart=callbacks.onStart || function(){},onUpdate=callbacks.onUpdate || function(){},onComplete=callbacks.onComplete || function(){},
					startTime=_getTime(),_delay,progress=0,from=el.offsetTop,elStyle=el.style,_request,tobj=el._mTween[prop];
				if(prop==="left"){from=el.offsetLeft;}
				var diff=to-from;
				tobj.stop=0;
				if(overwrite!=="none"){_cancelTween();}
				_startTween();
				function _step(){
					if(tobj.stop){return;}
					if(!progress){onStart.call();}
					progress=_getTime()-startTime;
					_tween();
					if(progress>=tobj.time){
						tobj.time=(progress>tobj.time) ? progress+_delay-(progress-tobj.time) : progress+_delay-1;
						if(tobj.time<progress+1){tobj.time=progress+1;}
					}
					if(tobj.time<duration){tobj.id=_request(_step);}else{onComplete.call();}
				}
				function _tween(){
					if(duration>0){
						tobj.currVal=_ease(tobj.time,from,diff,duration,easing);
						elStyle[prop]=Math.round(tobj.currVal)+"px";
					}else{
						elStyle[prop]=to+"px";
					}
					onUpdate.call();
				}
				function _startTween(){
					_delay=1000/60;
					tobj.time=progress+_delay;
					_request=(!window.requestAnimationFrame) ? function(f){_tween(); return setTimeout(f,0.01);} : window.requestAnimationFrame;
					tobj.id=_request(_step);
				}
				function _cancelTween(){
					if(tobj.id==null){return;}
					if(!window.requestAnimationFrame){clearTimeout(tobj.id);
					}else{window.cancelAnimationFrame(tobj.id);}
					tobj.id=null;
				}
				function _ease(t,b,c,d,type){
					switch(type){
						case "linear": case "mcsLinear":
							return c*t/d + b;
							break;
						case "mcsLinearOut":
							t/=d; t--; return c * Math.sqrt(1 - t*t) + b;
							break;
						case "easeInOutSmooth":
							t/=d/2;
							if(t<1) return c/2*t*t + b;
							t--;
							return -c/2 * (t*(t-2) - 1) + b;
							break;
						case "easeInOutStrong":
							t/=d/2;
							if(t<1) return c/2 * Math.pow( 2, 10 * (t - 1) ) + b;
							t--;
							return c/2 * ( -Math.pow( 2, -10 * t) + 2 ) + b;
							break;
						case "easeInOut": case "mcsEaseInOut":
							t/=d/2;
							if(t<1) return c/2*t*t*t + b;
							t-=2;
							return c/2*(t*t*t + 2) + b;
							break;
						case "easeOutSmooth":
							t/=d; t--;
							return -c * (t*t*t*t - 1) + b;
							break;
						case "easeOutStrong":
							return c * ( -Math.pow( 2, -10 * t/d ) + 1 ) + b;
							break;
						case "easeOut": case "mcsEaseOut": default:
							var ts=(t/=d)*t,tc=ts*t;
							return b+c*(0.499999999999997*tc*ts + -2.5*ts*ts + 5.5*tc + -6.5*ts + 4*t);
					}
				}
			},
			/* -------------------- */
			
			
			/* returns current time */
			_getTime=function(){
				if(window.performance && window.performance.now){
					return window.performance.now();
				}else{
					if(window.performance && window.performance.webkitNow){
						return window.performance.webkitNow();
					}else{
						if(Date.now){return Date.now();}else{return new Date().getTime();}
					}
				}
			},
			/* -------------------- */
			
			
			/* stops a tween */
			_stopTween=function(){
				var el=this;
				if(!el._mTween){el._mTween={top:{},left:{}};}
				var props=["top","left"];
				for(var i=0; i<props.length; i++){
					var prop=props[i];
					if(el._mTween[prop].id){
						if(!window.requestAnimationFrame){clearTimeout(el._mTween[prop].id);
						}else{window.cancelAnimationFrame(el._mTween[prop].id);}
						el._mTween[prop].id=null;
						el._mTween[prop].stop=1;
					}
				}
			},
			/* -------------------- */
			
			
			/* deletes a property (avoiding the exception thrown by IE) */
			_delete=function(c,m){
				try{delete c[m];}catch(e){c[m]=null;}
			},
			/* -------------------- */
			
			
			/* detects left mouse button */
			_mouseBtnLeft=function(e){
				return !(e.which && e.which!==1);
			},
			/* -------------------- */
			
			
			/* detects if pointer type event is touch */
			_pointerTouch=function(e){
				var t=e.originalEvent.pointerType;
				return !(t && t!=="touch" && t!==2);
			},
			/* -------------------- */
			
			
			/* checks if value is numeric */
			_isNumeric=function(val){
				return !isNaN(parseFloat(val)) && isFinite(val);
			},
			/* -------------------- */
			
			
			/* returns element position according to content */
			_childPos=function(el){
				var p=el.parents(".mCSB_container");
				return [el.offset().top-p.offset().top,el.offset().left-p.offset().left];
			},
			/* -------------------- */
			
			
			/* checks if browser tab is hidden/inactive via Page Visibility API */
			_isTabHidden=function(){
				var prop=_getHiddenProp();
				if(!prop) return false;
				return document[prop];
				function _getHiddenProp(){
					var pfx=["webkit","moz","ms","o"];
					if("hidden" in document) return "hidden"; //natively supported
					for(var i=0; i<pfx.length; i++){ //prefixed
					    if((pfx[i]+"Hidden") in document) 
					        return pfx[i]+"Hidden";
					}
					return null; //not supported
				}
			};
			/* -------------------- */
			
		
		
		
		
		/* 
		----------------------------------------
		PLUGIN SETUP 
		----------------------------------------
		*/
		
		/* plugin constructor functions */
		$.fn[pluginNS]=function(method){ /* usage: $(selector).mCustomScrollbar(); */
			if(methods[method]){
				return methods[method].apply(this,Array.prototype.slice.call(arguments,1));
			}else if(typeof method==="object" || !method){
				return methods.init.apply(this,arguments);
			}else{
				$.error("Method "+method+" does not exist");
			}
		};
		$[pluginNS]=function(method){ /* usage: $.mCustomScrollbar(); */
			if(methods[method]){
				return methods[method].apply(this,Array.prototype.slice.call(arguments,1));
			}else if(typeof method==="object" || !method){
				return methods.init.apply(this,arguments);
			}else{
				$.error("Method "+method+" does not exist");
			}
		};
		
		/* 
		allow setting plugin default options. 
		usage: $.mCustomScrollbar.defaults.scrollInertia=500; 
		to apply any changed default options on default selectors (below), use inside document ready fn 
		e.g.: $(document).ready(function(){ $.mCustomScrollbar.defaults.scrollInertia=500; });
		*/
		$[pluginNS].defaults=defaults;
		
		/* 
		add window object (window.mCustomScrollbar) 
		usage: if(window.mCustomScrollbar){console.log("custom scrollbar plugin loaded");}
		*/
		window[pluginNS]=true;
		
		$(window).bind("load",function(){
			
			$(defaultSelector)[pluginNS](); /* add scrollbars automatically on default selector */
			
			/* extend jQuery expressions */
			$.extend($.expr[":"],{
				/* checks if element is within scrollable viewport */
				mcsInView:$.expr[":"].mcsInView || function(el){
					var $el=$(el),content=$el.parents(".mCSB_container"),wrapper,cPos;
					if(!content.length){return;}
					wrapper=content.parent();
					cPos=[content[0].offsetTop,content[0].offsetLeft];
					return 	cPos[0]+_childPos($el)[0]>=0 && cPos[0]+_childPos($el)[0]<wrapper.height()-$el.outerHeight(false) && 
							cPos[1]+_childPos($el)[1]>=0 && cPos[1]+_childPos($el)[1]<wrapper.width()-$el.outerWidth(false);
				},
				/* checks if element or part of element is in view of scrollable viewport */
				mcsInSight:$.expr[":"].mcsInSight || function(el,i,m){
					var $el=$(el),elD,content=$el.parents(".mCSB_container"),wrapperView,pos,wrapperViewPct,
						pctVals=m[3]==="exact" ? [[1,0],[1,0]] : [[0.9,0.1],[0.6,0.4]];
					if(!content.length){return;}
					elD=[$el.outerHeight(false),$el.outerWidth(false)];
					pos=[content[0].offsetTop+_childPos($el)[0],content[0].offsetLeft+_childPos($el)[1]];
					wrapperView=[content.parent()[0].offsetHeight,content.parent()[0].offsetWidth];
					wrapperViewPct=[elD[0]<wrapperView[0] ? pctVals[0] : pctVals[1],elD[1]<wrapperView[1] ? pctVals[0] : pctVals[1]];
					return 	pos[0]-(wrapperView[0]*wrapperViewPct[0][0])<0 && pos[0]+elD[0]-(wrapperView[0]*wrapperViewPct[0][1])>=0 && 
							pos[1]-(wrapperView[1]*wrapperViewPct[1][0])<0 && pos[1]+elD[1]-(wrapperView[1]*wrapperViewPct[1][1])>=0;
				},
				/* checks if element is overflowed having visible scrollbar(s) */
				mcsOverflow:$.expr[":"].mcsOverflow || function(el){
					var d=$(el).data(pluginPfx);
					if(!d){return;}
					return d.overflowed[0] || d.overflowed[1];
				}
			});
		
		});
	
	}))}));

/***/ }),
/* 14 */
/***/ (function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {module.exports = __webpack_amd_options__;
	
	/* WEBPACK VAR INJECTION */}.call(exports, {}))

/***/ }),
/* 15 */
12,
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(17);
	
	$('.dotdotdot').dotdotdot({
	    wrap: 'word',
	    watch: true,
	    tolerance: 0
	});
	
	$('.info-cut').dotdotdot({
	    ellipsis: ''
	});
	$('.info-cut').trigger('isTruncated', function( isTruncated ) {
	    if ( isTruncated ) {
	        $(this).parent().append('<div class="dotdotdot-arr"><i class="icon icon_arrow-small-down"></div>');
	    }
	});
	
	// open dotdotdot
	
	$('.dotdotdot-arr').on('click', function(e) {
	    e.preventDefault();
	    var t = $(this),
	        outerBlock = t.parent(),
	        dotedBlock = outerBlock.find('.info-cut'),
	        hideBlock = outerBlock.find('.hideble-block');
	
	    t.add(dotedBlock).toggleClass('open');
	    hideBlock.fadeToggle();
	
	    dotedBlock.trigger('originalContent', function( content ) {
	        dotedBlock.html( content );
	    });
	});
	
	


/***/ }),
/* 17 */
/***/ (function(module, exports) {

	/*
	 *	jQuery dotdotdot 1.8.3
	 *
	 *	Copyright (c) Fred Heusschen
	 *	www.frebsite.nl
	 *
	 *	Plugin website:
	 *	dotdotdot.frebsite.nl
	 *
	 *	Licensed under the MIT license.
	 *	http://en.wikipedia.org/wiki/MIT_License
	 */
	
	(function( $, undef )
	{
		if ( $.fn.dotdotdot )
		{
			return;
		}
	
		$.fn.dotdotdot = function( o )
		{
			if ( this.length == 0 )
			{
				$.fn.dotdotdot.debug( 'No element found for "' + this.selector + '".' );
				return this;
			}
			if ( this.length > 1 )
			{
				return this.each(
					function()
					{
						$(this).dotdotdot( o );
					}
				);
			}
	
	
			var $dot = this;
			var orgContent	= $dot.contents();
	
			if ( $dot.data( 'dotdotdot' ) )
			{
				$dot.trigger( 'destroy.dot' );
			}
	
			$dot.data( 'dotdotdot-style', $dot.attr( 'style' ) || '' );
			$dot.css( 'word-wrap', 'break-word' );
			if ($dot.css( 'white-space' ) === 'nowrap')
			{
				$dot.css( 'white-space', 'normal' );
			}
	
			$dot.bind_events = function()
			{
				$dot.bind(
					'update.dot',
					function( e, c )
					{
						$dot.removeClass("is-truncated");
						e.preventDefault();
						e.stopPropagation();
	
						switch( typeof opts.height )
						{
							case 'number':
								opts.maxHeight = opts.height;
								break;
	
							case 'function':
								opts.maxHeight = opts.height.call( $dot[ 0 ] );
								break;
	
							default:
								opts.maxHeight = getTrueInnerHeight( $dot );
								break;
						}
	
						opts.maxHeight += opts.tolerance;
	
						if ( typeof c != 'undefined' )
						{
							if ( typeof c == 'string' || ('nodeType' in c && c.nodeType === 1) )
							{
						 		c = $('<div />').append( c ).contents();
							}
							if ( c instanceof $ )
							{
								orgContent = c;
							}
						}
	
						$inr = $dot.wrapInner( '<div class="dotdotdot" />' ).children();
						$inr.contents()
							.detach()
							.end()
							.append( orgContent.clone( true ) )
							.find( 'br' )
							.replaceWith( '  <br />  ' )
							.end()
							.css({
								'height'	: 'auto',
								'width'		: 'auto',
								'border'	: 'none',
								'padding'	: 0,
								'margin'	: 0
							});
	
						var after = false,
							trunc = false;
	
						if ( conf.afterElement )
						{
							after = conf.afterElement.clone( true );
						    after.show();
							conf.afterElement.detach();
						}
	
						if ( test( $inr, opts ) )
						{
							if ( opts.wrap == 'children' )
							{
								trunc = children( $inr, opts, after );
							}
							else
							{
								trunc = ellipsis( $inr, $dot, $inr, opts, after );
							}
						}
						$inr.replaceWith( $inr.contents() );
						$inr = null;
	
						if ( $.isFunction( opts.callback ) )
						{
							opts.callback.call( $dot[ 0 ], trunc, orgContent );
						}
	
						conf.isTruncated = trunc;
						return trunc;
					}
	
				).bind(
					'isTruncated.dot',
					function( e, fn )
					{
						e.preventDefault();
						e.stopPropagation();
	
						if ( typeof fn == 'function' )
						{
							fn.call( $dot[ 0 ], conf.isTruncated );
						}
						return conf.isTruncated;
					}
	
				).bind(
					'originalContent.dot',
					function( e, fn )
					{
						e.preventDefault();
						e.stopPropagation();
	
						if ( typeof fn == 'function' )
						{
							fn.call( $dot[ 0 ], orgContent );
						}
						return orgContent;
					}
	
				).bind(
					'destroy.dot',
					function( e )
					{
						e.preventDefault();
						e.stopPropagation();
	
						$dot.unwatch()
							.unbind_events()
							.contents()
							.detach()
							.end()
							.append( orgContent )
							.attr( 'style', $dot.data( 'dotdotdot-style' ) || '' )
							.removeClass( 'is-truncated' )
							.data( 'dotdotdot', false );
					}
				);
				return $dot;
			};	//	/bind_events
	
			$dot.unbind_events = function()
			{
				$dot.unbind('.dot');
				return $dot;
			};	//	/unbind_events
	
			$dot.watch = function()
			{
				$dot.unwatch();
				if ( opts.watch == 'window' )
				{
					var $window = $(window),
						_wWidth = $window.width(),
						_wHeight = $window.height();
	
					$window.bind(
						'resize.dot' + conf.dotId,
						function()
						{
							if ( _wWidth != $window.width() || _wHeight != $window.height() || !opts.windowResizeFix )
							{
								_wWidth = $window.width();
								_wHeight = $window.height();
	
								if ( watchInt )
								{
									clearInterval( watchInt );
								}
								watchInt = setTimeout(
									function()
									{
										$dot.trigger( 'update.dot' );
									}, 100
								);
							}
						}
					);
				}
				else
				{
					watchOrg = getSizes( $dot );
					watchInt = setInterval(
						function()
						{
							if ( $dot.is( ':visible' ) )
							{
								var watchNew = getSizes( $dot );
								if ( watchOrg.width  != watchNew.width ||
									 watchOrg.height != watchNew.height )
								{
									$dot.trigger( 'update.dot' );
									watchOrg = watchNew;
								}
							}
						}, 500
					);
				}
				return $dot;
			};
			$dot.unwatch = function()
			{
				$(window).unbind( 'resize.dot' + conf.dotId );
				if ( watchInt )
				{
					clearInterval( watchInt );
				}
				return $dot;
			};
	
			var	opts 		= $.extend( true, {}, $.fn.dotdotdot.defaults, o ),
				conf		= {},
				watchOrg	= {},
				watchInt	= null,
				$inr		= null;
	
	
			if ( !( opts.lastCharacter.remove instanceof Array ) )
			{
				opts.lastCharacter.remove = $.fn.dotdotdot.defaultArrays.lastCharacter.remove;
			}
			if ( !( opts.lastCharacter.noEllipsis instanceof Array ) )
			{
				opts.lastCharacter.noEllipsis = $.fn.dotdotdot.defaultArrays.lastCharacter.noEllipsis;
			}
	
	
			conf.afterElement	= getElement( opts.after, $dot );
			conf.isTruncated	= false;
			conf.dotId			= dotId++;
	
	
			$dot.data( 'dotdotdot', true )
				.bind_events()
				.trigger( 'update.dot' );
	
			if ( opts.watch )
			{
				$dot.watch();
			}
	
			return $dot;
		};
	
	
		//	public
		$.fn.dotdotdot.defaults = {
			'ellipsis'			: '... ',
			'wrap'				: 'word',
			'fallbackToLetter'	: true,
			'lastCharacter'		: {},
			'tolerance'			: 0,
			'callback'			: null,
			'after'				: null,
			'height'			: null,
			'watch'				: false,
			'windowResizeFix'	: true
		};
		$.fn.dotdotdot.defaultArrays = {
			'lastCharacter'		: {
				'remove'			: [ ' ', '\u3000', ',', ';', '.', '!', '?' ],
				'noEllipsis'		: []
			}
		};
		$.fn.dotdotdot.debug = function( msg ) {};
	
	
		//	private
		var dotId = 1;
	
		function children( $elem, o, after )
		{
			var $elements 	= $elem.children(),
				isTruncated	= false;
	
			$elem.empty();
	
			for ( var a = 0, l = $elements.length; a < l; a++ )
			{
				var $e = $elements.eq( a );
				$elem.append( $e );
				if ( after )
				{
					$elem.append( after );
				}
				if ( test( $elem, o ) )
				{
					$e.remove();
					isTruncated = true;
					break;
				}
				else
				{
					if ( after )
					{
						after.detach();
					}
				}
			}
			return isTruncated;
		}
		function ellipsis( $elem, $d, $i, o, after )
		{
			var isTruncated	= false;
	
			//	Don't put the ellipsis directly inside these elements
			var notx = 'a, table, thead, tbody, tfoot, tr, col, colgroup, object, embed, param, ol, ul, dl, blockquote, select, optgroup, option, textarea, script, style';
	
			//	Don't remove these elements even if they are after the ellipsis
			var noty = 'script, .dotdotdot-keep';
	
			$elem
				.contents()
				.detach()
				.each(
					function()
					{
	
						var e	= this,
							$e	= $(e);
	
						if ( typeof e == 'undefined' )
						{
							return true;
						}
						else if ( $e.is( noty ) )
						{
							$elem.append( $e );
						}
						else if ( isTruncated )
						{
							return true;
						}
						else
						{
							$elem.append( $e );
							if ( after && !$e.is( o.after ) && !$e.find( o.after ).length  )
							{
								$elem[ $elem.is( notx ) ? 'after' : 'append' ]( after );
							}
							if ( test( $i, o ) )
							{
								if ( e.nodeType == 3 ) // node is TEXT
								{
									isTruncated = ellipsisElement( $e, $d, $i, o, after );
								}
								else
								{
									isTruncated = ellipsis( $e, $d, $i, o, after );
								}
							}
	
							if ( !isTruncated )
							{
								if ( after )
								{
									after.detach();
								}
							}
						}
					}
				);
			$d.addClass("is-truncated");
			return isTruncated;
		}
		function ellipsisElement( $e, $d, $i, o, after )
		{
			var e = $e[ 0 ];
	
			if ( !e )
			{
				return false;
			}
	
			var txt			= getTextContent( e ),
				space		= ( txt.indexOf(' ') !== -1 ) ? ' ' : '\u3000',
				separator	= ( o.wrap == 'letter' ) ? '' : space,
				textArr		= txt.split( separator ),
				position 	= -1,
				midPos		= -1,
				startPos	= 0,
				endPos		= textArr.length - 1;
	
	
			//	Only one word
			if ( o.fallbackToLetter && startPos == 0 && endPos == 0 )
			{
				separator	= '';
				textArr		= txt.split( separator );
				endPos		= textArr.length - 1;
			}
	
			while ( startPos <= endPos && !( startPos == 0 && endPos == 0 ) )
			{
				var m = Math.floor( ( startPos + endPos ) / 2 );
				if ( m == midPos )
				{
					break;
				}
				midPos = m;
	
				setTextContent( e, textArr.slice( 0, midPos + 1 ).join( separator ) + o.ellipsis );
				$i.children()
					.each(
						function()
						{
							$(this).toggle().toggle();
						}
					);
	
				if ( !test( $i, o ) )
				{
					position = midPos;
					startPos = midPos;
				}
				else
				{
					endPos = midPos;
	
					//	Fallback to letter
					if (o.fallbackToLetter && startPos == 0 && endPos == 0 )
					{
						separator	= '';
						textArr		= textArr[ 0 ].split( separator );
						position	= -1;
						midPos		= -1;
						startPos	= 0;
						endPos		= textArr.length - 1;
					}
				}
			}
	
			if ( position != -1 && !( textArr.length == 1 && textArr[ 0 ].length == 0 ) )
			{
				txt = addEllipsis( textArr.slice( 0, position + 1 ).join( separator ), o );
				setTextContent( e, txt );
			}
			else
			{
				var $w = $e.parent();
				$e.detach();
	
				var afterLength = ( after && after.closest($w).length ) ? after.length : 0;
	
				if ( $w.contents().length > afterLength )
				{
					e = findLastTextNode( $w.contents().eq( -1 - afterLength ), $d );
				}
				else
				{
					e = findLastTextNode( $w, $d, true );
					if ( !afterLength )
					{
						$w.detach();
					}
				}
				if ( e )
				{
					txt = addEllipsis( getTextContent( e ), o );
					setTextContent( e, txt );
					if ( afterLength && after )
					{
						var $parent = after.parent();
	
						$(e).parent().append( after );
	
						if ( !$.trim( $parent.html() ) )
						{
							$parent.remove();
						}
					}
				}
			}
	
			return true;
		}
		function test( $i, o )
		{
			return $i.innerHeight() > o.maxHeight;
		}
		function addEllipsis( txt, o )
		{
			while( $.inArray( txt.slice( -1 ), o.lastCharacter.remove ) > -1 )
			{
				txt = txt.slice( 0, -1 );
			}
			if ( $.inArray( txt.slice( -1 ), o.lastCharacter.noEllipsis ) < 0 )
			{
				txt += o.ellipsis;
			}
			return txt;
		}
		function getSizes( $d )
		{
			return {
				'width'	: $d.innerWidth(),
				'height': $d.innerHeight()
			};
		}
		function setTextContent( e, content )
		{
			if ( e.innerText )
			{
				e.innerText = content;
			}
			else if ( e.nodeValue )
			{
				e.nodeValue = content;
			}
			else if (e.textContent)
			{
				e.textContent = content;
			}
	
		}
		function getTextContent( e )
		{
			if ( e.innerText )
			{
				return e.innerText;
			}
			else if ( e.nodeValue )
			{
				return e.nodeValue;
			}
			else if ( e.textContent )
			{
				return e.textContent;
			}
			else
			{
				return "";
			}
		}
		function getPrevNode( n )
		{
			do
			{
				n = n.previousSibling;
			}
			while ( n && n.nodeType !== 1 && n.nodeType !== 3 );
	
			return n;
		}
		function findLastTextNode( $el, $top, excludeCurrent )
		{
			var e = $el && $el[ 0 ], p;
			if ( e )
			{
				if ( !excludeCurrent )
				{
					if ( e.nodeType === 3 )
					{
						return e;
					}
					if ( $.trim( $el.text() ) )
					{
						return findLastTextNode( $el.contents().last(), $top );
					}
				}
				p = getPrevNode( e );
				while ( !p )
				{
					$el = $el.parent();
					if ( $el.is( $top ) || !$el.length )
					{
						return false;
					}
					p = getPrevNode( $el[0] );
				}
				if ( p )
				{
					return findLastTextNode( $(p), $top );
				}
			}
			return false;
		}
		function getElement( e, $i )
		{
			if ( !e )
			{
				return false;
			}
			if ( typeof e === 'string' )
			{
				e = $(e, $i);
				return ( e.length )
					? e
					: false;
			}
			return !e.jquery
				? false
				: e;
		}
		function getTrueInnerHeight( $el )
		{
			var h = $el.innerHeight(),
				a = [ 'paddingTop', 'paddingBottom' ];
	
			for ( var z = 0, l = a.length; z < l; z++ )
			{
				var m = parseInt( $el.css( a[ z ] ), 10 );
				if ( isNaN( m ) )
				{
					m = 0;
				}
				h -= m;
			}
			return h;
		}
	
	
		//	override jQuery.html
		var _orgHtml = $.fn.html;
		$.fn.html = function( str )
		{
			if ( str != undef && !$.isFunction( str ) && this.data( 'dotdotdot' ) )
			{
				return this.trigger( 'update', [ str ] );
			}
			return _orgHtml.apply( this, arguments );
		};
	
	
		//	override jQuery.text
		var _orgText = $.fn.text;
		$.fn.text = function( str )
		{
			if ( str != undef && !$.isFunction( str ) && this.data( 'dotdotdot' ) )
			{
				str = $( '<div />' ).text( str ).html();
				return this.trigger( 'update', [ str ] );
			}
			return _orgText.apply( this, arguments );
		};
	
	
	})( jQuery );
	
	/*
	
	## Automatic parsing for CSS classes
	Contributed by [Ramil Valitov](https://github.com/rvalitov)
	
	### The idea
	You can add one or several CSS classes to HTML elements to automatically invoke "jQuery.dotdotdot functionality" and some extra features. It allows to use jQuery.dotdotdot only by adding appropriate CSS classes without JS programming.
	
	### Available classes and their description
	* dot-ellipsis - automatically invoke jQuery.dotdotdot to this element. This class must be included if you plan to use other classes below.
	* dot-resize-update - automatically update if window resize event occurs. It's equivalent to option `watch:'window'`.
	* dot-timer-update - automatically update if window resize event occurs. It's equivalent to option `watch:true`.
	* dot-load-update - automatically update after the window has beem completely rendered. Can be useful if your content is generated dynamically using using JS and, hence, jQuery.dotdotdot can't correctly detect the height of the element before it's rendered completely.
	* dot-height-XXX - available height of content area in pixels, where XXX is a number, e.g. can be `dot-height-35` if you want to set maximum height for 35 pixels. It's equivalent to option `height:'XXX'`.
	
	### Usage examples
	*Adding jQuery.dotdotdot to element*
	    
		<div class="dot-ellipsis">
		<p>Lorem Ipsum is simply dummy text.</p>
		</div>
		
	*Adding jQuery.dotdotdot to element with update on window resize*
	    
		<div class="dot-ellipsis dot-resize-update">
		<p>Lorem Ipsum is simply dummy text.</p>
		</div>
		
	*Adding jQuery.dotdotdot to element with predefined height of 50px*
	    
		<div class="dot-ellipsis dot-height-50">
		<p>Lorem Ipsum is simply dummy text.</p>
		</div>
		
	*/
	
	jQuery(document).ready(function($) {
		//We only invoke jQuery.dotdotdot on elements that have dot-ellipsis class
		$(".dot-ellipsis").each(function(){
			//Checking if update on window resize required
			var watch_window=$(this).hasClass("dot-resize-update");
			
			//Checking if update on timer required
			var watch_timer=$(this).hasClass("dot-timer-update");
			
			//Checking if height set
			var height=0;		
			var classList = $(this).attr('class').split(/\s+/);
			$.each(classList, function(index, item) {
				var matchResult = item.match(/^dot-height-(\d+)$/);
				if(matchResult !== null)
					height = Number(matchResult[1]);
			});
			
			//Invoking jQuery.dotdotdot
			var x = new Object();
			if (watch_timer)
				x.watch=true;
			if (watch_window)
				x.watch='window';
			if (height>0)
				x.height=height;
			$(this).dotdotdot(x);
		});
			
	});
	
	//Updating elements (if any) on window.load event
	jQuery(window).on('load', function(){
		jQuery(".dot-ellipsis.dot-load-update").trigger("update.dot");
	});


/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(19);
	
	$("._card-click").flip({
	    front: '.flip-card__front',
	    back: '.flip-card__back',
	    speed: 500
	
	});
	
	$("._card-hover").flip({
	    front: '.flip-card__front',
	    back: '.flip-card__back',
	    trigger: 'hover',
	    speed: 500
	});

/***/ }),
/* 19 */
/***/ (function(module, exports) {

	/*! flip - v1.1.1 - 2016-05-25
	* https://github.com/nnattawat/flip
	* Copyright (c) 2016 Nattawat Nonsung; Licensed MIT */
	(function( $ ) {
	  /*
	   * Private attributes and method
	   */
	
	  // Function from David Walsh: http://davidwalsh.name/css-animation-callback licensed with http://opensource.org/licenses/MIT
	  var whichTransitionEvent = function() {
	    var t, el = document.createElement("fakeelement"),
	    transitions = {
	      "transition"      : "transitionend",
	      "OTransition"     : "oTransitionEnd",
	      "MozTransition"   : "transitionend",
	      "WebkitTransition": "webkitTransitionEnd"
	    };
	
	    for (t in transitions) {
	      if (el.style[t] !== undefined) {
	        return transitions[t];
	      }
	    }
	  };
	
	  /*
	   * Model declaration
	   */
	  var Flip = function($el, options, callback) {
	    // Define default setting
	    this.setting = {
	      axis: "y",
	      reverse: false,
	      trigger: "click",
	      speed: 500,
	      forceHeight: false,
	      forceWidth: false,
	      autoSize: true,
	      front: '.front',
	      back: '.back'
	    };
	
	    this.setting = $.extend(this.setting, options);
	
	    if (typeof options.axis === 'string' && (options.axis.toLowerCase() === 'x' || options.axis.toLowerCase() === 'y')) {
	      this.setting.axis = options.axis.toLowerCase();
	    }
	
	    if (typeof options.reverse === "boolean") {
	      this.setting.reverse = options.reverse;
	    }
	
	    if (typeof options.trigger === 'string') {
	      this.setting.trigger = options.trigger.toLowerCase();
	    }
	
	    var speed = parseInt(options.speed);
	    if (!isNaN(speed)) {
	      this.setting.speed = speed;
	    }
	
	    if (typeof options.forceHeight === "boolean") {
	      this.setting.forceHeight = options.forceHeight;
	    }
	
	    if (typeof options.forceWidth === "boolean") {
	      this.setting.forceWidth = options.forceWidth;
	    }
	
	    if (typeof options.autoSize === "boolean") {
	      this.setting.autoSize = options.autoSize;
	    }
	
	    if (typeof options.front === 'string' || options.front instanceof $) {
	      this.setting.front = options.front;
	    }
	
	    if (typeof options.back === 'string' || options.back instanceof $) {
	      this.setting.back = options.back;
	    }
	
	    // Other attributes
	    this.element = $el;
	    this.frontElement = this.getFrontElement();
	    this.backElement = this.getBackElement();
	    this.isFlipped = false;
	
	    this.init(callback);
	  };
	
	  /*
	   * Public methods
	   */
	  $.extend(Flip.prototype, {
	
	    flipDone: function(callback) {
	      var self = this;
	      // Providing a nicely wrapped up callback because transform is essentially async
	      self.element.one(whichTransitionEvent(), function() {
	        self.element.trigger('flip:done');
	        if (typeof callback === 'function') {
	          callback.call(self.element);
	        }
	      });
	    },
	
	    flip: function(callback) {
	      if (this.isFlipped) {
	        return;
	      }
	
	      this.isFlipped = true;
	
	      var rotateAxis = "rotate" + this.setting.axis;
	      this.frontElement.css({
	        transform: rotateAxis + (this.setting.reverse ? "(-180deg)" : "(180deg)"),
	        "z-index": "0"
	      });
	
	      this.backElement.css({
	        transform: rotateAxis + "(0deg)",
	        "z-index": "1"
	      });
	      this.flipDone(callback);
	    },
	
	    unflip: function(callback) {
	      if (!this.isFlipped) {
	        return;
	      }
	
	      this.isFlipped = false;
	
	      var rotateAxis = "rotate" + this.setting.axis;
	      this.frontElement.css({
	        transform: rotateAxis + "(0deg)",
	        "z-index": "1"
	      });
	
	      this.backElement.css({
	        transform: rotateAxis + (this.setting.reverse ? "(180deg)" : "(-180deg)"),
	        "z-index": "0"
	      });
	      this.flipDone(callback);
	    },
	
	    getFrontElement: function() {
	      if (this.setting.front instanceof $) {
	        return this.setting.front;
	      } else {
	        return this.element.find(this.setting.front);
	      }
	    },
	
	    getBackElement: function() {
	      if (this.setting.back instanceof $) {
	        return this.setting.back;
	      } else {
	        return this.element.find(this.setting.back);
	      }
	    },
	
	    init: function(callback) {
	      var self = this;
	
	      var faces = self.frontElement.add(self.backElement);
	      var rotateAxis = "rotate" + self.setting.axis;
	      var perspective = self.element["outer" + (rotateAxis === "rotatex" ? "Height" : "Width")]() * 2;
	      var elementCss = {
	        'perspective': perspective,
	        'position': 'relative'
	      };
	      var backElementCss = {
	        "transform": rotateAxis + "(" + (self.setting.reverse ? "180deg" : "-180deg") + ")",
	        "z-index": "0"
	      };
	      var faceElementCss = {
	        "backface-visibility": "hidden",
	        "transform-style": "preserve-3d",
	        "position": "absolute",
	        "z-index": "1"
	      };
	
	      if (self.setting.forceHeight) {
	        faces.outerHeight(self.element.height());
	      } else if (self.setting.autoSize) {
	        faceElementCss.height = '100%';
	      }
	
	      if (self.setting.forceWidth) {
	        faces.outerWidth(self.element.width());
	      } else if (self.setting.autoSize) {
	        faceElementCss.width = '100%';
	      }
	
	      // Back face always visible on Chrome #39
	      if ((window.chrome || (window.Intl && Intl.v8BreakIterator)) && 'CSS' in window) {
	        //Blink Engine, add preserve-3d to self.element
	        elementCss["-webkit-transform-style"] = "preserve-3d";
	      }
	
	      self.element.css(elementCss);
	      self.backElement.css(backElementCss);
	      faces.css(faceElementCss).find('*').css({
	        "backface-visibility": "hidden"
	      });
	
	      // #39
	      // not forcing width/height may cause an initial flip to show up on
	      // page load when we apply the style to reverse the backface...
	      // To prevent self we first apply the basic styles and then give the
	      // browser a moment to apply them. Only afterwards do we add the transition.
	      setTimeout(function() {
	        // By now the browser should have applied the styles, so the transition
	        // will only affect subsequent flips.
	        var speedInSec = self.setting.speed / 1000 || 0.5;
	        faces.css({
	          "transition": "all " + speedInSec + "s ease-out"
	        });
	
	        // This allows flip to be called for setup with only a callback (default settings)
	        if (typeof callback === 'function') {
	          callback.call(self.element);
	        }
	
	        // While this used to app with a setTimeout of zero, at some point that became
	        // unstable and the initial flip returned. The reason for this is unknown but we
	        // will temporarily use a short delay of 20 to mitigate this issue. 
	      }, 20);
	
	      self.attachEvents();
	    },
	
	    clickHandler: function(event) {
	      if (!event) { event = window.event; }
	      if (this.element.find($(event.target).closest('button, a, input[type="submit"]')).length) {
	        return;
	      }
	
	      if (this.isFlipped) {
	        this.unflip();
	      } else {
	        this.flip();
	      }
	    },
	
	    hoverHandler: function() {
	      var self = this;
	      self.element.off('mouseleave.flip');
	
	      self.flip();
	
	      setTimeout(function() {
	        self.element.on('mouseleave.flip', $.proxy(self.unflip, self));
	        if (!self.element.is(":hover")) {
	          self.unflip();
	        }
	      }, (self.setting.speed + 150));
	    },
	
	    attachEvents: function() {
	      var self = this;
	      if (self.setting.trigger === "click") {
	        self.element.on($.fn.tap ? "tap.flip" : "click.flip", $.proxy(self.clickHandler, self));
	      } else if (self.setting.trigger === "hover") {
	        self.element.on('mouseenter.flip', $.proxy(self.hoverHandler, self));
	        self.element.on('mouseleave.flip', $.proxy(self.unflip, self));
	      }
	    },
	
	    flipChanged: function(callback) {
	      this.element.trigger('flip:change');
	      if (typeof callback === 'function') {
	        callback.call(this.element);
	      }
	    },
	
	    changeSettings: function(options, callback) {
	      var self = this;
	      var changeNeeded = false;
	
	      if (options.axis !== undefined && self.setting.axis !== options.axis.toLowerCase()) {
	        self.setting.axis = options.axis.toLowerCase();
	        changeNeeded = true;
	      }
	
	      if (options.reverse !== undefined && self.setting.reverse !== options.reverse) {
	        self.setting.reverse = options.reverse;
	        changeNeeded = true;
	      }
	
	      if (changeNeeded) {
	        var faces = self.frontElement.add(self.backElement);
	        var savedTrans = faces.css(["transition-property", "transition-timing-function", "transition-duration", "transition-delay"]);
	
	        faces.css({
	          transition: "none"
	        });
	
	        // This sets up the first flip in the new direction automatically
	        var rotateAxis = "rotate" + self.setting.axis;
	
	        if (self.isFlipped) {
	          self.frontElement.css({
	            transform: rotateAxis + (self.setting.reverse ? "(-180deg)" : "(180deg)"),
	            "z-index": "0"
	          });
	        } else {
	          self.backElement.css({
	            transform: rotateAxis + (self.setting.reverse ? "(180deg)" : "(-180deg)"),
	            "z-index": "0"
	          });
	        }
	        // Providing a nicely wrapped up callback because transform is essentially async
	        setTimeout(function() {
	          faces.css(savedTrans);
	          self.flipChanged(callback);
	        }, 0);
	      } else {
	        // If we didnt have to set the axis we can just call back.
	        self.flipChanged(callback);
	      }
	    }
	
	  });
	
	  /*
	   * jQuery collection methods
	   */
	  $.fn.flip = function (options, callback) {
	    if (typeof options === 'function') {
	      callback = options;
	    }
	
	    if (typeof options === "string" || typeof options === "boolean") {
	      this.each(function() {
	        var flip = $(this).data('flip-model');
	
	        if (options === "toggle") {
	          options = !flip.isFlipped;
	        }
	
	        if (options) {
	          flip.flip(callback);
	        } else {
	          flip.unflip(callback);
	        }
	      });
	    } else {
	      this.each(function() {
	        if ($(this).data('flip-model')) { // The element has been initiated, all we have to do is change applicable settings
	          var flip = $(this).data('flip-model');
	
	          if (options && (options.axis !== undefined || options.reverse !== undefined)) {
	            flip.changeSettings(options, callback);
	          }
	        } else { // Init
	          $(this).data('flip-model', new Flip($(this), (options || {}), callback));
	        }
	      });
	    }
	
	    return this;
	  };
	
	}( jQuery ));


/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(21);
	
	// var mask_phone = function () {
	//         $('._phone-mask').inputmask('+9(999) 999-99-99', {
	//             placeholder: '_',
	//             showMaskOnHover: false
	//         });
	//     };
	
	$('.mask_phone').inputmask("+7(999)999-99-99", {
	    placeholder: '_',
	    showMaskOnHover: false
	});

/***/ }),
/* 21 */
/***/ (function(module, exports) {

	/**
	* @license Input Mask plugin for jquery
	* http://github.com/RobinHerbots/jquery.inputmask
	* Copyright (c) 2010 - 2013 Robin Herbots
	* Licensed under the MIT license (http://www.opensource.org/licenses/mit-license.php)
	* Version: 0.0.0
	*/
	
	(function ($) {
	    if ($.fn.inputmask == undefined) {
	        $.inputmask = {
	            //options default
	            defaults: {
	                placeholder: "_",
	                optionalmarker: {
	                    start: "[",
	                    end: "]"
	                },
	                escapeChar: "\\",
	                mask: null,
	                oncomplete: $.noop, //executes when the mask is complete
	                onincomplete: $.noop, //executes when the mask is incomplete and focus is lost
	                oncleared: $.noop, //executes when the mask is cleared
	                repeat: 0, //repetitions of the mask
	                greedy: true, //true: allocated buffer for the mask and repetitions - false: allocate only if needed
	                autoUnmask: false, //automatically unmask when retrieving the value with $.fn.val or value if the browser supports __lookupGetter__ or getOwnPropertyDescriptor
	                clearMaskOnLostFocus: true,
	                insertMode: true, //insert the input or overwrite the input
	                clearIncomplete: false, //clear the incomplete input on blur
	                aliases: {}, //aliases definitions => see jquery.inputmask.extensions.js
	                onKeyUp: $.noop, //override to implement autocomplete on certain keys for example
	                onKeyDown: $.noop, //override to implement autocomplete on certain keys for example
	                showMaskOnFocus: true, //show the mask-placeholder when the input has focus
	                showMaskOnHover: true, //show the mask-placeholder when hovering the empty input
	                onKeyValidation: $.noop, //executes on every key-press with the result of isValid
	                skipOptionalPartCharacter: " ", //a character which can be used to skip an optional part of a mask
	                //numeric basic properties
	                numericInput: false, //numericInput input direction style (input shifts to the left while holding the caret position)
	                radixPoint: "", //".", // | ","
	                //numeric basic properties
	                definitions: {
	                    '9': {
	                        validator: "[0-9]",
	                        cardinality: 1
	                    },
	                    'a': {
	                        validator: "[A-Za-z\u0410-\u044F\u0401\u0451]",
	                        cardinality: 1
	                    },
	                    '*': {
	                        validator: "[A-Za-z\u0410-\u044F\u0401\u04510-9]",
	                        cardinality: 1
	                    }
	                },
	                keyCode: {
	                    ALT: 18, BACKSPACE: 8, CAPS_LOCK: 20, COMMA: 188, COMMAND: 91, COMMAND_LEFT: 91, COMMAND_RIGHT: 93, CONTROL: 17, DELETE: 46, DOWN: 40, END: 35, ENTER: 13, ESCAPE: 27, HOME: 36, INSERT: 45, LEFT: 37, MENU: 93, NUMPAD_ADD: 107, NUMPAD_DECIMAL: 110, NUMPAD_DIVIDE: 111, NUMPAD_ENTER: 108,
	                    NUMPAD_MULTIPLY: 106, NUMPAD_SUBTRACT: 109, PAGE_DOWN: 34, PAGE_UP: 33, PERIOD: 190, RIGHT: 39, SHIFT: 16, SPACE: 32, TAB: 9, UP: 38, WINDOWS: 91
	                },
	                //specify keycodes which should not be considered in the keypress event, otherwise the preventDefault will stop their default behavior especially in FF
	                ignorables: [9, 13, 19, 27, 33, 34, 35, 36, 37, 38, 39, 40, 45, 46, 93, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123],
	                getMaskLength: function (buffer, greedy, repeat, currentBuffer, opts) {
	                    var calculatedLength = buffer.length;
	                    if (!greedy && repeat > 1) {
	                        calculatedLength += (buffer.length * (repeat - 1));
	                    }
	                    return calculatedLength;
	                }
	            },
	            val: $.fn.val, //store the original jquery val function
	            escapeRegex: function (str) {
	                var specials = ['/', '.', '*', '+', '?', '|', '(', ')', '[', ']', '{', '}', '\\'];
	                return str.replace(new RegExp('(\\' + specials.join('|\\') + ')', 'gim'), '\\$1');
	            }
	        };
	
	        $.fn.inputmask = function (fn, options) {
	            var opts = $.extend(true, {}, $.inputmask.defaults, options);
	            var pasteEvent = isInputEventSupported('paste') ? 'paste' : 'input';
	
	            var iphone = navigator.userAgent.match(/iphone/i) != null;
	            var android = navigator.userAgent.match(/android.*safari.*/i) != null,
		    	android534;
	            if (android) {
	                var browser = navigator.userAgent.match(/safari.*/i);
	                var version = parseInt(new RegExp(/[0-9]+/).exec(browser));
	                android = (version <= 533);
	                android534 = (533 < version <= 534);
	            }
	            var caretposCorrection = null;
	            var masksets,
		        activeMasksetIndex = 0;
	
	            if (typeof fn == "string") {
	                switch (fn) {
	                    case "mask":
	                        //resolve possible aliases given by options
	                        resolveAlias(opts.alias, options);
	                        masksets = generateMaskSets();
	
	                        return this.each(function () {
	                            mask(this);
	                        });
	                        break;
	                    case "unmaskedvalue":
	                        masksets = this.data('inputmask')['masksets'];
	                        activeMasksetIndex = this.data('inputmask')['activeMasksetIndex'];
	                        opts.definitions = this.data('inputmask')['definitions'];
	                        return unmaskedvalue(this);
	                        break;
	                    case "remove":
	                        return this.each(function () {
	                            var $input = $(this), input = this;
	                            setTimeout(function () {
	                                if ($input.data('inputmask')) {
	                                    masksets = $input.data('inputmask')['masksets'];
	                                    activeMasksetIndex = $input.data('inputmask')['activeMasksetIndex'];
	                                    opts.definitions = $input.data('inputmask')['definitions'];
	                                    //writeout the unmaskedvalue
	                                    input._valueSet(unmaskedvalue($input, true));
	                                    //clear data
	                                    $input.removeData('inputmask');
	                                    //unbind all events
	                                    $input.unbind(".inputmask");
	                                    $input.removeClass('focus.inputmask');
	                                    //restore the value property
	                                    var valueProperty;
	                                    if (Object.getOwnPropertyDescriptor)
	                                        valueProperty = Object.getOwnPropertyDescriptor(input, "value");
	                                    if (valueProperty && valueProperty.get) {
	                                        if (input._valueGet) {
	                                            Object.defineProperty(input, "value", {
	                                                get: input._valueGet,
	                                                set: input._valueSet
	                                            });
	                                        }
	                                    } else if (document.__lookupGetter__ && input.__lookupGetter__("value")) {
	                                        if (input._valueGet) {
	                                            input.__defineGetter__("value", input._valueGet);
	                                            input.__defineSetter__("value", input._valueSet);
	                                        }
	                                    }
	                                    delete input._valueGet;
	                                    delete input._valueSet;
	                                }
	                            }, 0);
	                        });
	                        break;
	                    case "getemptymask": //return the default (empty) mask value, usefull for setting the default value in validation
	                        if (this.data('inputmask')) {
	                            masksets = this.data('inputmask')['masksets'];
	                            activeMasksetIndex = this.data('inputmask')['activeMasksetIndex'];
	                            return masksets[activeMasksetIndex]['_buffer'].join('');
	                        }
	                        else return "";
	                    case "hasMaskedValue": //check wheter the returned value is masked or not; currently only works reliable when using jquery.val fn to retrieve the value 
	                        return this.data('inputmask') ? !this.data('inputmask')['autoUnmask'] : false;
	                    case "isComplete":
	                        masksets = this.data('inputmask')['masksets'];
	                        activeMasksetIndex = this.data('inputmask')['activeMasksetIndex'];
	                        opts.definitions = this.data('inputmask')['definitions'];
	                        return isComplete(this[0].split(''));
	                    default:
	                        //check if the fn is an alias
	                        if (!resolveAlias(fn, options)) {
	                            //maybe fn is a mask so we try
	                            //set mask
	                            opts.mask = fn;
	                        }
	                        masksets = generateMaskSets();
	
	                        return this.each(function () {
	                            mask(this);
	                        });
	
	                        break;
	                }
	            } else if (typeof fn == "object") {
	                opts = $.extend(true, {}, $.inputmask.defaults, fn);
	
	                resolveAlias(opts.alias, fn); //resolve aliases
	                masksets = generateMaskSets();
	
	                return this.each(function () {
	                    mask(this);
	                });
	            } else if (fn == undefined) {
	                //look for data-inputmask atribute - the attribute should only contain optipns
	                return this.each(function () {
	                    var attrOptions = $(this).attr("data-inputmask");
	                    if (attrOptions && attrOptions != "") {
	                        try {
	                            attrOptions = attrOptions.replace(new RegExp("'", "g"), '"');
	                            var options = $.parseJSON("{" + attrOptions + "}");
	                            opts = $.extend(true, {}, $.inputmask.defaults, options);
	                            resolveAlias(opts.alias, options);
	                            opts.alias = undefined;
	                            $(this).inputmask(opts);
	                        } catch (ex) { } //need a more relax parseJSON
	                    }
	                });
	            }
	
	            //helper functions
	            function isInputEventSupported(eventName) {
	                var el = document.createElement('input'),
			        eventName = 'on' + eventName,
			        isSupported = (eventName in el);
	                if (!isSupported) {
	                    el.setAttribute(eventName, 'return;');
	                    isSupported = typeof el[eventName] == 'function';
	                }
	                el = null;
	                return isSupported;
	            }
	
	            function resolveAlias(aliasStr, options) {
	                var aliasDefinition = opts.aliases[aliasStr];
	                if (aliasDefinition) {
	                    if (aliasDefinition.alias) resolveAlias(aliasDefinition.alias); //alias is another alias
	                    $.extend(true, opts, aliasDefinition);  //merge alias definition in the options
	                    $.extend(true, opts, options);  //reapply extra given options
	                    return true;
	                }
	                return false;
	            }
	
	            function getMaskTemplate(mask) {
	                var escaped = false, outCount = 0, greedy = opts.greedy, repeat = opts.repeat;
	                if (mask.length == 1 && greedy == false) { opts.placeholder = ""; } //hide placeholder with single non-greedy mask
	                var singleMask = $.map(mask.split(""), function (element, index) {
	                    var outElem = [];
	                    if (element == opts.escapeChar) {
	                        escaped = true;
	                    }
	                    else if ((element != opts.optionalmarker.start && element != opts.optionalmarker.end) || escaped) {
	                        var maskdef = opts.definitions[element];
	                        if (maskdef && !escaped) {
	                            for (var i = 0; i < maskdef.cardinality; i++) {
	                                outElem.push(getPlaceHolder(outCount + i));
	                            }
	                        } else {
	                            outElem.push(element);
	                            escaped = false;
	                        }
	                        outCount += outElem.length;
	                        return outElem;
	                    }
	                });
	
	                //allocate repetitions
	                var repeatedMask = singleMask.slice();
	                for (var i = 1; i < repeat && greedy; i++) {
	                    repeatedMask = repeatedMask.concat(singleMask.slice());
	                }
	
	                return { "mask": repeatedMask, "repeat": repeat, "greedy": greedy };
	            }
	
	            //test definition => {fn: RegExp/function, cardinality: int, optionality: bool, newBlockMarker: bool, offset: int, casing: null/upper/lower, def: definitionSymbol}
	            function getTestingChain(mask) {
	                var isOptional = false, escaped = false;
	                var newBlockMarker = false; //indicates wheter the begin/ending of a block should be indicated
	
	                return $.map(mask.split(""), function (element, index) {
	                    var outElem = [];
	
	                    if (element == opts.escapeChar) {
	                        escaped = true;
	                    } else if (element == opts.optionalmarker.start && !escaped) {
	                        isOptional = true;
	                        newBlockMarker = true;
	                    }
	                    else if (element == opts.optionalmarker.end && !escaped) {
	                        isOptional = false;
	                        newBlockMarker = true;
	                    }
	                    else {
	                        var maskdef = opts.definitions[element];
	                        if (maskdef && !escaped) {
	                            var prevalidators = maskdef["prevalidator"], prevalidatorsL = prevalidators ? prevalidators.length : 0;
	                            for (var i = 1; i < maskdef.cardinality; i++) {
	                                var prevalidator = prevalidatorsL >= i ? prevalidators[i - 1] : [], validator = prevalidator["validator"], cardinality = prevalidator["cardinality"];
	                                outElem.push({ fn: validator ? typeof validator == 'string' ? new RegExp(validator) : new function () { this.test = validator; } : new RegExp("."), cardinality: cardinality ? cardinality : 1, optionality: isOptional, newBlockMarker: isOptional == true ? newBlockMarker : false, offset: 0, casing: maskdef["casing"], def: element });
	                                if (isOptional == true) //reset newBlockMarker
	                                    newBlockMarker = false;
	                            }
	                            outElem.push({ fn: maskdef.validator ? typeof maskdef.validator == 'string' ? new RegExp(maskdef.validator) : new function () { this.test = maskdef.validator; } : new RegExp("."), cardinality: maskdef.cardinality, optionality: isOptional, newBlockMarker: newBlockMarker, offset: 0, casing: maskdef["casing"], def: element });
	                        } else {
	                            outElem.push({ fn: null, cardinality: 0, optionality: isOptional, newBlockMarker: newBlockMarker, offset: 0, casing: null, def: element });
	                            escaped = false;
	                        }
	                        //reset newBlockMarker
	                        newBlockMarker = false;
	                        return outElem;
	                    }
	                });
	            }
	
	            function generateMaskSets() {  //TODO improve generate masksets
	                var ms = [];
	                function markOptional(maskPart) { //needed for the clearOptionalTail functionality
	                    return opts.optionalmarker.start + maskPart + opts.optionalmarker.end;
	                }
	                function generateMask(maskPrefix, maskPart) {
	                    var maskParts = maskPart.split(opts.optionalmarker.end, 2);
	                    var newMask, maskTemplate;
	
	
	                    var masks = maskParts[0].split(opts.optionalmarker.start);
	                    if (masks.length > 1) {
	                        newMask = maskPrefix + masks[0] + markOptional(masks[1]) + (maskParts.length > 1 ? maskParts[1] : "");
	                        maskTemplate = getMaskTemplate(newMask);
	                        ms.push({
	                            "_buffer": maskTemplate["mask"],
	                            "tests": getTestingChain(newMask),
	                            "lastValidPosition": 0,
	                            "greedy": maskTemplate["greedy"],
	                            "repeat": maskTemplate["repeat"]
	                        });
	                        newMask = maskPrefix + masks[0] + (maskParts.length > 1 ? maskParts[1] : "");
	                        maskTemplate = getMaskTemplate(newMask);
	                        ms.push({
	                            "_buffer": maskTemplate["mask"],
	                            "tests": getTestingChain(newMask),
	                            "lastValidPosition": 0,
	                            "greedy": maskTemplate["greedy"],
	                            "repeat": maskTemplate["repeat"]
	                        });
	                        if (maskParts.length > 1 && maskParts[1].split(opts.optionalmarker.start).length > 1) {
	                            generateMask(maskPrefix + masks[0] + markOptional(masks[1]), maskParts[1]);
	                            generateMask(maskPrefix + masks[0], maskParts[1]);
	                        }
	                    }
	                    else {
	                        newMask = maskPrefix + maskParts;
	                        maskTemplate = getMaskTemplate(newMask);
	                        ms.push({
	                            "_buffer": maskTemplate["mask"],
	                            "tests": getTestingChain(newMask),
	                            "lastValidPosition": 0,
	                            "greedy": maskTemplate["greedy"],
	                            "repeat": maskTemplate["repeat"]
	                        });
	                    }
	
	                }
	
	                generateMask("", opts.mask.toString());
	                return ms;
	            }
	
	            //maskset helperfunctions
	            function getActiveMaskSet() {
	                return masksets[activeMasksetIndex];
	            }
	
	            function getActiveTests() {
	                return getActiveMaskSet()['tests'];
	            }
	
	            function getActiveBuffer() {
	                return getActiveMaskSet()['_buffer'];
	            }
	
	            function isValid(pos, c, buffer, strict, isRTL) { //strict true ~ no correction or autofill
	                function _isValid(position, activeMaskset) {
	                    var testPos = determineTestPosition(position), loopend = c ? 1 : 0, chrs = '';
	                    for (var i = activeMaskset['tests'][testPos].cardinality; i > loopend; i--) {
	                        chrs += getBufferElement(buffer, testPos - (i - 1));
	                    }
	
	                    if (c) {
	                        chrs += c;
	                    }
	
	                    //return is false or a json object => { pos: ??, c: ??} or true
	                    return activeMaskset['tests'][testPos].fn != null ? activeMaskset['tests'][testPos].fn.test(chrs, buffer, position, strict, opts) : false;
	                }
	
	                if (strict) return _isValid(pos, getActiveMaskSet()); //only check validity in current mask when validating strict
	
	                var results = [], result = false, currentActiveMasksetIndex = activeMasksetIndex;
	                $.each(masksets, function (index, value) {
	                    var activeMaskset = this;
	                    activeMasksetIndex = index;
	
	                    var maskPos = pos;
	                    if (currentActiveMasksetIndex != activeMasksetIndex && !isMask(pos)) {
	                        if (c == activeMaskset['_buffer'][maskPos] || c == opts.skipOptionalPartCharacter) { //match non-mask item
	                            results[index] = { "refresh": true };  //new command hack only rewrite buffer
	                            activeMaskset['lastValidPosition'] = maskPos;
	                            return false;
	                        }
	
	                        maskPos = isRTL ? seekPrevious(buffer, pos) : seekNext(buffer, pos);
	                    }
	                    if ((isRTL || opts.numericInput) ? activeMaskset['lastValidPosition'] <= opts.numericInput ? getMaskLength(buffer) : seekNext(buffer, maskPos) : activeMaskset['lastValidPosition'] >= seekPrevious(buffer, maskPos)) {
	                        if (maskPos >= 0 && maskPos < getMaskLength(buffer)) {
	                            results[index] = _isValid(maskPos, activeMaskset);
	                            if (results[index] !== false) {
	                                if (results[index] === true) {
	                                    results[index] = { "pos": maskPos }; //always take a possible corrected maskposition into account
	                                }
	                                activeMaskset['lastValidPosition'] = results[index].pos || maskPos; //set new position from isValid
	                            } else activeMaskset['lastValidPosition'] = isRTL ? seekNext(buffer, pos) : seekPrevious(buffer, pos); //autocorrect validposition from backspace etc  	
	                        }
	                    }
	                });
	                activeMasksetIndex = currentActiveMasksetIndex; //reset activeMasksetIndex
	                determineActiveMasksetIndex(buffer, pos, currentActiveMasksetIndex, isRTL);
	                result = results[activeMasksetIndex] || result;
	                setTimeout(function () { opts.onKeyValidation.call(this, result, opts); }, 0); //extra stuff to execute on keydown
	                return result;
	            }
	
	            function determineActiveMasksetIndex(buffer, pos, currentActiveMasksetIndex, isRTL) {
	                $.each(masksets, function (index, value) {
	                    var activeMaskset = this;
	                    if ((isRTL || opts.numericInput) ? activeMaskset['lastValidPosition'] <= pos : activeMaskset['lastValidPosition'] >= pos) {
	                        activeMasksetIndex = index;
	                        //reset to correct masktemplate
	                        if (activeMasksetIndex != currentActiveMasksetIndex) {
	                            var abl = getMaskLength(buffer), bufTemplate = getActiveBuffer();
	                            if (isRTL || opts.numericInput) {
	                                buffer.reverse();
	                                bufTemplate.reverse();
	                            }
	                            buffer.length = pos; //clearout beyond the current
	                            for (var i = pos; i < abl; i++) {
	                                var testPos = determineTestPosition(i);
	                                setBufferElement(buffer, i, getBufferElement(bufTemplate, testPos));
	                            }
	                            if (isRTL) {
	                                buffer.reverse();
	                            }
	                        }
	                        return false; //breaks
	                    }
	                });
	            }
	
	            function isMask(pos) {
	                var testPos = determineTestPosition(pos);
	                var test = getActiveTests()[testPos];
	
	                return test != undefined ? test.fn : false;
	            }
	
	            function determineTestPosition(pos) {
	                return pos % getActiveTests().length;
	            }
	
	            function getPlaceHolder(pos) {
	                return opts.placeholder.charAt(pos % opts.placeholder.length);
	            }
	
	            function getMaskLength(currentBuffer) {
	                return opts.getMaskLength(getActiveBuffer(), getActiveMaskSet()['greedy'], getActiveMaskSet()['repeat'], currentBuffer, opts);
	            }
	
	            //pos: from position
	            function seekNext(buffer, pos) {
	                var maskL = getMaskLength(buffer);
	                if (pos >= maskL) return maskL;
	                var position = pos;
	                while (++position < maskL && !isMask(position)) { };
	                return position;
	            }
	            //pos: from position
	            function seekPrevious(buffer, pos) {
	                var position = pos;
	                if (position <= 0) return 0;
	
	                while (--position > 0 && !isMask(position)) { };
	                return position;
	            }
	
	            function setBufferElement(buffer, position, element) {
	                //position = prepareBuffer(buffer, position);
	
	                var test = getActiveTests()[determineTestPosition(position)];
	                var elem = element;
	                if (elem != undefined) {
	                    switch (test.casing) {
	                        case "upper":
	                            elem = element.toUpperCase();
	                            break;
	                        case "lower":
	                            elem = element.toLowerCase();
	                            break;
	                    }
	                }
	
	                buffer[position] = elem;
	            }
	            function getBufferElement(buffer, position, autoPrepare) {
	                if (autoPrepare) position = prepareBuffer(buffer, position);
	                return buffer[position];
	            }
	
	            //needed to handle the non-greedy mask repetitions
	            function prepareBuffer(buffer, position, isRTL) {
	                var j;
	                if (isRTL) {
	                    while (position < 0 && buffer.length < getMaskLength(buffer)) {
	                        j = getActiveBuffer().length - 1;
	                        position = getActiveBuffer().length;
	                        while (getActiveBuffer()[j] !== undefined) {
	                            buffer.unshift(getActiveBuffer()[j--]);
	                        }
	                    }
	                } else {
	                    while (buffer[position] == undefined && buffer.length < getMaskLength(buffer)) {
	                        j = 0;
	                        while (getActiveBuffer()[j] !== undefined) { //add a new buffer
	                            buffer.push(getActiveBuffer()[j++]);
	                        }
	                    }
	                }
	
	                return position;
	            }
	
	            function writeBuffer(input, buffer, caretPos) {
	                input._valueSet(buffer.join(''));
	                if (caretPos != undefined) {
	                    if (android) {
	                        setTimeout(function () {
	                            caret(input, caretPos);
	                        }, 100);
	                    }
	                    else caret(input, caretPos);
	                }
	            };
	            function clearBuffer(buffer, start, end) {
	                for (var i = start, maskL = getMaskLength(buffer) ; i < end && i < maskL; i++) {
	                    setBufferElement(buffer, i, getBufferElement(getActiveBuffer().slice(), i));
	                }
	            };
	
	            function setReTargetPlaceHolder(buffer, pos) {
	                var testPos = determineTestPosition(pos);
	                setBufferElement(buffer, pos, getBufferElement(getActiveBuffer(), testPos));
	            }
	
	            function checkVal(input, buffer, clearInvalid, skipRadixHandling) {
	                var isRTL = $(input).data('inputmask')['isRTL'],
	                    inputValue = truncateInput(input._valueGet(), isRTL).split('');
	
	                var maskL = getMaskLength(buffer);
	                if (isRTL) { //align inputValue for RTL/numeric input
	                    var inputValueRev = inputValue.reverse(); inputValueRev.length = maskL;
	
	                    for (var i = 0; i < maskL; i++) {
	                        var targetPosition = determineTestPosition(maskL - (i + 1));
	                        if (getActiveTests()[targetPosition].fn == null && inputValueRev[i] != getBufferElement(getActiveBuffer(), targetPosition)) {
	                            inputValueRev.splice(i, 0, getBufferElement(getActiveBuffer(), targetPosition));
	                            inputValueRev.length = maskL;
	                        } else {
	                            inputValueRev[i] = inputValueRev[i] || getBufferElement(getActiveBuffer(), targetPosition);
	                        }
	                    }
	                    inputValue = inputValueRev.reverse();
	                }
	                clearBuffer(buffer, 0, buffer.length);
	                buffer.length = getActiveBuffer().length;
	                var lastMatch = -1, checkPosition = -1, np, ivl = inputValue.length, rtlMatch = ivl == 0 ? maskL : -1;
	                for (var i = 0; i < ivl; i++) {
	                    for (var pos = checkPosition + 1; pos < maskL; pos++) {
	                        if (isMask(pos)) {
	                            var c = inputValue[i];
	                            if ((np = isValid(pos, c, buffer, !clearInvalid, isRTL)) !== false) {
	                                if (np !== true) {
	                                    pos = np.pos != undefined ? np.pos : pos; //set new position from isValid
	                                    c = np.c != undefined ? np.c : c; //set new char from isValid
	                                }
	                                setBufferElement(buffer, pos, c);
	                                lastMatch = checkPosition = pos;
	                            } else {
	                                setReTargetPlaceHolder(buffer, pos);
	                                if (c == getPlaceHolder(pos)) {
	                                    checkPosition = pos;
	                                    rtlMatch = pos;
	                                }
	                            }
	                            break;
	                        } else {   //nonmask
	                            setReTargetPlaceHolder(buffer, pos);
	                            if (lastMatch == checkPosition) //once outsync the nonmask cannot be the lastmatch
	                                lastMatch = pos;
	                            checkPosition = pos;
	                            if (inputValue[i] == getBufferElement(buffer, pos))
	                                break;
	                        }
	                    }
	                }
	                //Truncate buffer when using non-greedy masks
	                if (getActiveMaskSet()['greedy'] == false) {
	                    var newBuffer = truncateInput(buffer.join(''), isRTL).split('');
	                    while (buffer.length != newBuffer.length) {  //map changes into the original buffer
	                        isRTL ? buffer.shift() : buffer.pop();
	                    }
	                }
	
	                if (clearInvalid) {
	                    writeBuffer(input, buffer);
	                }
	                return isRTL ? (opts.numericInput ? (opts.radixPoint != "" && $.inArray(opts.radixPoint, buffer) != -1 && skipRadixHandling !== true ? $.inArray(opts.radixPoint, buffer) : seekNext(buffer, maskL)) : seekNext(buffer, rtlMatch)) : seekNext(buffer, lastMatch);
	            }
	
	            function escapeRegex(str) {
	                return $.inputmask.escapeRegex.call(this, str);
	            }
	
	            function truncateInput(inputValue, rtl) {
	                return rtl ? inputValue.replace(new RegExp("^(" + escapeRegex(getActiveBuffer().join('')) + ")*"), "") : inputValue.replace(new RegExp("(" + escapeRegex(getActiveBuffer().join('')) + ")*$"), "");
	            }
	
	            function clearOptionalTail(input, buffer) {
	                checkVal(input, buffer, false);
	                var tmpBuffer = buffer.slice(), testPos, pos;
	                if ($(input).data('inputmask')['isRTL']) {
	                    for (var pos = 0; pos <= tmpBuffer.length - 1; pos++) {
	                        var testPos = determineTestPosition(pos);
	                        if (getActiveTests()[testPos].optionality) {
	                            if (!isMask(pos) || !isValid(pos, buffer[pos], buffer, true))
	                                tmpBuffer.splice(0, 1);
	                            else break;
	                        } else break;
	                    }
	                } else {
	                    for (var pos = tmpBuffer.length - 1; pos >= 0; pos--) {
	                        var testPos = determineTestPosition(pos);
	                        if (getActiveTests()[testPos].optionality) {
	                            if (!isMask(pos) || !isValid(pos, buffer[pos], buffer, true))
	                                tmpBuffer.pop();
	                            else break;
	                        } else break;
	                    }
	                }
	                writeBuffer(input, tmpBuffer);
	            }
	
	            //functionality fn
	            function unmaskedvalue($input, skipDatepickerCheck) {
	                var input = $input[0];
	                if (getActiveTests() && (skipDatepickerCheck === true || !$input.hasClass('hasDatepicker'))) {
	                    var buffer = getActiveBuffer().slice();
	                    checkVal(input, buffer);
	                    return $.map(buffer, function (element, index) {
	                        return isMask(index) && isValid(index, element, buffer, true) ? element : null;
	                    }).join('');
	                }
	                else {
	                    return input._valueGet();
	                }
	            }
	
	            function caret(input, begin, end) {       
	                var npt = input.jquery && input.length > 0 ? input[0] : input;
	                if (typeof begin == 'number') {
	                  	if (!$(input).is(':visible')) {
	                    	return;
	                	}
	                    end = (typeof end == 'number') ? end : begin;
	                    if (opts.insertMode == false && begin == end) end++; //set visualization for insert/overwrite mode
	                    if (npt.setSelectionRange) {
	                        if (end == begin) {
	                       		npt.focus();
	                        	npt.setSelectionRange(begin, end);
	                    	} else {
	                        	npt.select();
	                        	npt.selectionStart = begin;
	                        	npt.selectionEnd = android534 ? begin : end;
	                    	}
	                    } else if (npt.createTextRange) {
	                        var range = npt.createTextRange();
	                        range.collapse(true);
	                        range.moveEnd('character', end);
	                        range.moveStart('character', begin);
	                        range.select();
	                    }
	                    npt.focus();
	                    if (android && end != npt.selectionEnd) caretposCorrection = { begin: begin, end: end };
	                } else {
	                	if (!$(input).is(':visible')) {
	                    	return { begin: 0, end: 0 };
	                	}
	                    var caretpos = android ? caretposCorrection : null, caretposCorrection = null;
	                    if (caretpos == null) {
	                        if (npt.setSelectionRange) {
	                            begin = npt.selectionStart;
	                            end = npt.selectionEnd;
	                        } else if (document.selection && document.selection.createRange) {
	                            var range = document.selection.createRange();
	                            begin = 0 - range.duplicate().moveStart('character', -100000);
	                            end = begin + range.text.length;
	                        }
	                        caretpos = { begin: begin, end: end };
	                    }
	                    return caretpos;
	                }
	            };
	
	            function isComplete(buffer) {
	                var complete = false;
	                currentActiveMasksetIndex = activeMasksetIndex, highestValidPosition = 0;
	                $.each(masksets, function (ndx, ms) {
	                    activeMasksetIndex = ndx;
	                    var aml = getMaskLength(buffer);
	                    if (ms["lastValidPosition"] >= highestValidPosition && ms["lastValidPosition"] == (aml - 1)) {
	                        var msComplete = true;
	                        for (var i = 0; i < aml; i++) {
	                            var mask = isMask(i);
	                            if ((mask && buffer[i] == getPlaceHolder(i)) || (!mask && buffer[i] != getActiveBuffer()[i])) {
	                                msComplete = false;
	                                break;
	                            }
	                        }
	                        complete = complete || msComplete;
	                        if (complete) //break loop
	                            return false;
	                    }
	                    highestValidPosition = ms["lastValidPosition"];
	                });
	                activeMasksetIndex = currentActiveMasksetIndex; //reset activeMaskset
	                return complete;
	            }
	
	            function mask(el) {
	                var $input = $(el);
	                if (!$input.is(":input")) return;
	
	                var buffer = getActiveBuffer().slice();
	
	                //correct greedy setting if needed
	                getActiveMaskSet()['greedy'] = getActiveMaskSet()['greedy'] ? getActiveMaskSet()['greedy'] : getActiveMaskSet()['repeat'] == 0;
	
	                //handle maxlength attribute
	                var maxLength = $input.prop('maxLength');
	                if (getMaskLength(buffer) > maxLength && maxLength > -1) { //FF sets no defined max length to -1 
	                    if (maxLength < getActiveBuffer().length) getActiveBuffer().length = maxLength;
	                    if (getActiveMaskSet()['greedy'] == false) {
	                        getActiveMaskSet()['repeat'] = Math.round(maxLength / getActiveBuffer().length);
	                    }
	                    $input.prop('maxLength', getMaskLength(buffer) * 2);
	                }
	
	                //store tests & original buffer in the input element - used to get the unmasked value
	                $input.data('inputmask', {
	                    'masksets': masksets,
	                    'activeMasksetIndex': activeMasksetIndex,
	                    'autoUnmask': opts.autoUnmask,
	                    'definitions': opts.definitions,
	                    'isRTL': false
	                });
	
	                patchValueProperty(el);
	
	                //init vars
	                var buffer = getActiveBuffer().slice(),
	                undoBuffer = el._valueGet(),
	
	                skipKeyPressEvent = false, //Safari 5.1.x - modal dialog fires keypress twice workaround
	                ignorable = false,
	                lastPosition = -1,
	                firstMaskPos = seekNext(buffer, -1),
	                lastMaskPos = seekPrevious(buffer, getMaskLength(buffer)),
	                isRTL = false;
	                if (el.dir == "rtl" || opts.numericInput) {
	                    el.dir = "ltr"
	                    $input.css("text-align", "right");
	                    $input.removeAttr("dir");
	                    var inputData = $input.data('inputmask');
	                    inputData['isRTL'] = true;
	                    $input.data('inputmask', inputData);
	                    isRTL = true;
	                }
	
	                //unbind all events - to make sure that no other mask will interfere when re-masking
	                $input.unbind(".inputmask");
	                $input.removeClass('focus.inputmask');
	                //bind events
	                $input.bind("mouseenter.inputmask", function () {
	                    var $input = $(this), input = this;
	                    if (!$input.hasClass('focus.inputmask') && opts.showMaskOnHover) {
	                        var nptL = input._valueGet().length;
	                        if (nptL < buffer.length) {
	                            if (nptL == 0)
	                                buffer = getActiveBuffer().slice();
	                            writeBuffer(input, buffer);
	                        }
	                    }
	                }).bind("blur.inputmask", function () {
	                    var $input = $(this), input = this, nptValue = input._valueGet();
	                    $input.removeClass('focus.inputmask');
	                    if (nptValue != undoBuffer) {
	                        $input.change();
	                    }
	                    if (opts.clearMaskOnLostFocus && nptValue != '') {
	                        if (nptValue == getActiveBuffer().join(''))
	                            input._valueSet('');
	                        else { //clearout optional tail of the mask
	                            clearOptionalTail(input, buffer);
	                        }
	                    }
	                    if (!isComplete(buffer)) {
	                        $input.trigger("incomplete");
	                        if (opts.clearIncomplete) {
	                            if (opts.clearMaskOnLostFocus)
	                                input._valueSet('');
	                            else {
	                                buffer = getActiveBuffer().slice();
	                                writeBuffer(input, buffer);
	                            }
	                        }
	                    }
	                }).bind("focus.inputmask", function () {
	                    var $input = $(this), input = this, nptValue = input._valueGet();
	                    if (opts.showMaskOnFocus && !$input.hasClass('focus.inputmask') && (!opts.showMaskOnHover || (opts.showMaskOnHover && nptValue == ''))) {
	                        var nptL = nptValue.length;
	                        if (nptL < buffer.length) {
	                            if (nptL == 0)
	                                buffer = getActiveBuffer().slice();
	                            caret(input, checkVal(input, buffer, true));
	                        }
	                    }
	                    $input.addClass('focus.inputmask');
	                    undoBuffer = input._valueGet();
	                }).bind("mouseleave.inputmask", function () {
	                    var $input = $(this), input = this;
	                    if (opts.clearMaskOnLostFocus) {
	                        if (!$input.hasClass('focus.inputmask')) {
	                            if (input._valueGet() == getActiveBuffer().join('') || input._valueGet() == '')
	                                input._valueSet('');
	                            else { //clearout optional tail of the mask
	                                clearOptionalTail(input, buffer);
	                            }
	                        }
	                    }
	                }).bind("click.inputmask", function () {
	                    var input = this;
	                    setTimeout(function () {
	                        var selectedCaret = caret(input);
	                        if (selectedCaret.begin == selectedCaret.end) {
	                            var clickPosition = selectedCaret.begin;
	                            lastPosition = checkVal(input, buffer, false);
	                            determineInputDirection(input, selectedCaret);
	                            if (isRTL)
	                                caret(input, clickPosition > lastPosition && (isValid(clickPosition, buffer[clickPosition], buffer, true, isRTL) !== false || !isMask(clickPosition)) ? clickPosition : lastPosition);
	                            else
	                                caret(input, clickPosition < lastPosition && (isValid(clickPosition, buffer[clickPosition], buffer, true, isRTL) !== false || !isMask(clickPosition)) ? clickPosition : lastPosition);
	                        }
	                    }, 0);
	                }).bind('dblclick.inputmask', function () {
	                    var input = this;
	                    setTimeout(function () {
	                        caret(input, 0, lastPosition);
	                    }, 0);
	                }).bind("keydown.inputmask", keydownEvent
	                ).bind("keypress.inputmask", keypressEvent
	                ).bind("keyup.inputmask", keyupEvent
	                ).bind(pasteEvent + ".inputmask dragdrop.inputmask drop.inputmask", function () {
	                    var input = this;
	                    setTimeout(function () {
	                        caret(input, checkVal(input, buffer, true));
	                        if (isComplete(buffer))
	                            $input.trigger("complete");
	                    }, 0);
	                }).bind('setvalue.inputmask', function () {
	                    var input = this;
	                    undoBuffer = input._valueGet();
	                    checkVal(input, buffer, true);
	                    if (input._valueGet() == getActiveBuffer().join(''))
	                        input._valueSet('');
	                }).bind('complete.inputmask', opts.oncomplete)
	                .bind('incomplete.inputmask', opts.onincomplete)
	                .bind('cleared.inputmask', opts.oncleared);
	
	                //apply mask
	                lastPosition = checkVal(el, buffer, true);
	
	                // Wrap document.activeElement in a try/catch block since IE9 throw "Unspecified error" if document.activeElement is undefined when we are in an IFrame.
	                var activeElement;
	                try {
	                    activeElement = document.activeElement;
	                } catch (e) { }
	                if (activeElement === el) { //position the caret when in focus
	                    $input.addClass('focus.inputmask');
	                    caret(el, lastPosition);
	                } else if (opts.clearMaskOnLostFocus) {
	                    if (el._valueGet() == getActiveBuffer().join('')) {
	                        el._valueSet('');
	                    } else {
	                        clearOptionalTail(el, buffer);
	                    }
	                }
	
	                installEventRuler(el);
	
	                //private functions
	                function installEventRuler(npt) {
	                    var events = $._data(npt).events;
	
	                    $.each(events, function (eventType, eventHandlers) {
	                        $.each(eventHandlers, function (ndx, eventHandler) {
	                            if (eventHandler.namespace == "inputmask") {
	                                var handler = eventHandler.handler;
	                                eventHandler.handler = function () {
	                                    if (this.readOnly || this.disabled)
	                                        return false;
	                                    return handler.apply(this, arguments);
	                                };
	                            }
	                        });
	                    });
	                }
	
	                function patchValueProperty(npt) {
	                    var valueProperty;
	                    if (Object.getOwnPropertyDescriptor)
	                        valueProperty = Object.getOwnPropertyDescriptor(npt, "value");
	                    if (valueProperty && valueProperty.get) {
	                        if (!npt._valueGet) {
	
	                            npt._valueGet = valueProperty.get;
	                            npt._valueSet = valueProperty.set;
	
	                            Object.defineProperty(npt, "value", {
	                                get: function () {
	                                    var $self = $(this), inputData = $(this).data('inputmask'), masksets = inputData['masksets'],
	                                    activeMasksetIndex = inputData['activeMasksetIndex'];
	                                    return inputData && inputData['autoUnmask'] ? $self.inputmask('unmaskedvalue') : this._valueGet() != masksets[activeMasksetIndex]['_buffer'].join('') ? this._valueGet() : '';
	                                },
	                                set: function (value) {
	                                    this._valueSet(value); $(this).triggerHandler('setvalue.inputmask');
	                                }
	                            });
	                        }
	                    } else if (document.__lookupGetter__ && npt.__lookupGetter__("value")) {
	                        if (!npt._valueGet) {
	                            npt._valueGet = npt.__lookupGetter__("value");
	                            npt._valueSet = npt.__lookupSetter__("value");
	
	                            npt.__defineGetter__("value", function () {
	                                var $self = $(this), inputData = $(this).data('inputmask'), masksets = inputData['masksets'],
	                                    activeMasksetIndex = inputData['activeMasksetIndex'];
	                                return inputData && inputData['autoUnmask'] ? $self.inputmask('unmaskedvalue') : this._valueGet() != masksets[activeMasksetIndex]['_buffer'].join('') ? this._valueGet() : '';
	                            });
	                            npt.__defineSetter__("value", function (value) {
	                                this._valueSet(value); $(this).triggerHandler('setvalue.inputmask');
	                            });
	                        }
	                    } else {
	                        if (!npt._valueGet) {
	                            npt._valueGet = function () { return this.value; }
	                            npt._valueSet = function (value) { this.value = value; }
	                        }
	                        if ($.fn.val.inputmaskpatch != true) {
	                            $.fn.val = function () {
	                                if (arguments.length == 0) {
	                                    var $self = $(this);
	                                    if ($self.data('inputmask')) {
	                                        if ($self.data('inputmask')['autoUnmask'])
	                                            return $self.inputmask('unmaskedvalue');
	                                        else {
	                                            var result = $.inputmask.val.apply($self);
	                                            var inputData = $(this).data('inputmask'), masksets = inputData['masksets'],
	                                            activeMasksetIndex = inputData['activeMasksetIndex'];
	                                            return result != masksets[activeMasksetIndex]['_buffer'].join('') ? result : '';
	                                        }
	                                    } else return $.inputmask.val.apply($self);
	                                } else {
	                                    var args = arguments;
	                                    return this.each(function () {
	                                        var $self = $(this);
	                                        var result = $.inputmask.val.apply($self, args);
	                                        if ($self.data('inputmask')) $self.triggerHandler('setvalue.inputmask');
	                                        return result;
	                                    });
	                                }
	                            };
	                            $.extend($.fn.val, {
	                                inputmaskpatch: true
	                            });
	                        }
	                    }
	                }
	
	                function determineInputDirection(input, pos) {
	                    //set input direction according the position to the radixPoint
	                    if (opts.numericInput && opts.radixPoint != "") {
	                        var nptStr = input._valueGet();
	                        var radixPosition = nptStr.indexOf(opts.radixPoint);
	                        isRTL = pos.begin <= radixPosition || pos.end <= radixPosition || radixPosition == -1;
	                    }
	                }
	
	                //shift chars to left from start to end and put c at end position if defined
	                function shiftL(start, end, c) {
	                    while (!isMask(start) && start - 1 >= 0) start--;
	                    for (var i = start; i < end && i < getMaskLength(buffer) ; i++) {
	                        if (isMask(i)) {
	                            setReTargetPlaceHolder(buffer, i);
	                            var j = seekNext(buffer, i);
	                            var p = getBufferElement(buffer, j);
	                            if (p != getPlaceHolder(j)) {
	                                if (j < getMaskLength(buffer) && isValid(i, p, buffer, true, isRTL) !== false && getActiveTests()[determineTestPosition(i)].def == getActiveTests()[determineTestPosition(j)].def) {
	                                    setBufferElement(buffer, i, getBufferElement(buffer, j));
	                                    setReTargetPlaceHolder(buffer, j); //cleanup next position
	                                } else {
	                                    if (isMask(i))
	                                        break;
	                                }
	                            } else if (c == undefined) break;
	                        } else {
	                            setReTargetPlaceHolder(buffer, i);
	                        }
	                    }
	                    if (c != undefined)
	                        setBufferElement(buffer, isRTL ? end : seekPrevious(buffer, end), c);
	
	                    buffer = truncateInput(buffer.join(''), isRTL).split('');
	                    if (buffer.length == 0) buffer = getActiveBuffer().slice();
	
	                    return start; //return the used start position
	                }
	                function shiftR(start, end, c, full) { //full => behave like a push right ~ do not stop on placeholders
	                    for (var i = start; i <= end && i < getMaskLength(buffer) ; i++) {
	                        if (isMask(i)) {
	                            var t = getBufferElement(buffer, i);
	                            setBufferElement(buffer, i, c);
	                            if (t != getPlaceHolder(i)) {
	                                var j = seekNext(buffer, i);
	                                if (j < getMaskLength(buffer)) {
	                                    if (isValid(j, t, buffer, true, isRTL) !== false && getActiveTests()[determineTestPosition(i)].def == getActiveTests()[determineTestPosition(j)].def)
	                                        c = t;
	                                    else {
	                                        if (isMask(j))
	                                            break;
	                                        else c = t;
	                                    }
	                                } else break;
	                            } else if (full !== true) break;
	                        } else
	                            setReTargetPlaceHolder(buffer, i);
	                    }
	                    var lengthBefore = buffer.length;
	                    buffer = truncateInput(buffer.join(''), isRTL).split('');
	                    if (buffer.length == 0) buffer = getActiveBuffer().slice();
	
	                    return end - (lengthBefore - buffer.length);  //return new start position
	                };
	
	                function keydownEvent(e) {
	                    //Safari 5.1.x - modal dialog fires keypress twice workaround
	                    skipKeyPressEvent = false;
	
	                    var input = this, k = e.keyCode, pos = caret(input);
	
	                    determineInputDirection(input, pos);
	
	                    //backspace, delete, and escape get special treatment
	                    if (k == opts.keyCode.BACKSPACE || k == opts.keyCode.DELETE || (iphone && k == 127)) {//backspace/delete
	                        var maskL = getMaskLength(buffer);
	                        if (pos.begin == 0 && pos.end == maskL) { //remove full selection
	                            activeMasksetIndex = 0; //reset activemask
	                            buffer = getActiveBuffer().slice();
	                            writeBuffer(input, buffer);
	                            caret(input, checkVal(input, buffer, false));
	                        } else if ((pos.end - pos.begin) > 1 || ((pos.end - pos.begin) == 1 && opts.insertMode)) { //partial selection
	                            clearBuffer(buffer, pos.begin, pos.end);
	                            determineActiveMasksetIndex(buffer, pos.begin, activeMasksetIndex);
	                            writeBuffer(input, buffer, isRTL ? checkVal(input, buffer, false) : pos.begin);
	                        } else { //handle delete
	                            var beginPos = pos.begin;
	                            if (k == opts.keyCode.DELETE) {
	                                if (beginPos < firstMaskPos)
	                                    beginPos = firstMaskPos;
	                                if (beginPos < maskL) {
	                                    if (opts.numericInput && opts.radixPoint != "" && buffer[beginPos] == opts.radixPoint) {
	                                        beginPos = (buffer.length - 1 == beginPos) /* radixPoint is latest? delete it */ ? beginPos : seekNext(buffer, beginPos);
	                                        beginPos = shiftL(beginPos, maskL);
	                                    } else {
	                                        if (isRTL) {
	                                            beginPos = shiftR(firstMaskPos, beginPos, getPlaceHolder(beginPos), true);
	                                            beginPos = seekNext(buffer, beginPos);
	                                        } else {
	                                            beginPos = shiftL(beginPos, maskL);
	                                        }
	                                    }
	                                    determineActiveMasksetIndex(buffer, beginPos, activeMasksetIndex);
	                                    writeBuffer(input, buffer, beginPos);
	                                }
	                            } else if (k == opts.keyCode.BACKSPACE) { //handle backspace
	                                if (beginPos > firstMaskPos) {
	                                    beginPos -= 1;
	                                    if (opts.numericInput && opts.radixPoint != "" && buffer[beginPos] == opts.radixPoint) {
	                                        beginPos = shiftR(firstMaskPos, (buffer.length - 1 == beginPos) /* radixPoint is latest? delete it */ ? beginPos : beginPos - 1, getPlaceHolder(beginPos), true);
	                                        beginPos++;
	                                    } else {
	                                        if (isRTL) {
	                                            beginPos = shiftR(firstMaskPos, beginPos, getPlaceHolder(beginPos), true);
	                                            beginPos = buffer[beginPos + 1] == opts.radixPoint ? beginPos + 1 : seekNext(buffer, beginPos);
	                                        } else {
	                                            beginPos = shiftL(beginPos, maskL);
	                                        }
	                                    }
	                                    determineActiveMasksetIndex(buffer, beginPos, activeMasksetIndex);
	                                    writeBuffer(input, buffer, beginPos);
	                                }
	                            }
	                        }
	                        if (input._valueGet() == getActiveBuffer().join(''))
	                            $(input).trigger('cleared');
	
	                        e.preventDefault(); //stop default action but allow propagation
	                    } else if (k == opts.keyCode.END || k == opts.keyCode.PAGE_DOWN) { //when END or PAGE_DOWN pressed set position at lastmatch
	                        setTimeout(function () {
	                            var caretPos = checkVal(input, buffer, false, true);
	                            if (!opts.insertMode && caretPos == getMaskLength(buffer) && !e.shiftKey) caretPos--;
	                            caret(input, e.shiftKey ? pos.begin : caretPos, caretPos);
	                        }, 0);
	                    } else if (k == opts.keyCode.HOME || k == opts.keyCode.PAGE_UP) {//Home or page_up
	                        caret(input, 0, e.shiftKey ? pos.begin : 0);
	                    }
	                    else if (k == opts.keyCode.ESCAPE) {//escape
	                        input._valueSet(undoBuffer);
	                        caret(input, 0, checkVal(input, buffer));
	                    } else if (k == opts.keyCode.INSERT) {//insert
	                        opts.insertMode = !opts.insertMode;
	                        caret(input, !opts.insertMode && pos.begin == getMaskLength(buffer) ? pos.begin - 1 : pos.begin);
	                    } else if (e.ctrlKey && k == 88) {
	                        setTimeout(function () {
	                            caret(input, checkVal(input, buffer, true));
	                        }, 0);
	                    } else if (!opts.insertMode) { //overwritemode
	                        if (k == opts.keyCode.RIGHT) {//right
	                            var caretPos = pos.begin == pos.end ? pos.end + 1 : pos.end;
	                            caretPos = caretPos < getMaskLength(buffer) ? caretPos : pos.end;
	                            caret(input, e.shiftKey ? pos.begin : caretPos, e.shiftKey ? caretPos + 1 : caretPos);
	                        } else if (k == opts.keyCode.LEFT) {//left
	                            var caretPos = pos.begin - 1;
	                            caretPos = caretPos > 0 ? caretPos : 0;
	                            caret(input, caretPos, e.shiftKey ? pos.end : caretPos);
	                        }
	                    }
	
	                    opts.onKeyDown.call(this, e, buffer, opts); //extra stuff to execute on keydown
	                    ignorable = $.inArray(k, opts.ignorables) != -1;
	                }
	
	                function keypressEvent(e) {
	                    //Safari 5.1.x - modal dialog fires keypress twice workaround
	                    if (skipKeyPressEvent) return false;
	                    skipKeyPressEvent = true;
	
	                    var input = this, $input = $(input);
	
	                    e = e || window.event;
	                    var k = e.which || e.charCode || e.keyCode,
	                        c = String.fromCharCode(k);
	
	                    if (opts.numericInput && c == opts.radixPoint) {
	                        var nptStr = input._valueGet();
	                        var radixPosition = nptStr.indexOf(opts.radixPoint);
	                        caret(input, seekNext(buffer, radixPosition != -1 ? radixPosition : getMaskLength(buffer)));
	                    }
	
	                    if (e.ctrlKey || e.altKey || e.metaKey || ignorable) {
	                        return true;
	                    } else {
	                        if (k) {
	                            $input.trigger('input');
	
	                            var pos = caret(input), maskL = getMaskLength(buffer), writeOutBuffer = true;
	                            clearBuffer(buffer, pos.begin, pos.end);
	
	                            if (isRTL) {
	                                var p = seekPrevious(buffer, pos.end), np;
	                                if ((np = isValid(p == maskL || getBufferElement(buffer, p) == opts.radixPoint ? seekPrevious(buffer, p) : p, c, buffer, false, isRTL)) !== false) {
	                                    var refresh = false;
	                                    if (np !== true) {
	                                        refresh = np["refresh"]; //only rewrite buffer from isValid
	                                        p = np.pos != undefined ? np.pos : p; //set new position from isValid
	                                        c = np.c != undefined ? np.c : c; //set new char from isValid
	                                    }
	                                    if (refresh !== true) {
	                                        maskL = getMaskLength(buffer); //update masklength to include possible groupSeparator offset
	                                        var firstUnmaskedPosition = firstMaskPos;
	                                        if (opts.insertMode == true) {
	                                            if (getActiveMaskSet()['greedy'] == true) {
	                                                var bfrClone = buffer.slice();
	                                                while (getBufferElement(bfrClone, firstUnmaskedPosition, true) != getPlaceHolder(firstUnmaskedPosition) && firstUnmaskedPosition <= p) {
	                                                    firstUnmaskedPosition = firstUnmaskedPosition == maskL ? (maskL + 1) : seekNext(buffer, firstUnmaskedPosition);
	                                                }
	                                            }
	                                            if (firstUnmaskedPosition <= p && (getActiveMaskSet()['greedy'] || buffer.length < maskL)) {
	                                                if (buffer[firstMaskPos] != getPlaceHolder(firstMaskPos) && buffer.length < maskL) {
	                                                    var offset = prepareBuffer(buffer, -1, isRTL);
	                                                    if (pos.end != 0) p = p + offset;
	                                                    maskL = buffer.length;
	                                                }
	                                                shiftL(firstUnmaskedPosition, p, c);
	                                            } else writeOutBuffer = false;
	                                        } else setBufferElement(buffer, p, c);
	                                    }
	
	                                    if (writeOutBuffer) {
	                                        writeBuffer(input, buffer, opts.numericInput ? p + 1 : p);
	                                        setTimeout(function () { //timeout needed for IE
	                                            if (isComplete(buffer))
	                                                $input.trigger("complete");
	                                        }, 0);
	                                    }
	                                } else if (android) writeBuffer(input, buffer, pos.begin);
	                            }
	                            else {
	                                var p = seekNext(buffer, pos.begin - 1), np;
	                                prepareBuffer(buffer, p, isRTL);
	                                if ((np = isValid(p, c, buffer, false, isRTL)) !== false) {
	                                    var refresh = false;
	                                    if (np !== true) {
	                                        refresh = np["refresh"]; //only rewrite buffer from isValid
	                                        p = np.pos != undefined ? np.pos : p; //set new position from isValid
	                                        c = np.c != undefined ? np.c : c; //set new char from isValid
	                                    }
	                                    if (refresh !== true) {
	                                        if (opts.insertMode == true) {
	                                            var lastUnmaskedPosition = getMaskLength(buffer);
	                                            var bfrClone = buffer.slice();
	                                            while (getBufferElement(bfrClone, lastUnmaskedPosition, true) != getPlaceHolder(lastUnmaskedPosition) && lastUnmaskedPosition >= p) {
	                                                lastUnmaskedPosition = lastUnmaskedPosition == 0 ? -1 : seekPrevious(buffer, lastUnmaskedPosition);
	                                            }
	                                            if (lastUnmaskedPosition >= p)
	                                                shiftR(p, buffer.length, c);
	                                            else writeOutBuffer = false;
	                                        } else setBufferElement(buffer, p, c);
	                                    }
	                                    if (writeOutBuffer) {
	                                        var next = seekNext(buffer, p);
	                                        writeBuffer(input, buffer, next);
	
	                                        setTimeout(function () { //timeout needed for IE
	                                            if (isComplete(buffer))
	                                                $input.trigger("complete");
	                                        }, 0);
	                                    }
	                                } else if (android) writeBuffer(input, buffer, pos.begin);
	                            }
	                            e.preventDefault();
	                        }
	                    }
	                }
	
	                function keyupEvent(e) {
	                    var $input = $(this), input = this;
	                    var k = e.keyCode;
	                    opts.onKeyUp.call(this, e, buffer, opts); //extra stuff to execute on keyup
	                    if (k == opts.keyCode.TAB && $input.hasClass('focus.inputmask') && input._valueGet().length == 0 && opts.showMaskOnFocus) {
	                        buffer = getActiveBuffer().slice();
	                        writeBuffer(input, buffer);
	                        if (!isRTL) caret(input, 0);
	                        undoBuffer = input._valueGet();
	                    }
	                }
	            }
	
	            return this; //return this to expose publics
	        };
	    }
	})(jQuery);

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * @copyright Copyright &copy; Kartik Visweswaran, Krajee.com, 2014 - 2016
	 * @version 1.3.4
	 *
	 * Date formatter utility library that allows formatting date/time variables or Date objects using PHP DateTime format.
	 * @see http://php.net/manual/en/function.date.php
	 *
	 * For more JQuery plugins visit http://plugins.krajee.com
	 * For more Yii related demos visit http://demos.krajee.com
	 */var DateFormatter;!function(){"use strict";var t,e,r,n,a,u,i;u=864e5,i=3600,t=function(t,e){return"string"==typeof t&&"string"==typeof e&&t.toLowerCase()===e.toLowerCase()},e=function(t,r,n){var a=n||"0",u=t.toString();return u.length<r?e(a+u,r):u},r=function(t){var e,n;for(t=t||{},e=1;e<arguments.length;e++)if(n=arguments[e])for(var a in n)n.hasOwnProperty(a)&&("object"==typeof n[a]?r(t[a],n[a]):t[a]=n[a]);return t},n=function(t,e){for(var r=0;r<e.length;r++)if(e[r].toLowerCase()===t.toLowerCase())return r;return-1},a={dateSettings:{days:["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],daysShort:["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],months:["January","February","March","April","May","June","July","August","September","October","November","December"],monthsShort:["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],meridiem:["AM","PM"],ordinal:function(t){var e=t%10,r={1:"st",2:"nd",3:"rd"};return 1!==Math.floor(t%100/10)&&r[e]?r[e]:"th"}},separators:/[ \-+\/\.T:@]/g,validParts:/[dDjlNSwzWFmMntLoYyaABgGhHisueTIOPZcrU]/g,intParts:/[djwNzmnyYhHgGis]/g,tzParts:/\b(?:[PMCEA][SDP]T|(?:Pacific|Mountain|Central|Eastern|Atlantic) (?:Standard|Daylight|Prevailing) Time|(?:GMT|UTC)(?:[-+]\d{4})?)\b/g,tzClip:/[^-+\dA-Z]/g},DateFormatter=function(t){var e=this,n=r(a,t);e.dateSettings=n.dateSettings,e.separators=n.separators,e.validParts=n.validParts,e.intParts=n.intParts,e.tzParts=n.tzParts,e.tzClip=n.tzClip},DateFormatter.prototype={constructor:DateFormatter,getMonth:function(t){var e,r=this;return e=n(t,r.dateSettings.monthsShort)+1,0===e&&(e=n(t,r.dateSettings.months)+1),e},parseDate:function(e,r){var n,a,u,i,s,o,c,f,l,h,d=this,g=!1,m=!1,p=d.dateSettings,y={date:null,year:null,month:null,day:null,hour:0,min:0,sec:0};if(!e)return null;if(e instanceof Date)return e;if("U"===r)return u=parseInt(e),u?new Date(1e3*u):e;switch(typeof e){case"number":return new Date(e);case"string":break;default:return null}if(n=r.match(d.validParts),!n||0===n.length)throw new Error("Invalid date format definition.");for(a=e.replace(d.separators,"\x00").split("\x00"),u=0;u<a.length;u++)switch(i=a[u],s=parseInt(i),n[u]){case"y":case"Y":if(!s)return null;l=i.length,y.year=2===l?parseInt((70>s?"20":"19")+i):s,g=!0;break;case"m":case"n":case"M":case"F":if(isNaN(s)){if(o=d.getMonth(i),!(o>0))return null;y.month=o}else{if(!(s>=1&&12>=s))return null;y.month=s}g=!0;break;case"d":case"j":if(!(s>=1&&31>=s))return null;y.day=s,g=!0;break;case"g":case"h":if(c=n.indexOf("a")>-1?n.indexOf("a"):n.indexOf("A")>-1?n.indexOf("A"):-1,h=a[c],c>-1)f=t(h,p.meridiem[0])?0:t(h,p.meridiem[1])?12:-1,s>=1&&12>=s&&f>-1?y.hour=s+f-1:s>=0&&23>=s&&(y.hour=s);else{if(!(s>=0&&23>=s))return null;y.hour=s}m=!0;break;case"G":case"H":if(!(s>=0&&23>=s))return null;y.hour=s,m=!0;break;case"i":if(!(s>=0&&59>=s))return null;y.min=s,m=!0;break;case"s":if(!(s>=0&&59>=s))return null;y.sec=s,m=!0}if(g===!0&&y.year&&y.month&&y.day)y.date=new Date(y.year,y.month-1,y.day,y.hour,y.min,y.sec,0);else{if(m!==!0)return null;y.date=new Date(0,0,0,y.hour,y.min,y.sec,0)}return y.date},guessDate:function(t,e){if("string"!=typeof t)return t;var r,n,a,u,i,s,o=this,c=t.replace(o.separators,"\x00").split("\x00"),f=/^[djmn]/g,l=e.match(o.validParts),h=new Date,d=0;if(!f.test(l[0]))return t;for(a=0;a<c.length;a++){if(d=2,i=c[a],s=parseInt(i.substr(0,2)),isNaN(s))return null;switch(a){case 0:"m"===l[0]||"n"===l[0]?h.setMonth(s-1):h.setDate(s);break;case 1:"m"===l[0]||"n"===l[0]?h.setDate(s):h.setMonth(s-1);break;case 2:if(n=h.getFullYear(),r=i.length,d=4>r?r:4,n=parseInt(4>r?n.toString().substr(0,4-r)+i:i.substr(0,4)),!n)return null;h.setFullYear(n);break;case 3:h.setHours(s);break;case 4:h.setMinutes(s);break;case 5:h.setSeconds(s)}u=i.substr(d),u.length>0&&c.splice(a+1,0,u)}return h},parseFormat:function(t,r){var n,a=this,s=a.dateSettings,o=/\\?(.?)/gi,c=function(t,e){return n[t]?n[t]():e};return n={d:function(){return e(n.j(),2)},D:function(){return s.daysShort[n.w()]},j:function(){return r.getDate()},l:function(){return s.days[n.w()]},N:function(){return n.w()||7},w:function(){return r.getDay()},z:function(){var t=new Date(n.Y(),n.n()-1,n.j()),e=new Date(n.Y(),0,1);return Math.round((t-e)/u)},W:function(){var t=new Date(n.Y(),n.n()-1,n.j()-n.N()+3),r=new Date(t.getFullYear(),0,4);return e(1+Math.round((t-r)/u/7),2)},F:function(){return s.months[r.getMonth()]},m:function(){return e(n.n(),2)},M:function(){return s.monthsShort[r.getMonth()]},n:function(){return r.getMonth()+1},t:function(){return new Date(n.Y(),n.n(),0).getDate()},L:function(){var t=n.Y();return t%4===0&&t%100!==0||t%400===0?1:0},o:function(){var t=n.n(),e=n.W(),r=n.Y();return r+(12===t&&9>e?1:1===t&&e>9?-1:0)},Y:function(){return r.getFullYear()},y:function(){return n.Y().toString().slice(-2)},a:function(){return n.A().toLowerCase()},A:function(){var t=n.G()<12?0:1;return s.meridiem[t]},B:function(){var t=r.getUTCHours()*i,n=60*r.getUTCMinutes(),a=r.getUTCSeconds();return e(Math.floor((t+n+a+i)/86.4)%1e3,3)},g:function(){return n.G()%12||12},G:function(){return r.getHours()},h:function(){return e(n.g(),2)},H:function(){return e(n.G(),2)},i:function(){return e(r.getMinutes(),2)},s:function(){return e(r.getSeconds(),2)},u:function(){return e(1e3*r.getMilliseconds(),6)},e:function(){var t=/\((.*)\)/.exec(String(r))[1];return t||"Coordinated Universal Time"},I:function(){var t=new Date(n.Y(),0),e=Date.UTC(n.Y(),0),r=new Date(n.Y(),6),a=Date.UTC(n.Y(),6);return t-e!==r-a?1:0},O:function(){var t=r.getTimezoneOffset(),n=Math.abs(t);return(t>0?"-":"+")+e(100*Math.floor(n/60)+n%60,4)},P:function(){var t=n.O();return t.substr(0,3)+":"+t.substr(3,2)},T:function(){var t=(String(r).match(a.tzParts)||[""]).pop().replace(a.tzClip,"");return t||"UTC"},Z:function(){return 60*-r.getTimezoneOffset()},c:function(){return"Y-m-d\\TH:i:sP".replace(o,c)},r:function(){return"D, d M Y H:i:s O".replace(o,c)},U:function(){return r.getTime()/1e3||0}},c(t,t)},formatDate:function(t,e){var r,n,a,u,i,s=this,o="",c="\\";if("string"==typeof t&&(t=s.parseDate(t,e),!t))return null;if(t instanceof Date){for(a=e.length,r=0;a>r;r++)i=e.charAt(r),"S"!==i&&i!==c&&(r>0&&e.charAt(r-1)===c?o+=i:(u=s.parseFormat(i,t),r!==a-1&&s.intParts.test(i)&&"S"===e.charAt(r+1)&&(n=parseInt(u)||0,u+=s.dateSettings.ordinal(n)),o+=u));return o}return""}}}();
	/**
	 * @preserve jQuery DateTimePicker
	 * @homepage http://xdsoft.net/jqplugins/datetimepicker/
	 * @author Chupurnov Valeriy (<chupurnov@gmail.com>)
	 */
	
	/**
	 * @param {jQuery} $
	 */
	var datetimepickerFactory = function ($) {
		'use strict';
	
		var default_options  = {
			i18n: {
				ar: { // Arabic
					months: [
						"كانون الثاني", "شباط", "آذار", "نيسان", "مايو", "حزيران", "تموز", "آب", "أيلول", "تشرين الأول", "تشرين الثاني", "كانون الأول"
					],
					dayOfWeekShort: [
						"ن", "ث", "ع", "خ", "ج", "س", "ح"
					],
					dayOfWeek: ["الأحد", "الاثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت", "الأحد"]
				},
				ro: { // Romanian
					months: [
						"Ianuarie", "Februarie", "Martie", "Aprilie", "Mai", "Iunie", "Iulie", "August", "Septembrie", "Octombrie", "Noiembrie", "Decembrie"
					],
					dayOfWeekShort: [
						"Du", "Lu", "Ma", "Mi", "Jo", "Vi", "Sâ"
					],
					dayOfWeek: ["Duminică", "Luni", "Marţi", "Miercuri", "Joi", "Vineri", "Sâmbătă"]
				},
				id: { // Indonesian
					months: [
						"Januari", "Februari", "Maret", "April", "Mei", "Juni", "Juli", "Agustus", "September", "Oktober", "November", "Desember"
					],
					dayOfWeekShort: [
						"Min", "Sen", "Sel", "Rab", "Kam", "Jum", "Sab"
					],
					dayOfWeek: ["Minggu", "Senin", "Selasa", "Rabu", "Kamis", "Jumat", "Sabtu"]
				},
				is: { // Icelandic
					months: [
						"Janúar", "Febrúar", "Mars", "Apríl", "Maí", "Júní", "Júlí", "Ágúst", "September", "Október", "Nóvember", "Desember"
					],
					dayOfWeekShort: [
						"Sun", "Mán", "Þrið", "Mið", "Fim", "Fös", "Lau"
					],
					dayOfWeek: ["Sunnudagur", "Mánudagur", "Þriðjudagur", "Miðvikudagur", "Fimmtudagur", "Föstudagur", "Laugardagur"]
				},
				bg: { // Bulgarian
					months: [
						"Януари", "Февруари", "Март", "Април", "Май", "Юни", "Юли", "Август", "Септември", "Октомври", "Ноември", "Декември"
					],
					dayOfWeekShort: [
						"Нд", "Пн", "Вт", "Ср", "Чт", "Пт", "Сб"
					],
					dayOfWeek: ["Неделя", "Понеделник", "Вторник", "Сряда", "Четвъртък", "Петък", "Събота"]
				},
				fa: { // Persian/Farsi
					months: [
						'فروردین', 'اردیبهشت', 'خرداد', 'تیر', 'مرداد', 'شهریور', 'مهر', 'آبان', 'آذر', 'دی', 'بهمن', 'اسفند'
					],
					dayOfWeekShort: [
						'یکشنبه', 'دوشنبه', 'سه شنبه', 'چهارشنبه', 'پنجشنبه', 'جمعه', 'شنبه'
					],
					dayOfWeek: ["یک‌شنبه", "دوشنبه", "سه‌شنبه", "چهارشنبه", "پنج‌شنبه", "جمعه", "شنبه", "یک‌شنبه"]
				},
				ru: { // Russian
					months: [
						'Январь', 'Февраль', 'Март', 'Апрель', 'Май', 'Июнь', 'Июль', 'Август', 'Сентябрь', 'Октябрь', 'Ноябрь', 'Декабрь'
					],
					dayOfWeekShort: [
						"Вс", "Пн", "Вт", "Ср", "Чт", "Пт", "Сб"
					],
					dayOfWeek: ["Воскресенье", "Понедельник", "Вторник", "Среда", "Четверг", "Пятница", "Суббота"]
				},
				uk: { // Ukrainian
					months: [
						'Січень', 'Лютий', 'Березень', 'Квітень', 'Травень', 'Червень', 'Липень', 'Серпень', 'Вересень', 'Жовтень', 'Листопад', 'Грудень'
					],
					dayOfWeekShort: [
						"Ндл", "Пнд", "Втр", "Срд", "Чтв", "Птн", "Сбт"
					],
					dayOfWeek: ["Неділя", "Понеділок", "Вівторок", "Середа", "Четвер", "П'ятниця", "Субота"]
				},
				en: { // English
					months: [
						"January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"
					],
					dayOfWeekShort: [
						"Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"
					],
					dayOfWeek: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
				},
				el: { // Ελληνικά
					months: [
						"Ιανουάριος", "Φεβρουάριος", "Μάρτιος", "Απρίλιος", "Μάιος", "Ιούνιος", "Ιούλιος", "Αύγουστος", "Σεπτέμβριος", "Οκτώβριος", "Νοέμβριος", "Δεκέμβριος"
					],
					dayOfWeekShort: [
						"Κυρ", "Δευ", "Τρι", "Τετ", "Πεμ", "Παρ", "Σαβ"
					],
					dayOfWeek: ["Κυριακή", "Δευτέρα", "Τρίτη", "Τετάρτη", "Πέμπτη", "Παρασκευή", "Σάββατο"]
				},
				de: { // German
					months: [
						'Januar', 'Februar', 'März', 'April', 'Mai', 'Juni', 'Juli', 'August', 'September', 'Oktober', 'November', 'Dezember'
					],
					dayOfWeekShort: [
						"So", "Mo", "Di", "Mi", "Do", "Fr", "Sa"
					],
					dayOfWeek: ["Sonntag", "Montag", "Dienstag", "Mittwoch", "Donnerstag", "Freitag", "Samstag"]
				},
				nl: { // Dutch
					months: [
						"januari", "februari", "maart", "april", "mei", "juni", "juli", "augustus", "september", "oktober", "november", "december"
					],
					dayOfWeekShort: [
						"zo", "ma", "di", "wo", "do", "vr", "za"
					],
					dayOfWeek: ["zondag", "maandag", "dinsdag", "woensdag", "donderdag", "vrijdag", "zaterdag"]
				},
				tr: { // Turkish
					months: [
						"Ocak", "Şubat", "Mart", "Nisan", "Mayıs", "Haziran", "Temmuz", "Ağustos", "Eylül", "Ekim", "Kasım", "Aralık"
					],
					dayOfWeekShort: [
						"Paz", "Pts", "Sal", "Çar", "Per", "Cum", "Cts"
					],
					dayOfWeek: ["Pazar", "Pazartesi", "Salı", "Çarşamba", "Perşembe", "Cuma", "Cumartesi"]
				},
				fr: { //French
					months: [
						"Janvier", "Février", "Mars", "Avril", "Mai", "Juin", "Juillet", "Août", "Septembre", "Octobre", "Novembre", "Décembre"
					],
					dayOfWeekShort: [
						"Dim", "Lun", "Mar", "Mer", "Jeu", "Ven", "Sam"
					],
					dayOfWeek: ["dimanche", "lundi", "mardi", "mercredi", "jeudi", "vendredi", "samedi"]
				},
				es: { // Spanish
					months: [
						"Enero", "Febrero", "Marzo", "Abril", "Mayo", "Junio", "Julio", "Agosto", "Septiembre", "Octubre", "Noviembre", "Diciembre"
					],
					dayOfWeekShort: [
						"Dom", "Lun", "Mar", "Mié", "Jue", "Vie", "Sáb"
					],
					dayOfWeek: ["Domingo", "Lunes", "Martes", "Miércoles", "Jueves", "Viernes", "Sábado"]
				},
				th: { // Thai
					months: [
						'มกราคม', 'กุมภาพันธ์', 'มีนาคม', 'เมษายน', 'พฤษภาคม', 'มิถุนายน', 'กรกฎาคม', 'สิงหาคม', 'กันยายน', 'ตุลาคม', 'พฤศจิกายน', 'ธันวาคม'
					],
					dayOfWeekShort: [
						'อา.', 'จ.', 'อ.', 'พ.', 'พฤ.', 'ศ.', 'ส.'
					],
					dayOfWeek: ["อาทิตย์", "จันทร์", "อังคาร", "พุธ", "พฤหัส", "ศุกร์", "เสาร์", "อาทิตย์"]
				},
				pl: { // Polish
					months: [
						"styczeń", "luty", "marzec", "kwiecień", "maj", "czerwiec", "lipiec", "sierpień", "wrzesień", "październik", "listopad", "grudzień"
					],
					dayOfWeekShort: [
						"nd", "pn", "wt", "śr", "cz", "pt", "sb"
					],
					dayOfWeek: ["niedziela", "poniedziałek", "wtorek", "środa", "czwartek", "piątek", "sobota"]
				},
				pt: { // Portuguese
					months: [
						"Janeiro", "Fevereiro", "Março", "Abril", "Maio", "Junho", "Julho", "Agosto", "Setembro", "Outubro", "Novembro", "Dezembro"
					],
					dayOfWeekShort: [
						"Dom", "Seg", "Ter", "Qua", "Qui", "Sex", "Sab"
					],
					dayOfWeek: ["Domingo", "Segunda", "Terça", "Quarta", "Quinta", "Sexta", "Sábado"]
				},
				ch: { // Simplified Chinese
					months: [
						"一月", "二月", "三月", "四月", "五月", "六月", "七月", "八月", "九月", "十月", "十一月", "十二月"
					],
					dayOfWeekShort: [
						"日", "一", "二", "三", "四", "五", "六"
					]
				},
				se: { // Swedish
					months: [
						"Januari", "Februari", "Mars", "April", "Maj", "Juni", "Juli", "Augusti", "September",  "Oktober", "November", "December"
					],
					dayOfWeekShort: [
						"Sön", "Mån", "Tis", "Ons", "Tor", "Fre", "Lör"
					]
				},
				km: { // Khmer (ភាសាខ្មែរ)
					months: [
						"មករា​", "កុម្ភៈ", "មិនា​", "មេសា​", "ឧសភា​", "មិថុនា​", "កក្កដា​", "សីហា​", "កញ្ញា​", "តុលា​", "វិច្ឆិកា", "ធ្នូ​"
					],
					dayOfWeekShort: ["អាទិ​", "ច័ន្ទ​", "អង្គារ​", "ពុធ​", "ព្រហ​​", "សុក្រ​", "សៅរ៍"],
					dayOfWeek: ["អាទិត្យ​", "ច័ន្ទ​", "អង្គារ​", "ពុធ​", "ព្រហស្បតិ៍​", "សុក្រ​", "សៅរ៍"]
				},
				kr: { // Korean
					months: [
						"1월", "2월", "3월", "4월", "5월", "6월", "7월", "8월", "9월", "10월", "11월", "12월"
					],
					dayOfWeekShort: [
						"일", "월", "화", "수", "목", "금", "토"
					],
					dayOfWeek: ["일요일", "월요일", "화요일", "수요일", "목요일", "금요일", "토요일"]
				},
				it: { // Italian
					months: [
						"Gennaio", "Febbraio", "Marzo", "Aprile", "Maggio", "Giugno", "Luglio", "Agosto", "Settembre", "Ottobre", "Novembre", "Dicembre"
					],
					dayOfWeekShort: [
						"Dom", "Lun", "Mar", "Mer", "Gio", "Ven", "Sab"
					],
					dayOfWeek: ["Domenica", "Lunedì", "Martedì", "Mercoledì", "Giovedì", "Venerdì", "Sabato"]
				},
				da: { // Dansk
					months: [
						"Januar", "Februar", "Marts", "April", "Maj", "Juni", "Juli", "August", "September", "Oktober", "November", "December"
					],
					dayOfWeekShort: [
						"Søn", "Man", "Tir", "Ons", "Tor", "Fre", "Lør"
					],
					dayOfWeek: ["søndag", "mandag", "tirsdag", "onsdag", "torsdag", "fredag", "lørdag"]
				},
				no: { // Norwegian
					months: [
						"Januar", "Februar", "Mars", "April", "Mai", "Juni", "Juli", "August", "September", "Oktober", "November", "Desember"
					],
					dayOfWeekShort: [
						"Søn", "Man", "Tir", "Ons", "Tor", "Fre", "Lør"
					],
					dayOfWeek: ['Søndag', 'Mandag', 'Tirsdag', 'Onsdag', 'Torsdag', 'Fredag', 'Lørdag']
				},
				ja: { // Japanese
					months: [
						"1月", "2月", "3月", "4月", "5月", "6月", "7月", "8月", "9月", "10月", "11月", "12月"
					],
					dayOfWeekShort: [
						"日", "月", "火", "水", "木", "金", "土"
					],
					dayOfWeek: ["日曜", "月曜", "火曜", "水曜", "木曜", "金曜", "土曜"]
				},
				vi: { // Vietnamese
					months: [
						"Tháng 1", "Tháng 2", "Tháng 3", "Tháng 4", "Tháng 5", "Tháng 6", "Tháng 7", "Tháng 8", "Tháng 9", "Tháng 10", "Tháng 11", "Tháng 12"
					],
					dayOfWeekShort: [
						"CN", "T2", "T3", "T4", "T5", "T6", "T7"
					],
					dayOfWeek: ["Chủ nhật", "Thứ hai", "Thứ ba", "Thứ tư", "Thứ năm", "Thứ sáu", "Thứ bảy"]
				},
				sl: { // Slovenščina
					months: [
						"Januar", "Februar", "Marec", "April", "Maj", "Junij", "Julij", "Avgust", "September", "Oktober", "November", "December"
					],
					dayOfWeekShort: [
						"Ned", "Pon", "Tor", "Sre", "Čet", "Pet", "Sob"
					],
					dayOfWeek: ["Nedelja", "Ponedeljek", "Torek", "Sreda", "Četrtek", "Petek", "Sobota"]
				},
				cs: { // Čeština
					months: [
						"Leden", "Únor", "Březen", "Duben", "Květen", "Červen", "Červenec", "Srpen", "Září", "Říjen", "Listopad", "Prosinec"
					],
					dayOfWeekShort: [
						"Ne", "Po", "Út", "St", "Čt", "Pá", "So"
					]
				},
				hu: { // Hungarian
					months: [
						"Január", "Február", "Március", "Április", "Május", "Június", "Július", "Augusztus", "Szeptember", "Október", "November", "December"
					],
					dayOfWeekShort: [
						"Va", "Hé", "Ke", "Sze", "Cs", "Pé", "Szo"
					],
					dayOfWeek: ["vasárnap", "hétfő", "kedd", "szerda", "csütörtök", "péntek", "szombat"]
				},
				az: { //Azerbaijanian (Azeri)
					months: [
						"Yanvar", "Fevral", "Mart", "Aprel", "May", "Iyun", "Iyul", "Avqust", "Sentyabr", "Oktyabr", "Noyabr", "Dekabr"
					],
					dayOfWeekShort: [
						"B", "Be", "Ça", "Ç", "Ca", "C", "Ş"
					],
					dayOfWeek: ["Bazar", "Bazar ertəsi", "Çərşənbə axşamı", "Çərşənbə", "Cümə axşamı", "Cümə", "Şənbə"]
				},
				bs: { //Bosanski
					months: [
						"Januar", "Februar", "Mart", "April", "Maj", "Jun", "Jul", "Avgust", "Septembar", "Oktobar", "Novembar", "Decembar"
					],
					dayOfWeekShort: [
						"Ned", "Pon", "Uto", "Sri", "Čet", "Pet", "Sub"
					],
					dayOfWeek: ["Nedjelja","Ponedjeljak", "Utorak", "Srijeda", "Četvrtak", "Petak", "Subota"]
				},
				ca: { //Català
					months: [
						"Gener", "Febrer", "Març", "Abril", "Maig", "Juny", "Juliol", "Agost", "Setembre", "Octubre", "Novembre", "Desembre"
					],
					dayOfWeekShort: [
						"Dg", "Dl", "Dt", "Dc", "Dj", "Dv", "Ds"
					],
					dayOfWeek: ["Diumenge", "Dilluns", "Dimarts", "Dimecres", "Dijous", "Divendres", "Dissabte"]
				},
				'en-GB': { //English (British)
					months: [
						"January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"
					],
					dayOfWeekShort: [
						"Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"
					],
					dayOfWeek: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
				},
				et: { //"Eesti"
					months: [
						"Jaanuar", "Veebruar", "Märts", "Aprill", "Mai", "Juuni", "Juuli", "August", "September", "Oktoober", "November", "Detsember"
					],
					dayOfWeekShort: [
						"P", "E", "T", "K", "N", "R", "L"
					],
					dayOfWeek: ["Pühapäev", "Esmaspäev", "Teisipäev", "Kolmapäev", "Neljapäev", "Reede", "Laupäev"]
				},
				eu: { //Euskara
					months: [
						"Urtarrila", "Otsaila", "Martxoa", "Apirila", "Maiatza", "Ekaina", "Uztaila", "Abuztua", "Iraila", "Urria", "Azaroa", "Abendua"
					],
					dayOfWeekShort: [
						"Ig.", "Al.", "Ar.", "Az.", "Og.", "Or.", "La."
					],
					dayOfWeek: ['Igandea', 'Astelehena', 'Asteartea', 'Asteazkena', 'Osteguna', 'Ostirala', 'Larunbata']
				},
				fi: { //Finnish (Suomi)
					months: [
						"Tammikuu", "Helmikuu", "Maaliskuu", "Huhtikuu", "Toukokuu", "Kesäkuu", "Heinäkuu", "Elokuu", "Syyskuu", "Lokakuu", "Marraskuu", "Joulukuu"
					],
					dayOfWeekShort: [
						"Su", "Ma", "Ti", "Ke", "To", "Pe", "La"
					],
					dayOfWeek: ["sunnuntai", "maanantai", "tiistai", "keskiviikko", "torstai", "perjantai", "lauantai"]
				},
				gl: { //Galego
					months: [
						"Xan", "Feb", "Maz", "Abr", "Mai", "Xun", "Xul", "Ago", "Set", "Out", "Nov", "Dec"
					],
					dayOfWeekShort: [
						"Dom", "Lun", "Mar", "Mer", "Xov", "Ven", "Sab"
					],
					dayOfWeek: ["Domingo", "Luns", "Martes", "Mércores", "Xoves", "Venres", "Sábado"]
				},
				hr: { //Hrvatski
					months: [
						"Siječanj", "Veljača", "Ožujak", "Travanj", "Svibanj", "Lipanj", "Srpanj", "Kolovoz", "Rujan", "Listopad", "Studeni", "Prosinac"
					],
					dayOfWeekShort: [
						"Ned", "Pon", "Uto", "Sri", "Čet", "Pet", "Sub"
					],
					dayOfWeek: ["Nedjelja", "Ponedjeljak", "Utorak", "Srijeda", "Četvrtak", "Petak", "Subota"]
				},
				ko: { //Korean (한국어)
					months: [
						"1월", "2월", "3월", "4월", "5월", "6월", "7월", "8월", "9월", "10월", "11월", "12월"
					],
					dayOfWeekShort: [
						"일", "월", "화", "수", "목", "금", "토"
					],
					dayOfWeek: ["일요일", "월요일", "화요일", "수요일", "목요일", "금요일", "토요일"]
				},
				lt: { //Lithuanian (lietuvių)
					months: [
						"Sausio", "Vasario", "Kovo", "Balandžio", "Gegužės", "Birželio", "Liepos", "Rugpjūčio", "Rugsėjo", "Spalio", "Lapkričio", "Gruodžio"
					],
					dayOfWeekShort: [
						"Sek", "Pir", "Ant", "Tre", "Ket", "Pen", "Šeš"
					],
					dayOfWeek: ["Sekmadienis", "Pirmadienis", "Antradienis", "Trečiadienis", "Ketvirtadienis", "Penktadienis", "Šeštadienis"]
				},
				lv: { //Latvian (Latviešu)
					months: [
						"Janvāris", "Februāris", "Marts", "Aprīlis ", "Maijs", "Jūnijs", "Jūlijs", "Augusts", "Septembris", "Oktobris", "Novembris", "Decembris"
					],
					dayOfWeekShort: [
						"Sv", "Pr", "Ot", "Tr", "Ct", "Pk", "St"
					],
					dayOfWeek: ["Svētdiena", "Pirmdiena", "Otrdiena", "Trešdiena", "Ceturtdiena", "Piektdiena", "Sestdiena"]
				},
				mk: { //Macedonian (Македонски)
					months: [
						"јануари", "февруари", "март", "април", "мај", "јуни", "јули", "август", "септември", "октомври", "ноември", "декември"
					],
					dayOfWeekShort: [
						"нед", "пон", "вто", "сре", "чет", "пет", "саб"
					],
					dayOfWeek: ["Недела", "Понеделник", "Вторник", "Среда", "Четврток", "Петок", "Сабота"]
				},
				mn: { //Mongolian (Монгол)
					months: [
						"1-р сар", "2-р сар", "3-р сар", "4-р сар", "5-р сар", "6-р сар", "7-р сар", "8-р сар", "9-р сар", "10-р сар", "11-р сар", "12-р сар"
					],
					dayOfWeekShort: [
						"Дав", "Мяг", "Лха", "Пүр", "Бсн", "Бям", "Ням"
					],
					dayOfWeek: ["Даваа", "Мягмар", "Лхагва", "Пүрэв", "Баасан", "Бямба", "Ням"]
				},
				'pt-BR': { //Português(Brasil)
					months: [
						"Janeiro", "Fevereiro", "Março", "Abril", "Maio", "Junho", "Julho", "Agosto", "Setembro", "Outubro", "Novembro", "Dezembro"
					],
					dayOfWeekShort: [
						"Dom", "Seg", "Ter", "Qua", "Qui", "Sex", "Sáb"
					],
					dayOfWeek: ["Domingo", "Segunda", "Terça", "Quarta", "Quinta", "Sexta", "Sábado"]
				},
				sk: { //Slovenčina
					months: [
						"Január", "Február", "Marec", "Apríl", "Máj", "Jún", "Júl", "August", "September", "Október", "November", "December"
					],
					dayOfWeekShort: [
						"Ne", "Po", "Ut", "St", "Št", "Pi", "So"
					],
					dayOfWeek: ["Nedeľa", "Pondelok", "Utorok", "Streda", "Štvrtok", "Piatok", "Sobota"]
				},
				sq: { //Albanian (Shqip)
					months: [
						"Janar", "Shkurt", "Mars", "Prill", "Maj", "Qershor", "Korrik", "Gusht", "Shtator", "Tetor", "Nëntor", "Dhjetor"
					],
					dayOfWeekShort: [
						"Die", "Hën", "Mar", "Mër", "Enj", "Pre", "Shtu"
					],
					dayOfWeek: ["E Diel", "E Hënë", "E Martē", "E Mërkurë", "E Enjte", "E Premte", "E Shtunë"]
				},
				'sr-YU': { //Serbian (Srpski)
					months: [
						"Januar", "Februar", "Mart", "April", "Maj", "Jun", "Jul", "Avgust", "Septembar", "Oktobar", "Novembar", "Decembar"
					],
					dayOfWeekShort: [
						"Ned", "Pon", "Uto", "Sre", "čet", "Pet", "Sub"
					],
					dayOfWeek: ["Nedelja","Ponedeljak", "Utorak", "Sreda", "Četvrtak", "Petak", "Subota"]
				},
				sr: { //Serbian Cyrillic (Српски)
					months: [
						"јануар", "фебруар", "март", "април", "мај", "јун", "јул", "август", "септембар", "октобар", "новембар", "децембар"
					],
					dayOfWeekShort: [
						"нед", "пон", "уто", "сре", "чет", "пет", "суб"
					],
					dayOfWeek: ["Недеља","Понедељак", "Уторак", "Среда", "Четвртак", "Петак", "Субота"]
				},
				sv: { //Svenska
					months: [
						"Januari", "Februari", "Mars", "April", "Maj", "Juni", "Juli", "Augusti", "September", "Oktober", "November", "December"
					],
					dayOfWeekShort: [
						"Sön", "Mån", "Tis", "Ons", "Tor", "Fre", "Lör"
					],
					dayOfWeek: ["Söndag", "Måndag", "Tisdag", "Onsdag", "Torsdag", "Fredag", "Lördag"]
				},
				'zh-TW': { //Traditional Chinese (繁體中文)
					months: [
						"一月", "二月", "三月", "四月", "五月", "六月", "七月", "八月", "九月", "十月", "十一月", "十二月"
					],
					dayOfWeekShort: [
						"日", "一", "二", "三", "四", "五", "六"
					],
					dayOfWeek: ["星期日", "星期一", "星期二", "星期三", "星期四", "星期五", "星期六"]
				},
				zh: { //Simplified Chinese (简体中文)
					months: [
						"一月", "二月", "三月", "四月", "五月", "六月", "七月", "八月", "九月", "十月", "十一月", "十二月"
					],
					dayOfWeekShort: [
						"日", "一", "二", "三", "四", "五", "六"
					],
					dayOfWeek: ["星期日", "星期一", "星期二", "星期三", "星期四", "星期五", "星期六"]
				},
				ug:{ // Uyghur(ئۇيغۇرچە)
					months: [
						"1-ئاي","2-ئاي","3-ئاي","4-ئاي","5-ئاي","6-ئاي","7-ئاي","8-ئاي","9-ئاي","10-ئاي","11-ئاي","12-ئاي"
					],
					dayOfWeek: [
						"يەكشەنبە", "دۈشەنبە","سەيشەنبە","چارشەنبە","پەيشەنبە","جۈمە","شەنبە"
					]
				},
				he: { //Hebrew (עברית)
					months: [
						'ינואר', 'פברואר', 'מרץ', 'אפריל', 'מאי', 'יוני', 'יולי', 'אוגוסט', 'ספטמבר', 'אוקטובר', 'נובמבר', 'דצמבר'
					],
					dayOfWeekShort: [
						'א\'', 'ב\'', 'ג\'', 'ד\'', 'ה\'', 'ו\'', 'שבת'
					],
					dayOfWeek: ["ראשון", "שני", "שלישי", "רביעי", "חמישי", "שישי", "שבת", "ראשון"]
				},
				hy: { // Armenian
					months: [
						"Հունվար", "Փետրվար", "Մարտ", "Ապրիլ", "Մայիս", "Հունիս", "Հուլիս", "Օգոստոս", "Սեպտեմբեր", "Հոկտեմբեր", "Նոյեմբեր", "Դեկտեմբեր"
					],
					dayOfWeekShort: [
						"Կի", "Երկ", "Երք", "Չոր", "Հնգ", "Ուրբ", "Շբթ"
					],
					dayOfWeek: ["Կիրակի", "Երկուշաբթի", "Երեքշաբթի", "Չորեքշաբթի", "Հինգշաբթի", "Ուրբաթ", "Շաբաթ"]
				},
				kg: { // Kyrgyz
					months: [
						'Үчтүн айы', 'Бирдин айы', 'Жалган Куран', 'Чын Куран', 'Бугу', 'Кулжа', 'Теке', 'Баш Оона', 'Аяк Оона', 'Тогуздун айы', 'Жетинин айы', 'Бештин айы'
					],
					dayOfWeekShort: [
						"Жек", "Дүй", "Шей", "Шар", "Бей", "Жум", "Ише"
					],
					dayOfWeek: [
						"Жекшемб", "Дүйшөмб", "Шейшемб", "Шаршемб", "Бейшемби", "Жума", "Ишенб"
					]
				},
				rm: { // Romansh
					months: [
						"Schaner", "Favrer", "Mars", "Avrigl", "Matg", "Zercladur", "Fanadur", "Avust", "Settember", "October", "November", "December"
					],
					dayOfWeekShort: [
						"Du", "Gli", "Ma", "Me", "Gie", "Ve", "So"
					],
					dayOfWeek: [
						"Dumengia", "Glindesdi", "Mardi", "Mesemna", "Gievgia", "Venderdi", "Sonda"
					]
				},
				ka: { // Georgian
					months: [
						'იანვარი', 'თებერვალი', 'მარტი', 'აპრილი', 'მაისი', 'ივნისი', 'ივლისი', 'აგვისტო', 'სექტემბერი', 'ოქტომბერი', 'ნოემბერი', 'დეკემბერი'
					],
					dayOfWeekShort: [
						"კვ", "ორშ", "სამშ", "ოთხ", "ხუთ", "პარ", "შაბ"
					],
					dayOfWeek: ["კვირა", "ორშაბათი", "სამშაბათი", "ოთხშაბათი", "ხუთშაბათი", "პარასკევი", "შაბათი"]
				}
			},
	
			ownerDocument: document,
			contentWindow: window,
	
			value: '',
			rtl: false,
	
			format:	'Y/m/d H:i',
			formatTime:	'H:i',
			formatDate:	'Y/m/d',
	
			startDate:	false, // new Date(), '1986/12/08', '-1970/01/05','-1970/01/05',
			step: 60,
			monthChangeSpinner: true,
	
			closeOnDateSelect: false,
			closeOnTimeSelect: true,
			closeOnWithoutClick: true,
			closeOnInputClick: true,
			openOnFocus: true,
	
			timepicker: true,
			datepicker: true,
			weeks: false,
	
			defaultTime: false,	// use formatTime format (ex. '10:00' for formatTime:	'H:i')
			defaultDate: false,	// use formatDate format (ex new Date() or '1986/12/08' or '-1970/01/05' or '-1970/01/05')
	
			minDate: false,
			maxDate: false,
			minTime: false,
			maxTime: false,
			minDateTime: false,
			maxDateTime: false,
	
			allowTimes: [],
			opened: false,
			initTime: true,
			inline: false,
			theme: '',
			touchMovedThreshold: 5,
	
			onSelectDate: function () {},
			onSelectTime: function () {},
			onChangeMonth: function () {},
			onGetWeekOfYear: function () {},
			onChangeYear: function () {},
			onChangeDateTime: function () {},
			onShow: function () {},
			onClose: function () {},
			onGenerate: function () {},
	
			withoutCopyright: true,
			inverseButton: false,
			hours12: false,
			next: 'xdsoft_next',
			prev : 'xdsoft_prev',
			dayOfWeekStart: 0,
			parentID: 'body',
			timeHeightInTimePicker: 25,
			timepickerScrollbar: true,
			todayButton: true,
			prevButton: true,
			nextButton: true,
			defaultSelect: true,
	
			scrollMonth: true,
			scrollTime: true,
			scrollInput: true,
	
			lazyInit: false,
			mask: false,
			validateOnBlur: true,
			allowBlank: true,
			yearStart: 1950,
			yearEnd: 2050,
			monthStart: 0,
			monthEnd: 11,
			style: '',
			id: '',
			fixed: false,
			roundTime: 'round', // ceil, floor
			className: '',
			weekends: [],
			highlightedDates: [],
			highlightedPeriods: [],
			allowDates : [],
			allowDateRe : null,
			disabledDates : [],
			disabledWeekDays: [],
			yearOffset: 0,
			beforeShowDay: null,
	
			enterLikeTab: true,
	        showApplyButton: false,
	        insideParent: false,
		};
	
		var dateHelper = null,
			defaultDateHelper = null,
			globalLocaleDefault = 'en',
			globalLocale = 'en';
	
		var dateFormatterOptionsDefault = {
			meridiem: ['AM', 'PM']
		};
	
		var initDateFormatter = function(){
			var locale = default_options.i18n[globalLocale],
				opts = {
					days: locale.dayOfWeek,
					daysShort: locale.dayOfWeekShort,
					months: locale.months,
					monthsShort: $.map(locale.months, function(n){ return n.substring(0, 3) })
				};
	
			if (typeof DateFormatter === 'function') {
				dateHelper = defaultDateHelper = new DateFormatter({
					dateSettings: $.extend({}, dateFormatterOptionsDefault, opts)
				});
			}
		};
	
		var dateFormatters = {
			moment: {
				default_options:{
					format: 'YYYY/MM/DD HH:mm',
					formatDate: 'YYYY/MM/DD',
					formatTime: 'HH:mm',
				},
				formatter: {
					parseDate: function (date, format) {
						if(isFormatStandard(format)){
							return defaultDateHelper.parseDate(date, format);
						} 
						var d = moment(date, format);
						return d.isValid() ? d.toDate() : false;
					},
	
					formatDate: function (date, format) {
						if(isFormatStandard(format)){
							return defaultDateHelper.formatDate(date, format);
						} 
						return moment(date).format(format);
					},
	
					formatMask: function(format){
						return format
							.replace(/Y{4}/g, '9999')
							.replace(/Y{2}/g, '99')
							.replace(/M{2}/g, '19')
							.replace(/D{2}/g, '39')
							.replace(/H{2}/g, '29')
							.replace(/m{2}/g, '59')
							.replace(/s{2}/g, '59');
					},
				}
			}
		}
	
		// for locale settings
		$.datetimepicker = {
			setLocale: function(locale){
				var newLocale = default_options.i18n[locale] ? locale : globalLocaleDefault;
				if (globalLocale !== newLocale) {
					globalLocale = newLocale;
					// reinit date formatter
					initDateFormatter();
				}
			},
	
			setDateFormatter: function(dateFormatter) {
				if(typeof dateFormatter === 'string' && dateFormatters.hasOwnProperty(dateFormatter)){
					var df = dateFormatters[dateFormatter];
					$.extend(default_options, df.default_options);
					dateHelper = df.formatter; 
				}
				else {
					dateHelper = dateFormatter;
				}
			},
		};
	
		var standardFormats = {
			RFC_2822: 'D, d M Y H:i:s O',
			ATOM: 'Y-m-d\TH:i:sP',
			ISO_8601: 'Y-m-d\TH:i:sO',
			RFC_822: 'D, d M y H:i:s O',
			RFC_850: 'l, d-M-y H:i:s T',
			RFC_1036: 'D, d M y H:i:s O',
			RFC_1123: 'D, d M Y H:i:s O',
			RSS: 'D, d M Y H:i:s O',
			W3C: 'Y-m-d\TH:i:sP'
		}
	
		var isFormatStandard = function(format){
			return Object.values(standardFormats).indexOf(format) === -1 ? false : true;
		}
	
		$.extend($.datetimepicker, standardFormats);
	
		// first init date formatter
		initDateFormatter();
	
		// fix for ie8
		if (!window.getComputedStyle) {
			window.getComputedStyle = function (el) {
				this.el = el;
				this.getPropertyValue = function (prop) {
					var re = /(-([a-z]))/g;
					if (prop === 'float') {
						prop = 'styleFloat';
					}
					if (re.test(prop)) {
						prop = prop.replace(re, function (a, b, c) {
							return c.toUpperCase();
						});
					}
					return el.currentStyle[prop] || null;
				};
				return this;
			};
		}
		if (!Array.prototype.indexOf) {
			Array.prototype.indexOf = function (obj, start) {
				var i, j;
				for (i = (start || 0), j = this.length; i < j; i += 1) {
					if (this[i] === obj) { return i; }
				}
				return -1;
			};
		}
	
		Date.prototype.countDaysInMonth = function () {
			return new Date(this.getFullYear(), this.getMonth() + 1, 0).getDate();
		};
	
		$.fn.xdsoftScroller = function (options, percent) {
			return this.each(function () {
				var timeboxparent = $(this),
					pointerEventToXY = function (e) {
						var out = {x: 0, y: 0},
							touch;
						if (e.type === 'touchstart' || e.type === 'touchmove' || e.type === 'touchend' || e.type === 'touchcancel') {
							touch  = e.originalEvent.touches[0] || e.originalEvent.changedTouches[0];
							out.x = touch.clientX;
							out.y = touch.clientY;
						} else if (e.type === 'mousedown' || e.type === 'mouseup' || e.type === 'mousemove' || e.type === 'mouseover' || e.type === 'mouseout' || e.type === 'mouseenter' || e.type === 'mouseleave') {
							out.x = e.clientX;
							out.y = e.clientY;
						}
						return out;
					},
					getWheelDelta = function (e) {
						var deltaY = 0;
	
						if ('detail' in e) { deltaY = e.detail; }
						if ('wheelDelta' in e) { deltaY = -e.wheelDelta / 120; }
						if ('wheelDeltaY' in e) { deltaY = -e.wheelDeltaY / 120; }
						if ('axis' in e && e.axis === e.HORIZONTAL_AXIS) { deltaY = 0; }
	
						deltaY *= 10;
	
						if ('deltaY' in e) { deltaY = e.deltaY; }
	
						if (deltaY && e.deltaMode) {
							if (e.deltaMode === 1) {
								deltaY *= 40;
							} else {
								deltaY *= 800;
							}
						}
	
						return deltaY;
					},
					timebox,
					timeboxTop = 0,
					parentHeight,
					height,
					scrollbar,
					scroller,
					maximumOffset = 100,
					start = false,
					startY = 0,
					startTop = 0,
					h1 = 0,
					touchStart = false,
					startTopScroll = 0,
					calcOffset = function () {};
	
				if (percent === 'hide') {
					timeboxparent.find('.xdsoft_scrollbar').hide();
					return;
				}
	
				if (!$(this).hasClass('xdsoft_scroller_box')) {
					timebox = timeboxparent.children().eq(0);
					timeboxTop = Math.abs(parseInt(timebox.css('marginTop'), 10));
					parentHeight = timeboxparent[0].clientHeight;
					height = timebox[0].offsetHeight;
					scrollbar = $('<div class="xdsoft_scrollbar"></div>');
					scroller = $('<div class="xdsoft_scroller"></div>');
					scrollbar.append(scroller);
	
					timeboxparent.addClass('xdsoft_scroller_box').append(scrollbar);
					calcOffset = function calcOffset(event) {
						var offset = pointerEventToXY(event).y - startY + startTopScroll;
						if (offset < 0) {
							offset = 0;
						}
						if (offset + scroller[0].offsetHeight > h1) {
							offset = h1 - scroller[0].offsetHeight;
						}
						timeboxparent.trigger('scroll_element.xdsoft_scroller', [maximumOffset ? offset / maximumOffset : 0]);
					};
	
					scroller
						.on('touchstart.xdsoft_scroller mousedown.xdsoft_scroller', function (event) {
							if (!parentHeight) {
								timeboxparent.trigger('resize_scroll.xdsoft_scroller', [percent]);
							}
	
							startY = pointerEventToXY(event).y;
							startTopScroll = parseInt(scroller.css('marginTop'), 10);
							h1 = scrollbar[0].offsetHeight;
	
							if (event.type === 'mousedown' || event.type === 'touchstart') {
								if (options.ownerDocument) {
									$(options.ownerDocument.body).addClass('xdsoft_noselect');
								}
								$([options.ownerDocument.body, options.contentWindow]).on('touchend mouseup.xdsoft_scroller', function arguments_callee() {
									$([options.ownerDocument.body, options.contentWindow]).off('touchend mouseup.xdsoft_scroller', arguments_callee)
										.off('mousemove.xdsoft_scroller', calcOffset)
										.removeClass('xdsoft_noselect');
								});
								$(options.ownerDocument.body).on('mousemove.xdsoft_scroller', calcOffset);
							} else {
								touchStart = true;
								event.stopPropagation();
								event.preventDefault();
							}
						})
						.on('touchmove', function (event) {
							if (touchStart) {
								event.preventDefault();
								calcOffset(event);
							}
						})
						.on('touchend touchcancel', function () {
							touchStart =  false;
							startTopScroll = 0;
						});
	
					timeboxparent
						.on('scroll_element.xdsoft_scroller', function (event, percentage) {
							if (!parentHeight) {
								timeboxparent.trigger('resize_scroll.xdsoft_scroller', [percentage, true]);
							}
							percentage = percentage > 1 ? 1 : (percentage < 0 || isNaN(percentage)) ? 0 : percentage;
							timeboxTop = parseFloat(Math.abs((timebox[0].offsetHeight - parentHeight) * percentage).toFixed(4));
	
							scroller.css('marginTop', maximumOffset * percentage);
							timebox.css('marginTop', -timeboxTop);
						})
						.on('resize_scroll.xdsoft_scroller', function (event, percentage, noTriggerScroll) {
							var percent, sh;
							parentHeight = timeboxparent[0].clientHeight;
							height = timebox[0].offsetHeight;
							percent = parentHeight / height;
							sh = percent * scrollbar[0].offsetHeight;
							if (percent > 1) {
								scroller.hide();
							} else {
								scroller.show();
								scroller.css('height', parseInt(sh > 10 ? sh : 10, 10));
								maximumOffset = scrollbar[0].offsetHeight - scroller[0].offsetHeight;
								if (noTriggerScroll !== true) {
									timeboxparent.trigger('scroll_element.xdsoft_scroller', [percentage || timeboxTop / (height - parentHeight)]);
								}
							}
						});
	
					timeboxparent.on('mousewheel', function (event) {
						var deltaY = getWheelDelta(event.originalEvent);
						var top = Math.max(0, timeboxTop - deltaY);
						timeboxparent.trigger('scroll_element.xdsoft_scroller', [top / (height - parentHeight)]);
						event.stopPropagation();
						return false;
					});
	
					timeboxparent.on('touchstart', function (event) {
						start = pointerEventToXY(event);
						startTop = timeboxTop;
					});
	
					timeboxparent.on('touchmove', function (event) {
						if (start) {
							event.preventDefault();
							var coord = pointerEventToXY(event);
							timeboxparent.trigger('scroll_element.xdsoft_scroller', [(startTop - (coord.y - start.y)) / (height - parentHeight)]);
						}
					});
	
					timeboxparent.on('touchend touchcancel', function () {
						start = false;
						startTop = 0;
					});
				}
				timeboxparent.trigger('resize_scroll.xdsoft_scroller', [percent]);
			});
		};
	
		$.fn.datetimepicker = function (opt, opt2) {
			var result = this,
				KEY0 = 48,
				KEY9 = 57,
				_KEY0 = 96,
				_KEY9 = 105,
	            CTRLKEY = 17,
	            CMDKEY = 91,
				DEL = 46,
				ENTER = 13,
				ESC = 27,
				BACKSPACE = 8,
				ARROWLEFT = 37,
				ARROWUP = 38,
				ARROWRIGHT = 39,
				ARROWDOWN = 40,
				TAB = 9,
				F5 = 116,
				AKEY = 65,
				CKEY = 67,
				VKEY = 86,
				ZKEY = 90,
				YKEY = 89,
	            ctrlDown	=	false,
	            cmdDown = false,
				options = ($.isPlainObject(opt) || !opt) ? $.extend(true, {}, default_options, opt) : $.extend(true, {}, default_options),
	
				lazyInitTimer = 0,
				createDateTimePicker,
				destroyDateTimePicker,
	
				lazyInit = function (input) {
					input
						.on('open.xdsoft focusin.xdsoft mousedown.xdsoft touchstart', function initOnActionCallback() {
							if (input.is(':disabled') || input.data('xdsoft_datetimepicker')) {
								return;
							}
							clearTimeout(lazyInitTimer);
							lazyInitTimer = setTimeout(function () {
	
								if (!input.data('xdsoft_datetimepicker')) {
									createDateTimePicker(input);
								}
								input
									.off('open.xdsoft focusin.xdsoft mousedown.xdsoft touchstart', initOnActionCallback)
									.trigger('open.xdsoft');
							}, 100);
						});
				};
	
			createDateTimePicker = function (input) {
				var datetimepicker = $('<div class="xdsoft_datetimepicker xdsoft_noselect"></div>'),
					xdsoft_copyright = $('<div class="xdsoft_copyright"><a target="_blank" href="http://xdsoft.net/jqplugins/datetimepicker/">xdsoft.net</a></div>'),
					datepicker = $('<div class="xdsoft_datepicker active"></div>'),
					month_picker = $('<div class="xdsoft_monthpicker"><button type="button" class="xdsoft_prev"></button><button type="button" class="xdsoft_today_button"></button>' +
						'<div class="xdsoft_label xdsoft_month"><span></span><i></i></div>' +
						'<div class="xdsoft_label xdsoft_year"><span></span><i></i></div>' +
						'<button type="button" class="xdsoft_next"></button></div>'),
					calendar = $('<div class="xdsoft_calendar"></div>'),
					timepicker = $('<div class="xdsoft_timepicker active"><button type="button" class="xdsoft_prev"></button><div class="xdsoft_time_box"></div><button type="button" class="xdsoft_next"></button></div>'),
					timeboxparent = timepicker.find('.xdsoft_time_box').eq(0),
					timebox = $('<div class="xdsoft_time_variant"></div>'),
					applyButton = $('<button type="button" class="xdsoft_save_selected blue-gradient-button">Save Selected</button>'),
	
					monthselect = $('<div class="xdsoft_select xdsoft_monthselect"><div></div></div>'),
					yearselect = $('<div class="xdsoft_select xdsoft_yearselect"><div></div></div>'),
					triggerAfterOpen = false,
					XDSoft_datetime,
	
					xchangeTimer,
					timerclick,
					current_time_index,
					setPos,
					timer = 0,
					_xdsoft_datetime,
					forEachAncestorOf;
	
				if (options.id) {
					datetimepicker.attr('id', options.id);
				}
				if (options.style) {
					datetimepicker.attr('style', options.style);
				}
				if (options.weeks) {
					datetimepicker.addClass('xdsoft_showweeks');
				}
				if (options.rtl) {
					datetimepicker.addClass('xdsoft_rtl');
				}
	
				datetimepicker.addClass('xdsoft_' + options.theme);
				datetimepicker.addClass(options.className);
	
				month_picker
					.find('.xdsoft_month span')
					.after(monthselect);
				month_picker
					.find('.xdsoft_year span')
					.after(yearselect);
	
				month_picker
					.find('.xdsoft_month,.xdsoft_year')
					.on('touchstart mousedown.xdsoft', function (event) {
						var select = $(this).find('.xdsoft_select').eq(0),
							val = 0,
							top = 0,
							visible = select.is(':visible'),
							items,
							i;
	
						month_picker
							.find('.xdsoft_select')
							.hide();
						if (_xdsoft_datetime.currentTime) {
							val = _xdsoft_datetime.currentTime[$(this).hasClass('xdsoft_month') ? 'getMonth' : 'getFullYear']();
						}
	
						select[visible ? 'hide' : 'show']();
						for (items = select.find('div.xdsoft_option'), i = 0; i < items.length; i += 1) {
							if (items.eq(i).data('value') === val) {
								break;
							} else {
								top += items[0].offsetHeight;
							}
						}
	
						select.xdsoftScroller(options, top / (select.children()[0].offsetHeight - (select[0].clientHeight)));
						event.stopPropagation();
						return false;
					});
	
				var handleTouchMoved = function (event) {
					var evt = event.originalEvent;
					var touchPosition = evt.touches ? evt.touches[0] : evt;
					this.touchStartPosition = this.touchStartPosition || touchPosition;
					var xMovement = Math.abs(this.touchStartPosition.clientX - touchPosition.clientX);
					var yMovement = Math.abs(this.touchStartPosition.clientY - touchPosition.clientY);
					var distance = Math.sqrt(xMovement * xMovement + yMovement * yMovement);
					if(distance > options.touchMovedThreshold) {
						this.touchMoved = true;
					}
				}
	
				month_picker
					.find('.xdsoft_select')
					.xdsoftScroller(options)
					.on('touchstart mousedown.xdsoft', function (event) {
						var evt = event.originalEvent;
						this.touchMoved = false;
						this.touchStartPosition = evt.touches ? evt.touches[0] : evt;
						event.stopPropagation();
						event.preventDefault();
					})
					.on('touchmove', '.xdsoft_option', handleTouchMoved)
					.on('touchend mousedown.xdsoft', '.xdsoft_option', function () {
						if (!this.touchMoved) {
							if (_xdsoft_datetime.currentTime === undefined || _xdsoft_datetime.currentTime === null) {
								_xdsoft_datetime.currentTime = _xdsoft_datetime.now();
							}
	
							var year = _xdsoft_datetime.currentTime.getFullYear();
							if (_xdsoft_datetime && _xdsoft_datetime.currentTime) {
								_xdsoft_datetime.currentTime[$(this).parent().parent().hasClass('xdsoft_monthselect') ? 'setMonth' : 'setFullYear']($(this).data('value'));
							}
	
							$(this).parent().parent().hide();
	
							datetimepicker.trigger('xchange.xdsoft');
							if (options.onChangeMonth && $.isFunction(options.onChangeMonth)) {
								options.onChangeMonth.call(datetimepicker, _xdsoft_datetime.currentTime, datetimepicker.data('input'));
							}
	
							if (year !== _xdsoft_datetime.currentTime.getFullYear() && $.isFunction(options.onChangeYear)) {
								options.onChangeYear.call(datetimepicker, _xdsoft_datetime.currentTime, datetimepicker.data('input'));
							}
						}
					});
	
				datetimepicker.getValue = function () {
					return _xdsoft_datetime.getCurrentTime();
				};
	
				datetimepicker.setOptions = function (_options) {
					var highlightedDates = {};
	
					options = $.extend(true, {}, options, _options);
	
					if (_options.allowTimes && $.isArray(_options.allowTimes) && _options.allowTimes.length) {
						options.allowTimes = $.extend(true, [], _options.allowTimes);
					}
	
					if (_options.weekends && $.isArray(_options.weekends) && _options.weekends.length) {
						options.weekends = $.extend(true, [], _options.weekends);
					}
	
					if (_options.allowDates && $.isArray(_options.allowDates) && _options.allowDates.length) {
						options.allowDates = $.extend(true, [], _options.allowDates);
					}
	
					if (_options.allowDateRe && Object.prototype.toString.call(_options.allowDateRe)==="[object String]") {
						options.allowDateRe = new RegExp(_options.allowDateRe);
					}
	
					if (_options.highlightedDates && $.isArray(_options.highlightedDates) && _options.highlightedDates.length) {
						$.each(_options.highlightedDates, function (index, value) {
							var splitData = $.map(value.split(','), $.trim),
								exDesc,
								hDate = new HighlightedDate(dateHelper.parseDate(splitData[0], options.formatDate), splitData[1], splitData[2]), // date, desc, style
								keyDate = dateHelper.formatDate(hDate.date, options.formatDate);
							if (highlightedDates[keyDate] !== undefined) {
								exDesc = highlightedDates[keyDate].desc;
								if (exDesc && exDesc.length && hDate.desc && hDate.desc.length) {
									highlightedDates[keyDate].desc = exDesc + "\n" + hDate.desc;
								}
							} else {
								highlightedDates[keyDate] = hDate;
							}
						});
	
						options.highlightedDates = $.extend(true, [], highlightedDates);
					}
	
					if (_options.highlightedPeriods && $.isArray(_options.highlightedPeriods) && _options.highlightedPeriods.length) {
						highlightedDates = $.extend(true, [], options.highlightedDates);
						$.each(_options.highlightedPeriods, function (index, value) {
							var dateTest, // start date
								dateEnd,
								desc,
								hDate,
								keyDate,
								exDesc,
								style;
							if ($.isArray(value)) {
								dateTest = value[0];
								dateEnd = value[1];
								desc = value[2];
								style = value[3];
							}
							else {
								var splitData = $.map(value.split(','), $.trim);
								dateTest = dateHelper.parseDate(splitData[0], options.formatDate);
								dateEnd = dateHelper.parseDate(splitData[1], options.formatDate);
								desc = splitData[2];
								style = splitData[3];
							}
	
							while (dateTest <= dateEnd) {
								hDate = new HighlightedDate(dateTest, desc, style);
								keyDate = dateHelper.formatDate(dateTest, options.formatDate);
								dateTest.setDate(dateTest.getDate() + 1);
								if (highlightedDates[keyDate] !== undefined) {
									exDesc = highlightedDates[keyDate].desc;
									if (exDesc && exDesc.length && hDate.desc && hDate.desc.length) {
										highlightedDates[keyDate].desc = exDesc + "\n" + hDate.desc;
									}
								} else {
									highlightedDates[keyDate] = hDate;
								}
							}
						});
	
						options.highlightedDates = $.extend(true, [], highlightedDates);
					}
	
					if (_options.disabledDates && $.isArray(_options.disabledDates) && _options.disabledDates.length) {
						options.disabledDates = $.extend(true, [], _options.disabledDates);
					}
	
					if (_options.disabledWeekDays && $.isArray(_options.disabledWeekDays) && _options.disabledWeekDays.length) {
						options.disabledWeekDays = $.extend(true, [], _options.disabledWeekDays);
					}
	
					if ((options.open || options.opened) && (!options.inline)) {
						input.trigger('open.xdsoft');
					}
	
					if (options.inline) {
						triggerAfterOpen = true;
						datetimepicker.addClass('xdsoft_inline');
						input.after(datetimepicker).hide();
					}
	
					if (options.inverseButton) {
						options.next = 'xdsoft_prev';
						options.prev = 'xdsoft_next';
					}
	
					if (options.datepicker) {
						datepicker.addClass('active');
					} else {
						datepicker.removeClass('active');
					}
	
					if (options.timepicker) {
						timepicker.addClass('active');
					} else {
						timepicker.removeClass('active');
					}
	
					if (options.value) {
						_xdsoft_datetime.setCurrentTime(options.value);
						if (input && input.val) {
							input.val(_xdsoft_datetime.str);
						}
					}
	
					if (isNaN(options.dayOfWeekStart)) {
						options.dayOfWeekStart = 0;
					} else {
						options.dayOfWeekStart = parseInt(options.dayOfWeekStart, 10) % 7;
					}
	
					if (!options.timepickerScrollbar) {
						timeboxparent.xdsoftScroller(options, 'hide');
					}
	
					if (options.minDate && /^[\+\-](.*)$/.test(options.minDate)) {
						options.minDate = dateHelper.formatDate(_xdsoft_datetime.strToDateTime(options.minDate), options.formatDate);
					}
	
					if (options.maxDate &&  /^[\+\-](.*)$/.test(options.maxDate)) {
						options.maxDate = dateHelper.formatDate(_xdsoft_datetime.strToDateTime(options.maxDate), options.formatDate);
					}
	
	                if (options.minDateTime &&  /^\+(.*)$/.test(options.minDateTime)) {
	                	options.minDateTime = _xdsoft_datetime.strToDateTime(options.minDateTime).dateFormat(options.formatDate);
	                }
	
	                if (options.maxDateTime &&  /^\+(.*)$/.test(options.maxDateTime)) {
	                	options.maxDateTime = _xdsoft_datetime.strToDateTime(options.maxDateTime).dateFormat(options.formatDate);
	                }
	
					applyButton.toggle(options.showApplyButton);
	
					month_picker
						.find('.xdsoft_today_button')
						.css('visibility', !options.todayButton ? 'hidden' : 'visible');
	
					month_picker
						.find('.' + options.prev)
						.css('visibility', !options.prevButton ? 'hidden' : 'visible');
	
					month_picker
						.find('.' + options.next)
						.css('visibility', !options.nextButton ? 'hidden' : 'visible');
	
					setMask(options);
	
					if (options.validateOnBlur) {
						input
							.off('blur.xdsoft')
							.on('blur.xdsoft', function () {
								if (options.allowBlank && (!$.trim($(this).val()).length ||
										(typeof options.mask === "string" && $.trim($(this).val()) === options.mask.replace(/[0-9]/g, '_')))) {
									$(this).val(null);
									datetimepicker.data('xdsoft_datetime').empty();
								} else {
									var d = dateHelper.parseDate($(this).val(), options.format);
									if (d) { // parseDate() may skip some invalid parts like date or time, so make it clear for user: show parsed date/time
										$(this).val(dateHelper.formatDate(d, options.format));
									} else {
										var splittedHours   = +([$(this).val()[0], $(this).val()[1]].join('')),
											splittedMinutes = +([$(this).val()[2], $(this).val()[3]].join(''));
	
										// parse the numbers as 0312 => 03:12
										if (!options.datepicker && options.timepicker && splittedHours >= 0 && splittedHours < 24 && splittedMinutes >= 0 && splittedMinutes < 60) {
											$(this).val([splittedHours, splittedMinutes].map(function (item) {
												return item > 9 ? item : '0' + item;
											}).join(':'));
										} else {
											$(this).val(dateHelper.formatDate(_xdsoft_datetime.now(), options.format));
										}
									}
									datetimepicker.data('xdsoft_datetime').setCurrentTime($(this).val());
								}
	
								datetimepicker.trigger('changedatetime.xdsoft');
								datetimepicker.trigger('close.xdsoft');
							});
					}
					options.dayOfWeekStartPrev = (options.dayOfWeekStart === 0) ? 6 : options.dayOfWeekStart - 1;
	
					datetimepicker
						.trigger('xchange.xdsoft')
						.trigger('afterOpen.xdsoft');
				};
	
				datetimepicker
					.data('options', options)
					.on('touchstart mousedown.xdsoft', function (event) {
						event.stopPropagation();
						event.preventDefault();
						yearselect.hide();
						monthselect.hide();
						return false;
					});
	
				//scroll_element = timepicker.find('.xdsoft_time_box');
				timeboxparent.append(timebox);
				timeboxparent.xdsoftScroller(options);
	
				datetimepicker.on('afterOpen.xdsoft', function () {
					timeboxparent.xdsoftScroller(options);
				});
	
				datetimepicker
					.append(datepicker)
					.append(timepicker);
	
				if (options.withoutCopyright !== true) {
					datetimepicker
						.append(xdsoft_copyright);
				}
	
				datepicker
					.append(month_picker)
					.append(calendar)
					.append(applyButton);
	
	            if (options.insideParent) {
	                $(input).parent().append(datetimepicker);
	            } else {
	                $(options.parentID).append(datetimepicker);
	            }
	
				XDSoft_datetime = function () {
					var _this = this;
					_this.now = function (norecursion) {
						var d = new Date(),
							date,
							time;
	
						if (!norecursion && options.defaultDate) {
							date = _this.strToDateTime(options.defaultDate);
							d.setFullYear(date.getFullYear());
							d.setMonth(date.getMonth());
							d.setDate(date.getDate());
						}
	
						d.setFullYear(d.getFullYear());
	
						if (!norecursion && options.defaultTime) {
							time = _this.strtotime(options.defaultTime);
							d.setHours(time.getHours());
							d.setMinutes(time.getMinutes());
							d.setSeconds(time.getSeconds());
							d.setMilliseconds(time.getMilliseconds());
						}
						return d;
					};
	
					_this.isValidDate = function (d) {
						if (Object.prototype.toString.call(d) !== "[object Date]") {
							return false;
						}
						return !isNaN(d.getTime());
					};
	
					_this.setCurrentTime = function (dTime, requireValidDate) {
						if (typeof dTime === 'string') {
							_this.currentTime = _this.strToDateTime(dTime);
						}
						else if (_this.isValidDate(dTime)) {
							_this.currentTime = dTime;
						}
						else if (!dTime && !requireValidDate && options.allowBlank && !options.inline) {
							_this.currentTime = null;
						}
						else {
							_this.currentTime = _this.now();
						}
	
						datetimepicker.trigger('xchange.xdsoft');
					};
	
					_this.empty = function () {
						_this.currentTime = null;
					};
	
					_this.getCurrentTime = function () {
						return _this.currentTime;
					};
	
					_this.nextMonth = function () {
	
						if (_this.currentTime === undefined || _this.currentTime === null) {
							_this.currentTime = _this.now();
						}
	
						var month = _this.currentTime.getMonth() + 1,
							year;
						if (month === 12) {
							_this.currentTime.setFullYear(_this.currentTime.getFullYear() + 1);
							month = 0;
						}
	
						year = _this.currentTime.getFullYear();
	
						_this.currentTime.setDate(
							Math.min(
								new Date(_this.currentTime.getFullYear(), month + 1, 0).getDate(),
								_this.currentTime.getDate()
							)
						);
						_this.currentTime.setMonth(month);
	
						if (options.onChangeMonth && $.isFunction(options.onChangeMonth)) {
							options.onChangeMonth.call(datetimepicker, _xdsoft_datetime.currentTime, datetimepicker.data('input'));
						}
	
						if (year !== _this.currentTime.getFullYear() && $.isFunction(options.onChangeYear)) {
							options.onChangeYear.call(datetimepicker, _xdsoft_datetime.currentTime, datetimepicker.data('input'));
						}
	
						datetimepicker.trigger('xchange.xdsoft');
						return month;
					};
	
					_this.prevMonth = function () {
	
						if (_this.currentTime === undefined || _this.currentTime === null) {
							_this.currentTime = _this.now();
						}
	
						var month = _this.currentTime.getMonth() - 1;
						if (month === -1) {
							_this.currentTime.setFullYear(_this.currentTime.getFullYear() - 1);
							month = 11;
						}
						_this.currentTime.setDate(
							Math.min(
								new Date(_this.currentTime.getFullYear(), month + 1, 0).getDate(),
								_this.currentTime.getDate()
							)
						);
						_this.currentTime.setMonth(month);
						if (options.onChangeMonth && $.isFunction(options.onChangeMonth)) {
							options.onChangeMonth.call(datetimepicker, _xdsoft_datetime.currentTime, datetimepicker.data('input'));
						}
						datetimepicker.trigger('xchange.xdsoft');
						return month;
					};
	
					_this.getWeekOfYear = function (datetime) {
						if (options.onGetWeekOfYear && $.isFunction(options.onGetWeekOfYear)) {
							var week = options.onGetWeekOfYear.call(datetimepicker, datetime);
							if (typeof week !== 'undefined') {
								return week;
							}
						}
						var onejan = new Date(datetime.getFullYear(), 0, 1);
	
						//First week of the year is th one with the first Thursday according to ISO8601
						if (onejan.getDay() !== 4) {
							onejan.setMonth(0, 1 + ((4 - onejan.getDay()+ 7) % 7));
						}
	
						return Math.ceil((((datetime - onejan) / 86400000) + onejan.getDay() + 1) / 7);
					};
	
					_this.strToDateTime = function (sDateTime) {
						var tmpDate = [], timeOffset, currentTime;
	
						if (sDateTime && sDateTime instanceof Date && _this.isValidDate(sDateTime)) {
							return sDateTime;
						}
	
						tmpDate = /^([+-]{1})(.*)$/.exec(sDateTime);
	
						if (tmpDate) {
							tmpDate[2] = dateHelper.parseDate(tmpDate[2], options.formatDate);
						}
	
						if (tmpDate  && tmpDate[2]) {
							timeOffset = tmpDate[2].getTime() - (tmpDate[2].getTimezoneOffset()) * 60000;
							currentTime = new Date((_this.now(true)).getTime() + parseInt(tmpDate[1] + '1', 10) * timeOffset);
						} else {
							currentTime = sDateTime ? dateHelper.parseDate(sDateTime, options.format) : _this.now();
						}
	
						if (!_this.isValidDate(currentTime)) {
							currentTime = _this.now();
						}
	
						return currentTime;
					};
	
					_this.strToDate = function (sDate) {
						if (sDate && sDate instanceof Date && _this.isValidDate(sDate)) {
							return sDate;
						}
	
						var currentTime = sDate ? dateHelper.parseDate(sDate, options.formatDate) : _this.now(true);
						if (!_this.isValidDate(currentTime)) {
							currentTime = _this.now(true);
						}
						return currentTime;
					};
	
					_this.strtotime = function (sTime) {
						if (sTime && sTime instanceof Date && _this.isValidDate(sTime)) {
							return sTime;
						}
						var currentTime = sTime ? dateHelper.parseDate(sTime, options.formatTime) : _this.now(true);
						if (!_this.isValidDate(currentTime)) {
							currentTime = _this.now(true);
						}
						return currentTime;
					};
	
					_this.str = function () {
						var format = options.format;
						if (options.yearOffset) {
							format = format.replace('Y', _this.currentTime.getFullYear() + options.yearOffset);
							format = format.replace('y', String(_this.currentTime.getFullYear() + options.yearOffset).substring(2, 4));
						}
						return dateHelper.formatDate(_this.currentTime, format);
					};
					_this.currentTime = this.now();
				};
	
				_xdsoft_datetime = new XDSoft_datetime();
	
				applyButton.on('touchend click', function (e) {//pathbrite
					e.preventDefault();
					datetimepicker.data('changed', true);
					_xdsoft_datetime.setCurrentTime(getCurrentValue());
					input.val(_xdsoft_datetime.str());
					datetimepicker.trigger('close.xdsoft');
				});
				month_picker
					.find('.xdsoft_today_button')
					.on('touchend mousedown.xdsoft', function () {
						datetimepicker.data('changed', true);
						_xdsoft_datetime.setCurrentTime(0, true);
						datetimepicker.trigger('afterOpen.xdsoft');
					}).on('dblclick.xdsoft', function () {
					var currentDate = _xdsoft_datetime.getCurrentTime(), minDate, maxDate;
					currentDate = new Date(currentDate.getFullYear(), currentDate.getMonth(), currentDate.getDate());
					minDate = _xdsoft_datetime.strToDate(options.minDate);
					minDate = new Date(minDate.getFullYear(), minDate.getMonth(), minDate.getDate());
					if (currentDate < minDate) {
						return;
					}
					maxDate = _xdsoft_datetime.strToDate(options.maxDate);
					maxDate = new Date(maxDate.getFullYear(), maxDate.getMonth(), maxDate.getDate());
					if (currentDate > maxDate) {
						return;
					}
					input.val(_xdsoft_datetime.str());
					input.trigger('change');
					datetimepicker.trigger('close.xdsoft');
				});
				month_picker
					.find('.xdsoft_prev,.xdsoft_next')
					.on('touchend mousedown.xdsoft', function () {
						var $this = $(this),
							timer = 0,
							stop = false;
	
						(function arguments_callee1(v) {
							if ($this.hasClass(options.next)) {
								_xdsoft_datetime.nextMonth();
							} else if ($this.hasClass(options.prev)) {
								_xdsoft_datetime.prevMonth();
							}
							if (options.monthChangeSpinner) {
								if (!stop) {
									timer = setTimeout(arguments_callee1, v || 100);
								}
							}
						}(500));
	
						$([options.ownerDocument.body, options.contentWindow]).on('touchend mouseup.xdsoft', function arguments_callee2() {
							clearTimeout(timer);
							stop = true;
							$([options.ownerDocument.body, options.contentWindow]).off('touchend mouseup.xdsoft', arguments_callee2);
						});
					});
	
				timepicker
					.find('.xdsoft_prev,.xdsoft_next')
					.on('touchend mousedown.xdsoft', function () {
						var $this = $(this),
							timer = 0,
							stop = false,
							period = 110;
						(function arguments_callee4(v) {
							var pheight = timeboxparent[0].clientHeight,
								height = timebox[0].offsetHeight,
								top = Math.abs(parseInt(timebox.css('marginTop'), 10));
							if ($this.hasClass(options.next) && (height - pheight) - options.timeHeightInTimePicker >= top) {
								timebox.css('marginTop', '-' + (top + options.timeHeightInTimePicker) + 'px');
							} else if ($this.hasClass(options.prev) && top - options.timeHeightInTimePicker >= 0) {
								timebox.css('marginTop', '-' + (top - options.timeHeightInTimePicker) + 'px');
							}
							/**
							 * Fixed bug:
							 * When using css3 transition, it will cause a bug that you cannot scroll the timepicker list.
							 * The reason is that the transition-duration time, if you set it to 0, all things fine, otherwise, this
							 * would cause a bug when you use jquery.css method.
							 * Let's say: * { transition: all .5s ease; }
							 * jquery timebox.css('marginTop') will return the original value which is before you clicking the next/prev button,
							 * meanwhile the timebox[0].style.marginTop will return the right value which is after you clicking the
							 * next/prev button.
							 *
							 * What we should do:
							 * Replace timebox.css('marginTop') with timebox[0].style.marginTop.
							 */
							timeboxparent.trigger('scroll_element.xdsoft_scroller', [Math.abs(parseInt(timebox[0].style.marginTop, 10) / (height - pheight))]);
							period = (period > 10) ? 10 : period - 10;
							if (!stop) {
								timer = setTimeout(arguments_callee4, v || period);
							}
						}(500));
						$([options.ownerDocument.body, options.contentWindow]).on('touchend mouseup.xdsoft', function arguments_callee5() {
							clearTimeout(timer);
							stop = true;
							$([options.ownerDocument.body, options.contentWindow])
								.off('touchend mouseup.xdsoft', arguments_callee5);
						});
					});
	
				xchangeTimer = 0;
				// base handler - generating a calendar and timepicker
				datetimepicker
					.on('xchange.xdsoft', function (event) {
						clearTimeout(xchangeTimer);
						xchangeTimer = setTimeout(function () {
	
							if (_xdsoft_datetime.currentTime === undefined || _xdsoft_datetime.currentTime === null) {
								_xdsoft_datetime.currentTime = _xdsoft_datetime.now();
							}
	
							var table =	'',
								start = new Date(_xdsoft_datetime.currentTime.getFullYear(), _xdsoft_datetime.currentTime.getMonth(), 1, 12, 0, 0),
								i = 0,
								j,
								today = _xdsoft_datetime.now(),
								maxDate = false,
								minDate = false,
								minDateTime = false,
								maxDateTime = false,
								hDate,
								day,
								d,
								y,
								m,
								w,
								classes = [],
								customDateSettings,
								newRow = true,
								time = '',
								h,
								line_time,
								description;
	
							while (start.getDay() !== options.dayOfWeekStart) {
								start.setDate(start.getDate() - 1);
							}
	
							table += '<table><thead><tr>';
	
							if (options.weeks) {
								table += '<th></th>';
							}
	
							for (j = 0; j < 7; j += 1) {
								table += '<th>' + options.i18n[globalLocale].dayOfWeekShort[(j + options.dayOfWeekStart) % 7] + '</th>';
							}
	
							table += '</tr></thead>';
							table += '<tbody>';
	
							if (options.maxDate !== false) {
								maxDate = _xdsoft_datetime.strToDate(options.maxDate);
								maxDate = new Date(maxDate.getFullYear(), maxDate.getMonth(), maxDate.getDate(), 23, 59, 59, 999);
							}
	
							if (options.minDate !== false) {
								minDate = _xdsoft_datetime.strToDate(options.minDate);
								minDate = new Date(minDate.getFullYear(), minDate.getMonth(), minDate.getDate());
							}
	
	                        if (options.minDateTime !== false) {
								minDateTime = _xdsoft_datetime.strToDate(options.minDateTime);
								minDateTime = new Date(minDateTime.getFullYear(), minDateTime.getMonth(), minDateTime.getDate(), minDateTime.getHours(), minDateTime.getMinutes(), minDateTime.getSeconds());
							}
	
	                        if (options.maxDateTime !== false) {
								maxDateTime = _xdsoft_datetime.strToDate(options.maxDateTime);
								maxDateTime = new Date(maxDateTime.getFullYear(), maxDateTime.getMonth(), maxDateTime.getDate(), maxDateTime.getHours(), maxDateTime.getMinutes(), maxDateTime.getSeconds());
							}
	
							var maxDateTimeDay;
							if (maxDateTime !== false) {
								maxDateTimeDay = ((maxDateTime.getFullYear() * 12) + maxDateTime.getMonth()) * 31 + maxDateTime.getDate();
							}
	
							while (i < _xdsoft_datetime.currentTime.countDaysInMonth() || start.getDay() !== options.dayOfWeekStart || _xdsoft_datetime.currentTime.getMonth() === start.getMonth()) {
								classes = [];
								i += 1;
	
								day = start.getDay();
								d = start.getDate();
								y = start.getFullYear();
								m = start.getMonth();
								w = _xdsoft_datetime.getWeekOfYear(start);
								description = '';
	
								classes.push('xdsoft_date');
	
								if (options.beforeShowDay && $.isFunction(options.beforeShowDay.call)) {
									customDateSettings = options.beforeShowDay.call(datetimepicker, start);
								} else {
									customDateSettings = null;
								}
	
								if(options.allowDateRe && Object.prototype.toString.call(options.allowDateRe) === "[object RegExp]"){
									if(!options.allowDateRe.test(dateHelper.formatDate(start, options.formatDate))){
										classes.push('xdsoft_disabled');
									}
								}
								
								if(options.allowDates && options.allowDates.length>0){
									if(options.allowDates.indexOf(dateHelper.formatDate(start, options.formatDate)) === -1){
										classes.push('xdsoft_disabled');
									}
								}
								
								var currentDay = ((start.getFullYear() * 12) + start.getMonth()) * 31 + start.getDate();
								if ((maxDate !== false && start > maxDate) || (minDateTime !== false && start < minDateTime)  || (minDate !== false && start < minDate) || (maxDateTime !== false && currentDay > maxDateTimeDay) || (customDateSettings && customDateSettings[0] === false)) {
									classes.push('xdsoft_disabled');
								}
								
								if (options.disabledDates.indexOf(dateHelper.formatDate(start, options.formatDate)) !== -1) {
									classes.push('xdsoft_disabled');
								}
								
								if (options.disabledWeekDays.indexOf(day) !== -1) {
									classes.push('xdsoft_disabled');
								}
								
								if (input.is('[disabled]')) {
									classes.push('xdsoft_disabled');
								}
	
								if (customDateSettings && customDateSettings[1] !== "") {
									classes.push(customDateSettings[1]);
								}
	
								if (_xdsoft_datetime.currentTime.getMonth() !== m) {
									classes.push('xdsoft_other_month');
								}
	
								if ((options.defaultSelect || datetimepicker.data('changed')) && dateHelper.formatDate(_xdsoft_datetime.currentTime, options.formatDate) === dateHelper.formatDate(start, options.formatDate)) {
									classes.push('xdsoft_current');
								}
	
								if (dateHelper.formatDate(today, options.formatDate) === dateHelper.formatDate(start, options.formatDate)) {
									classes.push('xdsoft_today');
								}
	
								if (start.getDay() === 0 || start.getDay() === 6 || options.weekends.indexOf(dateHelper.formatDate(start, options.formatDate)) !== -1) {
									classes.push('xdsoft_weekend');
								}
	
								if (options.highlightedDates[dateHelper.formatDate(start, options.formatDate)] !== undefined) {
									hDate = options.highlightedDates[dateHelper.formatDate(start, options.formatDate)];
									classes.push(hDate.style === undefined ? 'xdsoft_highlighted_default' : hDate.style);
									description = hDate.desc === undefined ? '' : hDate.desc;
								}
	
								if (options.beforeShowDay && $.isFunction(options.beforeShowDay)) {
									classes.push(options.beforeShowDay(start));
								}
	
								if (newRow) {
									table += '<tr>';
									newRow = false;
									if (options.weeks) {
										table += '<th>' + w + '</th>';
									}
								}
	
								table += '<td data-date="' + d + '" data-month="' + m + '" data-year="' + y + '"' + ' class="xdsoft_date xdsoft_day_of_week' + start.getDay() + ' ' + classes.join(' ') + '" title="' + description + '">' +
									'<div>' + d + '</div>' +
									'</td>';
	
								if (start.getDay() === options.dayOfWeekStartPrev) {
									table += '</tr>';
									newRow = true;
								}
	
								start.setDate(d + 1);
							}
							table += '</tbody></table>';
	
							calendar.html(table);
	
							month_picker.find('.xdsoft_label span').eq(0).text(options.i18n[globalLocale].months[_xdsoft_datetime.currentTime.getMonth()]);
							month_picker.find('.xdsoft_label span').eq(1).text(_xdsoft_datetime.currentTime.getFullYear() + options.yearOffset);
	
							// generate timebox
							time = '';
							h = '';
							m = '';
	
							var minTimeMinutesOfDay = 0;
							if (options.minTime !== false) {
							    var t = _xdsoft_datetime.strtotime(options.minTime);
							    minTimeMinutesOfDay = 60 * t.getHours() + t.getMinutes();
							}
							var maxTimeMinutesOfDay = 24 * 60;
							if (options.maxTime !== false) {
							    var t = _xdsoft_datetime.strtotime(options.maxTime);
							    maxTimeMinutesOfDay = 60 * t.getHours() + t.getMinutes();
							}
	
							if (options.minDateTime !== false) {
								var t = _xdsoft_datetime.strToDateTime(options.minDateTime);
							        var currentDayIsMinDateTimeDay = dateHelper.formatDate(_xdsoft_datetime.currentTime, options.formatDate) === dateHelper.formatDate(t, options.formatDate);
								if (currentDayIsMinDateTimeDay) {
									var m = 60 * t.getHours() + t.getMinutes();
									if (m > minTimeMinutesOfDay) minTimeMinutesOfDay = m;
								}
							}
	
							if (options.maxDateTime !== false) {
								var t = _xdsoft_datetime.strToDateTime(options.maxDateTime);
							        var currentDayIsMaxDateTimeDay = dateHelper.formatDate(_xdsoft_datetime.currentTime, options.formatDate) === dateHelper.formatDate(t, options.formatDate);
								if (currentDayIsMaxDateTimeDay) {
									var m = 60 * t.getHours() + t.getMinutes();
									if (m < maxTimeMinutesOfDay) maxTimeMinutesOfDay = m;
								}
							}
	
							line_time = function line_time(h, m) {
								var now = _xdsoft_datetime.now(), current_time,
									isALlowTimesInit = options.allowTimes && $.isArray(options.allowTimes) && options.allowTimes.length;
								now.setHours(h);
								h = parseInt(now.getHours(), 10);
								now.setMinutes(m);
								m = parseInt(now.getMinutes(), 10);
								classes = [];
								var currentMinutesOfDay = 60 * h + m;
								if (input.is('[disabled]') || (currentMinutesOfDay >= maxTimeMinutesOfDay) || (currentMinutesOfDay < minTimeMinutesOfDay)) {
									classes.push('xdsoft_disabled');
								}
	
								current_time = new Date(_xdsoft_datetime.currentTime);
								current_time.setHours(parseInt(_xdsoft_datetime.currentTime.getHours(), 10));
	
								if (!isALlowTimesInit) {
									current_time.setMinutes(Math[options.roundTime](_xdsoft_datetime.currentTime.getMinutes() / options.step) * options.step);
								}
	
								if ((options.initTime || options.defaultSelect || datetimepicker.data('changed')) && current_time.getHours() === parseInt(h, 10) && ((!isALlowTimesInit && options.step > 59) || current_time.getMinutes() === parseInt(m, 10))) {
									if (options.defaultSelect || datetimepicker.data('changed')) {
										classes.push('xdsoft_current');
									} else if (options.initTime) {
										classes.push('xdsoft_init_time');
									}
								}
								if (parseInt(today.getHours(), 10) === parseInt(h, 10) && parseInt(today.getMinutes(), 10) === parseInt(m, 10)) {
									classes.push('xdsoft_today');
								}
								time += '<div class="xdsoft_time ' + classes.join(' ') + '" data-hour="' + h + '" data-minute="' + m + '">' + dateHelper.formatDate(now, options.formatTime) + '</div>';
							};
	
							if (!options.allowTimes || !$.isArray(options.allowTimes) || !options.allowTimes.length) {
								for (i = 0, j = 0; i < (options.hours12 ? 12 : 24); i += 1) {
									for (j = 0; j < 60; j += options.step) {
									        var currentMinutesOfDay = i * 60 + j;
									        if (currentMinutesOfDay < minTimeMinutesOfDay) continue;
									        if (currentMinutesOfDay >= maxTimeMinutesOfDay) continue;
										h = (i < 10 ? '0' : '') + i;
										m = (j < 10 ? '0' : '') + j;
										line_time(h, m);
									}
								}
							} else {
								for (i = 0; i < options.allowTimes.length; i += 1) {
									h = _xdsoft_datetime.strtotime(options.allowTimes[i]).getHours();
									m = _xdsoft_datetime.strtotime(options.allowTimes[i]).getMinutes();
									line_time(h, m);
								}
							}
	
							timebox.html(time);
	
							opt = '';
	
							for (i = parseInt(options.yearStart, 10); i <= parseInt(options.yearEnd, 10); i += 1) {
								opt += '<div class="xdsoft_option ' + (_xdsoft_datetime.currentTime.getFullYear() === i ? 'xdsoft_current' : '') + '" data-value="' + i + '">' + (i + options.yearOffset) + '</div>';
							}
							yearselect.children().eq(0)
								.html(opt);
	
							for (i = parseInt(options.monthStart, 10), opt = ''; i <= parseInt(options.monthEnd, 10); i += 1) {
								opt += '<div class="xdsoft_option ' + (_xdsoft_datetime.currentTime.getMonth() === i ? 'xdsoft_current' : '') + '" data-value="' + i + '">' + options.i18n[globalLocale].months[i] + '</div>';
							}
							monthselect.children().eq(0).html(opt);
							$(datetimepicker)
								.trigger('generate.xdsoft');
						}, 10);
						event.stopPropagation();
					})
					.on('afterOpen.xdsoft', function () {
						if (options.timepicker) {
							var classType, pheight, height, top;
							if (timebox.find('.xdsoft_current').length) {
								classType = '.xdsoft_current';
							} else if (timebox.find('.xdsoft_init_time').length) {
								classType = '.xdsoft_init_time';
							}
							if (classType) {
								pheight = timeboxparent[0].clientHeight;
								height = timebox[0].offsetHeight;
								top = timebox.find(classType).index() * options.timeHeightInTimePicker + 1;
								if ((height - pheight) < top) {
									top = height - pheight;
								}
								timeboxparent.trigger('scroll_element.xdsoft_scroller', [parseInt(top, 10) / (height - pheight)]);
							} else {
								timeboxparent.trigger('scroll_element.xdsoft_scroller', [0]);
							}
						}
					});
	
				timerclick = 0;
				calendar
					.on('touchend click.xdsoft', 'td', function (xdevent) {
						xdevent.stopPropagation();  // Prevents closing of Pop-ups, Modals and Flyouts in Bootstrap
						timerclick += 1;
						var $this = $(this),
							currentTime = _xdsoft_datetime.currentTime;
	
						if (currentTime === undefined || currentTime === null) {
							_xdsoft_datetime.currentTime = _xdsoft_datetime.now();
							currentTime = _xdsoft_datetime.currentTime;
						}
	
						if ($this.hasClass('xdsoft_disabled')) {
							return false;
						}
	
						currentTime.setDate(1);
						currentTime.setFullYear($this.data('year'));
						currentTime.setMonth($this.data('month'));
						currentTime.setDate($this.data('date'));
	
						datetimepicker.trigger('select.xdsoft', [currentTime]);
	
						input.val(_xdsoft_datetime.str());
	
						if (options.onSelectDate &&	$.isFunction(options.onSelectDate)) {
							options.onSelectDate.call(datetimepicker, _xdsoft_datetime.currentTime, datetimepicker.data('input'), xdevent);
						}
	
						datetimepicker.data('changed', true);
						datetimepicker.trigger('xchange.xdsoft');
						datetimepicker.trigger('changedatetime.xdsoft');
						if ((timerclick > 1 || (options.closeOnDateSelect === true || (options.closeOnDateSelect === false && !options.timepicker))) && !options.inline) {
							datetimepicker.trigger('close.xdsoft');
						}
						setTimeout(function () {
							timerclick = 0;
						}, 200);
					});
	
				timebox
					.on('touchstart', 'div', function (xdevent) {
						this.touchMoved = false;
					})
					.on('touchmove', 'div', handleTouchMoved)
					.on('touchend click.xdsoft', 'div', function (xdevent) {
						if (!this.touchMoved) {
							xdevent.stopPropagation();
							var $this = $(this),
								currentTime = _xdsoft_datetime.currentTime;
	
							if (currentTime === undefined || currentTime === null) {
								_xdsoft_datetime.currentTime = _xdsoft_datetime.now();
								currentTime = _xdsoft_datetime.currentTime;
							}
	
							if ($this.hasClass('xdsoft_disabled')) {
								return false;
							}
							currentTime.setHours($this.data('hour'));
							currentTime.setMinutes($this.data('minute'));
							datetimepicker.trigger('select.xdsoft', [currentTime]);
	
							datetimepicker.data('input').val(_xdsoft_datetime.str());
	
							if (options.onSelectTime && $.isFunction(options.onSelectTime)) {
								options.onSelectTime.call(datetimepicker, _xdsoft_datetime.currentTime, datetimepicker.data('input'), xdevent);
							}
							datetimepicker.data('changed', true);
							datetimepicker.trigger('xchange.xdsoft');
							datetimepicker.trigger('changedatetime.xdsoft');
							if (options.inline !== true && options.closeOnTimeSelect === true) {
								datetimepicker.trigger('close.xdsoft');
							}
						}
					});
	
				datepicker
					.on('mousewheel.xdsoft', function (event) {
						if (!options.scrollMonth) {
							return true;
						}
						if (event.deltaY < 0) {
							_xdsoft_datetime.nextMonth();
						} else {
							_xdsoft_datetime.prevMonth();
						}
						return false;
					});
	
				input
					.on('mousewheel.xdsoft', function (event) {
						if (!options.scrollInput) {
							return true;
						}
						if (!options.datepicker && options.timepicker) {
							current_time_index = timebox.find('.xdsoft_current').length ? timebox.find('.xdsoft_current').eq(0).index() : 0;
							if (current_time_index + event.deltaY >= 0 && current_time_index + event.deltaY < timebox.children().length) {
								current_time_index += event.deltaY;
							}
							if (timebox.children().eq(current_time_index).length) {
								timebox.children().eq(current_time_index).trigger('mousedown');
							}
							return false;
						}
						if (options.datepicker && !options.timepicker) {
							datepicker.trigger(event, [event.deltaY, event.deltaX, event.deltaY]);
							if (input.val) {
								input.val(_xdsoft_datetime.str());
							}
							datetimepicker.trigger('changedatetime.xdsoft');
							return false;
						}
					});
	
				datetimepicker
					.on('changedatetime.xdsoft', function (event) {
						if (options.onChangeDateTime && $.isFunction(options.onChangeDateTime)) {
							var $input = datetimepicker.data('input');
							options.onChangeDateTime.call(datetimepicker, _xdsoft_datetime.currentTime, $input, event);
							delete options.value;
							$input.trigger('change');
						}
					})
					.on('generate.xdsoft', function () {
						if (options.onGenerate && $.isFunction(options.onGenerate)) {
							options.onGenerate.call(datetimepicker, _xdsoft_datetime.currentTime, datetimepicker.data('input'));
						}
						if (triggerAfterOpen) {
							datetimepicker.trigger('afterOpen.xdsoft');
							triggerAfterOpen = false;
						}
					})
					.on('click.xdsoft', function (xdevent) {
						xdevent.stopPropagation();
					});
	
				current_time_index = 0;
	
				/**
				 * Runs the callback for each of the specified node's ancestors.
				 *
				 * Return FALSE from the callback to stop ascending.
				 *
				 * @param {DOMNode} node
				 * @param {Function} callback
				 * @returns {undefined}
				 */
				forEachAncestorOf = function (node, callback) {
					do {
						node = node.parentNode;
	
						if (!node || callback(node) === false) {
							break;
						}
					} while (node.nodeName !== 'HTML');
				};
	
				/**
				 * Sets the position of the picker.
				 *
				 * @returns {undefined}
				 */
				setPos = function () {
					var dateInputOffset,
						dateInputElem,
						verticalPosition,
						left,
						position,
						datetimepickerElem,
						dateInputHasFixedAncestor,
						$dateInput,
						windowWidth,
						verticalAnchorEdge,
						datetimepickerCss,
						windowHeight,
						windowScrollTop;
	
					$dateInput = datetimepicker.data('input');
					dateInputOffset = $dateInput.offset();
					dateInputElem = $dateInput[0];
	
					verticalAnchorEdge = 'top';
					verticalPosition = (dateInputOffset.top + dateInputElem.offsetHeight) - 1;
					left = dateInputOffset.left;
					position = "absolute";
	
					windowWidth = $(options.contentWindow).width();
					windowHeight = $(options.contentWindow).height();
					windowScrollTop = $(options.contentWindow).scrollTop();
	
					if ((options.ownerDocument.documentElement.clientWidth - dateInputOffset.left) < datepicker.parent().outerWidth(true)) {
						var diff = datepicker.parent().outerWidth(true) - dateInputElem.offsetWidth;
						left = left - diff;
					}
	
					if ($dateInput.parent().css('direction') === 'rtl') {
						left -= (datetimepicker.outerWidth() - $dateInput.outerWidth());
					}
	
					if (options.fixed) {
						verticalPosition -= windowScrollTop;
						left -= $(options.contentWindow).scrollLeft();
						position = "fixed";
					} else {
						dateInputHasFixedAncestor = false;
	
						forEachAncestorOf(dateInputElem, function (ancestorNode) {
							if (ancestorNode === null) {
								return false;
							}
	
							if (options.contentWindow.getComputedStyle(ancestorNode).getPropertyValue('position') === 'fixed') {
								dateInputHasFixedAncestor = true;
								return false;
							}
						});
	
						if (dateInputHasFixedAncestor && !options.insideParent) {
							position = 'fixed';
	
							//If the picker won't fit entirely within the viewport then display it above the date input.
							if (verticalPosition + datetimepicker.outerHeight() > windowHeight + windowScrollTop) {
								verticalAnchorEdge = 'bottom';
								verticalPosition = (windowHeight + windowScrollTop) - dateInputOffset.top;
							} else {
								verticalPosition -= windowScrollTop;
							}
						} else {
							if (verticalPosition + datetimepicker[0].offsetHeight > windowHeight + windowScrollTop) {
								verticalPosition = dateInputOffset.top - datetimepicker[0].offsetHeight + 1;
							}
						}
	
						if (verticalPosition < 0) {
							verticalPosition = 0;
						}
	
						if (left + dateInputElem.offsetWidth > windowWidth) {
							left = windowWidth - dateInputElem.offsetWidth;
						}
					}
	
					datetimepickerElem = datetimepicker[0];
	
					forEachAncestorOf(datetimepickerElem, function (ancestorNode) {
						var ancestorNodePosition;
	
						ancestorNodePosition = options.contentWindow.getComputedStyle(ancestorNode).getPropertyValue('position');
	
						if (ancestorNodePosition === 'relative' && windowWidth >= ancestorNode.offsetWidth) {
							left = left - ((windowWidth - ancestorNode.offsetWidth) / 2);
							return false;
						}
					});
	
					datetimepickerCss = {
						position: position,
						left: options.insideParent ? dateInputElem.offsetLeft : left,
						top: '',  //Initialize to prevent previous values interfering with new ones.
						bottom: ''  //Initialize to prevent previous values interfering with new ones.
					};
	
					if (options.insideParent) {
	                    datetimepickerCss[verticalAnchorEdge] = dateInputElem.offsetTop + dateInputElem.offsetHeight;
	                } else {
	                    datetimepickerCss[verticalAnchorEdge] = verticalPosition;
	                }
	
					datetimepicker.css(datetimepickerCss);
				};
	
				datetimepicker
					.on('open.xdsoft', function (event) {
						var onShow = true;
						if (options.onShow && $.isFunction(options.onShow)) {
							onShow = options.onShow.call(datetimepicker, _xdsoft_datetime.currentTime, datetimepicker.data('input'), event);
						}
						if (onShow !== false) {
							datetimepicker.show();
							setPos();
							$(options.contentWindow)
								.off('resize.xdsoft', setPos)
								.on('resize.xdsoft', setPos);
	
							if (options.closeOnWithoutClick) {
								$([options.ownerDocument.body, options.contentWindow]).on('touchstart mousedown.xdsoft', function arguments_callee6() {
									datetimepicker.trigger('close.xdsoft');
									$([options.ownerDocument.body, options.contentWindow]).off('touchstart mousedown.xdsoft', arguments_callee6);
								});
							}
						}
					})
					.on('close.xdsoft', function (event) {
						var onClose = true;
						month_picker
							.find('.xdsoft_month,.xdsoft_year')
							.find('.xdsoft_select')
							.hide();
						if (options.onClose && $.isFunction(options.onClose)) {
							onClose = options.onClose.call(datetimepicker, _xdsoft_datetime.currentTime, datetimepicker.data('input'), event);
						}
						if (onClose !== false && !options.opened && !options.inline) {
							datetimepicker.hide();
						}
						event.stopPropagation();
					})
					.on('toggle.xdsoft', function () {
						if (datetimepicker.is(':visible')) {
							datetimepicker.trigger('close.xdsoft');
						} else {
							datetimepicker.trigger('open.xdsoft');
						}
					})
					.data('input', input);
	
				timer = 0;
	
				datetimepicker.data('xdsoft_datetime', _xdsoft_datetime);
				datetimepicker.setOptions(options);
	
				function getCurrentValue() {
					var ct = false, time;
	
					if (options.startDate) {
						ct = _xdsoft_datetime.strToDate(options.startDate);
					} else {
						ct = options.value || ((input && input.val && input.val()) ? input.val() : '');
						if (ct) {
							ct = _xdsoft_datetime.strToDateTime(ct);
							if (options.yearOffset) {
								ct = new Date(ct.getFullYear() - options.yearOffset, ct.getMonth(), ct.getDate(), ct.getHours(), ct.getMinutes(), ct.getSeconds(), ct.getMilliseconds());
							}
						} else if (options.defaultDate) {
							ct = _xdsoft_datetime.strToDateTime(options.defaultDate);
							if (options.defaultTime) {
								time = _xdsoft_datetime.strtotime(options.defaultTime);
								ct.setHours(time.getHours());
								ct.setMinutes(time.getMinutes());
							}
						}
					}
	
					if (ct && _xdsoft_datetime.isValidDate(ct)) {
						datetimepicker.data('changed', true);
					} else {
						ct = '';
					}
	
					return ct || 0;
				}
	
				function setMask(options) {
	
					var isValidValue = function (mask, value) {
							var reg = mask
								.replace(/([\[\]\/\{\}\(\)\-\.\+]{1})/g, '\\$1')
								.replace(/_/g, '{digit+}')
								.replace(/([0-9]{1})/g, '{digit$1}')
								.replace(/\{digit([0-9]{1})\}/g, '[0-$1_]{1}')
								.replace(/\{digit[\+]\}/g, '[0-9_]{1}');
							return (new RegExp(reg)).test(value);
						},
						getCaretPos = function (input) {
							try {
								if (options.ownerDocument.selection && options.ownerDocument.selection.createRange) {
									var range = options.ownerDocument.selection.createRange();
									return range.getBookmark().charCodeAt(2) - 2;
								}
								if (input.setSelectionRange) {
									return input.selectionStart;
								}
							} catch (e) {
								return 0;
							}
						},
						setCaretPos = function (node, pos) {
							node = (typeof node === "string" || node instanceof String) ? options.ownerDocument.getElementById(node) : node;
							if (!node) {
								return false;
							}
							if (node.createTextRange) {
								var textRange = node.createTextRange();
								textRange.collapse(true);
								textRange.moveEnd('character', pos);
								textRange.moveStart('character', pos);
								textRange.select();
								return true;
							}
							if (node.setSelectionRange) {
								node.setSelectionRange(pos, pos);
								return true;
							}
							return false;
						};
	
					if(options.mask) {
						input.off('keydown.xdsoft');
					}
	
					if (options.mask === true) {
						if (dateHelper.formatMask) {
							options.mask = dateHelper.formatMask(options.format)
						} else {
							options.mask = options.format
								.replace(/Y/g, '9999')
								.replace(/F/g, '9999')
								.replace(/m/g, '19')
								.replace(/d/g, '39')
								.replace(/H/g, '29')
								.replace(/i/g, '59')
								.replace(/s/g, '59');
						}
					}
	
					if ($.type(options.mask) === 'string') {
						if (!isValidValue(options.mask, input.val())) {
							input.val(options.mask.replace(/[0-9]/g, '_'));
							setCaretPos(input[0], 0);
						}
	
						input.on('paste.xdsoft', function (event) {
						    // couple options here
						    // 1. return false - tell them they can't paste
						    // 2. insert over current characters - minimal validation
						    // 3. full fledged parsing and validation
						    // let's go option 2 for now
	
						    // fires multiple times for some reason
	
						    // https://stackoverflow.com/a/30496488/1366033
						    var clipboardData = event.clipboardData || event.originalEvent.clipboardData || window.clipboardData,
							pastedData = clipboardData.getData('text'),
							val = this.value,
							pos = this.selectionStart
	
						    var valueBeforeCursor = val.substr(0, pos);
						    var valueAfterPaste = val.substr(pos + pastedData.length);
	
						    val = valueBeforeCursor + pastedData + valueAfterPaste;           
						    pos += pastedData.length;
	
						    if (isValidValue(options.mask, val)) {
							this.value = val;
							setCaretPos(this, pos);
						    } else if ($.trim(val) === '') {
							this.value = options.mask.replace(/[0-9]/g, '_');
						    } else {
							input.trigger('error_input.xdsoft');
						    }
	
						    event.preventDefault();
						    return false;
						  });
	
						  input.on('keydown.xdsoft', function (event) {
						    var val = this.value,
							key = event.which,
							pos = this.selectionStart,
							selEnd = this.selectionEnd,
							hasSel = pos !== selEnd,
							digit;
	
						    // only alow these characters
						    if (((key >=  KEY0 && key <=  KEY9)  ||
							 (key >= _KEY0 && key <= _KEY9)) || 
							 (key === BACKSPACE || key === DEL)) {
	
						      // get char to insert which is new character or placeholder ('_')
						      digit = (key === BACKSPACE || key === DEL) ? '_' :
								  String.fromCharCode((_KEY0 <= key && key <= _KEY9) ? key - KEY0 : key);
	
							// we're deleting something, we're not at the start, and have normal cursor, move back one
							// if we have a selection length, cursor actually sits behind deletable char, not in front
							if (key === BACKSPACE && pos && !hasSel) {
							    pos -= 1;
							}
	
							// don't stop on a separator, continue whatever direction you were going
							//   value char - keep incrementing position while on separator char and we still have room
							//   del char   - keep decrementing position while on separator char and we still have room
							while (true) {
							  var maskValueAtCurPos = options.mask.substr(pos, 1);
							  var posShorterThanMaskLength = pos < options.mask.length;
							  var posGreaterThanZero = pos > 0;
							  var notNumberOrPlaceholder = /[^0-9_]/;
							  var curPosOnSep = notNumberOrPlaceholder.test(maskValueAtCurPos);
							  var continueMovingPosition = curPosOnSep && posShorterThanMaskLength && posGreaterThanZero
	
							  // if we hit a real char, stay where we are
							  if (!continueMovingPosition) break;
	
							  // hitting backspace in a selection, you can possibly go back any further - go forward
							  pos += (key === BACKSPACE && !hasSel) ? -1 : 1;
	
	                        }
	                        
	                        if (event.metaKey) {    // cmd has been pressed
	                            pos = 0;
	                            hasSel = true;
	                        }
	
							if (hasSel) {
							  // pos might have moved so re-calc length
							  var selLength = selEnd - pos
	
							  // if we have a selection length we will wipe out entire selection and replace with default template for that range
							  var defaultBlank = options.mask.replace(/[0-9]/g, '_');
							  var defaultBlankSelectionReplacement = defaultBlank.substr(pos, selLength); 
							  var selReplacementRemainder = defaultBlankSelectionReplacement.substr(1) // might be empty
	
							  var valueBeforeSel = val.substr(0, pos);
							  var insertChars = digit + selReplacementRemainder;
							  var charsAfterSelection = val.substr(pos + selLength);
	
							  val = valueBeforeSel + insertChars + charsAfterSelection
	
							} else {
							  var valueBeforeCursor = val.substr(0, pos);
							  var insertChar = digit;
							  var valueAfterNextChar = val.substr(pos + 1);
	
							  val = valueBeforeCursor + insertChar + valueAfterNextChar
							}
	
							if ($.trim(val) === '') {
							  // if empty, set to default
							    val = defaultBlank
							} else {
							  // if at the last character don't need to do anything
							    if (pos === options.mask.length) {
								event.preventDefault();
								return false;
							    }
							}
	
							// resume cursor location
							pos += (key === BACKSPACE) ? 0 : 1;
							// don't stop on a separator, continue whatever direction you were going
							while (/[^0-9_]/.test(options.mask.substr(pos, 1)) && pos < options.mask.length && pos > 0) {
							    pos += (key === BACKSPACE) ? 0 : 1;
							}
	
							if (isValidValue(options.mask, val)) {
							    this.value = val;
							    setCaretPos(this, pos);
							} else if ($.trim(val) === '') {
							    this.value = options.mask.replace(/[0-9]/g, '_');
							} else {
							    input.trigger('error_input.xdsoft');
							}
						    } else {
							if (([AKEY, CKEY, VKEY, ZKEY, YKEY].indexOf(key) !== -1 && ctrlDown) || [ESC, ARROWUP, ARROWDOWN, ARROWLEFT, ARROWRIGHT, F5, CTRLKEY, TAB, ENTER].indexOf(key) !== -1) {
							    return true;
							}
						    }
	
						    event.preventDefault();
						    return false;
						  });
					}
				}
	
				_xdsoft_datetime.setCurrentTime(getCurrentValue());
	
				input
					.data('xdsoft_datetimepicker', datetimepicker)
					.on('open.xdsoft focusin.xdsoft mousedown.xdsoft touchstart', function () {
						if (input.is(':disabled') || (input.data('xdsoft_datetimepicker').is(':visible') && options.closeOnInputClick)) {
							return;
						}
						if (!options.openOnFocus) {
							return;
						}
						clearTimeout(timer);
						timer = setTimeout(function () {
							if (input.is(':disabled')) {
								return;
							}
	
							triggerAfterOpen = true;
							_xdsoft_datetime.setCurrentTime(getCurrentValue(), true);
							if(options.mask) {
								setMask(options);
							}
							datetimepicker.trigger('open.xdsoft');
						}, 100);
					})
					.on('keydown.xdsoft', function (event) {
						var elementSelector,
							key = event.which;
						if ([ENTER].indexOf(key) !== -1 && options.enterLikeTab) {
							elementSelector = $("input:visible,textarea:visible,button:visible,a:visible");
							datetimepicker.trigger('close.xdsoft');
							elementSelector.eq(elementSelector.index(this) + 1).focus();
							return false;
						}
						if ([TAB].indexOf(key) !== -1) {
							datetimepicker.trigger('close.xdsoft');
							return true;
						}
					})
					.on('blur.xdsoft', function () {
						datetimepicker.trigger('close.xdsoft');
					});
			};
			destroyDateTimePicker = function (input) {
				var datetimepicker = input.data('xdsoft_datetimepicker');
				if (datetimepicker) {
					datetimepicker.data('xdsoft_datetime', null);
					datetimepicker.remove();
					input
						.data('xdsoft_datetimepicker', null)
						.off('.xdsoft');
					$(options.contentWindow).off('resize.xdsoft');
					$([options.contentWindow, options.ownerDocument.body]).off('mousedown.xdsoft touchstart');
					if (input.unmousewheel) {
						input.unmousewheel();
					}
				}
			};
			$(options.ownerDocument)
	            .off('keydown.xdsoftctrl keyup.xdsoftctrl')
	            .off('keydown.xdsoftcmd keyup.xdsoftcmd')
				.on('keydown.xdsoftctrl', function (e) {
					if (e.keyCode === CTRLKEY) {
						ctrlDown = true;
	                }
				})
				.on('keyup.xdsoftctrl', function (e) {
					if (e.keyCode === CTRLKEY) {
						ctrlDown = false;
	                }
	            })
	            .on('keydown.xdsoftcmd', function (e) {
	                if (e.keyCode === CMDKEY) {
	                    cmdDown = true;
	                }
				})
				.on('keyup.xdsoftcmd', function (e) {
	                if (e.keyCode === CMDKEY) {
	                    cmdDown = false;
	                }
				});
	
			this.each(function () {
				var datetimepicker = $(this).data('xdsoft_datetimepicker'), $input;
				if (datetimepicker) {
					if ($.type(opt) === 'string') {
						switch (opt) {
							case 'show':
								$(this).select().focus();
								datetimepicker.trigger('open.xdsoft');
								break;
							case 'hide':
								datetimepicker.trigger('close.xdsoft');
								break;
							case 'toggle':
								datetimepicker.trigger('toggle.xdsoft');
								break;
							case 'destroy':
								destroyDateTimePicker($(this));
								break;
							case 'reset':
								this.value = this.defaultValue;
								if (!this.value || !datetimepicker.data('xdsoft_datetime').isValidDate(dateHelper.parseDate(this.value, options.format))) {
									datetimepicker.data('changed', false);
								}
								datetimepicker.data('xdsoft_datetime').setCurrentTime(this.value);
								break;
							case 'validate':
								$input = datetimepicker.data('input');
								$input.trigger('blur.xdsoft');
								break;
							default:
								if (datetimepicker[opt] && $.isFunction(datetimepicker[opt])) {
									result = datetimepicker[opt](opt2);
								}
						}
					} else {
						datetimepicker
							.setOptions(opt);
					}
					return 0;
				}
				if ($.type(opt) !== 'string') {
					if (!options.lazyInit || options.open || options.inline) {
						createDateTimePicker($(this));
					} else {
						lazyInit($(this));
					}
				}
			});
	
			return result;
		};
	
		$.fn.datetimepicker.defaults = default_options;
	
		function HighlightedDate(date, desc, style) {
			"use strict";
			this.date = date;
			this.desc = desc;
			this.style = style;
		}
	};
	;(function (factory) {
		if ( true ) {
			// AMD. Register as an anonymous module.
			!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(7), __webpack_require__(15)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		} else if (typeof exports === 'object') {
			// Node/CommonJS style for Browserify
			module.exports = factory(require('jquery'));;
		} else {
			// Browser globals
			factory(jQuery);
		}
	}(datetimepickerFactory));
	
	
	
	/*!
	 * jQuery Mousewheel 3.1.13
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license
	 * http://jquery.org/license
	 */
	
	(function (factory) {
	    if ( true ) {
	        // AMD. Register as an anonymous module.
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(7)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    } else if (typeof exports === 'object') {
	        // Node/CommonJS style for Browserify
	        module.exports = factory;
	    } else {
	        // Browser globals
	        factory(jQuery);
	    }
	}(function ($) {
	
	    var toFix  = ['wheel', 'mousewheel', 'DOMMouseScroll', 'MozMousePixelScroll'],
	        toBind = ( 'onwheel' in document || document.documentMode >= 9 ) ?
	                    ['wheel'] : ['mousewheel', 'DomMouseScroll', 'MozMousePixelScroll'],
	        slice  = Array.prototype.slice,
	        nullLowestDeltaTimeout, lowestDelta;
	
	    if ( $.event.fixHooks ) {
	        for ( var i = toFix.length; i; ) {
	            $.event.fixHooks[ toFix[--i] ] = $.event.mouseHooks;
	        }
	    }
	
	    var special = $.event.special.mousewheel = {
	        version: '3.1.12',
	
	        setup: function() {
	            if ( this.addEventListener ) {
	                for ( var i = toBind.length; i; ) {
	                    this.addEventListener( toBind[--i], handler, false );
	                }
	            } else {
	                this.onmousewheel = handler;
	            }
	            // Store the line height and page height for this particular element
	            $.data(this, 'mousewheel-line-height', special.getLineHeight(this));
	            $.data(this, 'mousewheel-page-height', special.getPageHeight(this));
	        },
	
	        teardown: function() {
	            if ( this.removeEventListener ) {
	                for ( var i = toBind.length; i; ) {
	                    this.removeEventListener( toBind[--i], handler, false );
	                }
	            } else {
	                this.onmousewheel = null;
	            }
	            // Clean up the data we added to the element
	            $.removeData(this, 'mousewheel-line-height');
	            $.removeData(this, 'mousewheel-page-height');
	        },
	
	        getLineHeight: function(elem) {
	            var $elem = $(elem),
	                $parent = $elem['offsetParent' in $.fn ? 'offsetParent' : 'parent']();
	            if (!$parent.length) {
	                $parent = $('body');
	            }
	            return parseInt($parent.css('fontSize'), 10) || parseInt($elem.css('fontSize'), 10) || 16;
	        },
	
	        getPageHeight: function(elem) {
	            return $(elem).height();
	        },
	
	        settings: {
	            adjustOldDeltas: true, // see shouldAdjustOldDeltas() below
	            normalizeOffset: true  // calls getBoundingClientRect for each event
	        }
	    };
	
	    $.fn.extend({
	        mousewheel: function(fn) {
	            return fn ? this.bind('mousewheel', fn) : this.trigger('mousewheel');
	        },
	
	        unmousewheel: function(fn) {
	            return this.unbind('mousewheel', fn);
	        }
	    });
	
	
	    function handler(event) {
	        var orgEvent   = event || window.event,
	            args       = slice.call(arguments, 1),
	            delta      = 0,
	            deltaX     = 0,
	            deltaY     = 0,
	            absDelta   = 0,
	            offsetX    = 0,
	            offsetY    = 0;
	        event = $.event.fix(orgEvent);
	        event.type = 'mousewheel';
	
	        // Old school scrollwheel delta
	        if ( 'detail'      in orgEvent ) { deltaY = orgEvent.detail * -1;      }
	        if ( 'wheelDelta'  in orgEvent ) { deltaY = orgEvent.wheelDelta;       }
	        if ( 'wheelDeltaY' in orgEvent ) { deltaY = orgEvent.wheelDeltaY;      }
	        if ( 'wheelDeltaX' in orgEvent ) { deltaX = orgEvent.wheelDeltaX * -1; }
	
	        // Firefox < 17 horizontal scrolling related to DOMMouseScroll event
	        if ( 'axis' in orgEvent && orgEvent.axis === orgEvent.HORIZONTAL_AXIS ) {
	            deltaX = deltaY * -1;
	            deltaY = 0;
	        }
	
	        // Set delta to be deltaY or deltaX if deltaY is 0 for backwards compatabilitiy
	        delta = deltaY === 0 ? deltaX : deltaY;
	
	        // New school wheel delta (wheel event)
	        if ( 'deltaY' in orgEvent ) {
	            deltaY = orgEvent.deltaY * -1;
	            delta  = deltaY;
	        }
	        if ( 'deltaX' in orgEvent ) {
	            deltaX = orgEvent.deltaX;
	            if ( deltaY === 0 ) { delta  = deltaX * -1; }
	        }
	
	        // No change actually happened, no reason to go any further
	        if ( deltaY === 0 && deltaX === 0 ) { return; }
	
	        // Need to convert lines and pages to pixels if we aren't already in pixels
	        // There are three delta modes:
	        //   * deltaMode 0 is by pixels, nothing to do
	        //   * deltaMode 1 is by lines
	        //   * deltaMode 2 is by pages
	        if ( orgEvent.deltaMode === 1 ) {
	            var lineHeight = $.data(this, 'mousewheel-line-height');
	            delta  *= lineHeight;
	            deltaY *= lineHeight;
	            deltaX *= lineHeight;
	        } else if ( orgEvent.deltaMode === 2 ) {
	            var pageHeight = $.data(this, 'mousewheel-page-height');
	            delta  *= pageHeight;
	            deltaY *= pageHeight;
	            deltaX *= pageHeight;
	        }
	
	        // Store lowest absolute delta to normalize the delta values
	        absDelta = Math.max( Math.abs(deltaY), Math.abs(deltaX) );
	
	        if ( !lowestDelta || absDelta < lowestDelta ) {
	            lowestDelta = absDelta;
	
	            // Adjust older deltas if necessary
	            if ( shouldAdjustOldDeltas(orgEvent, absDelta) ) {
	                lowestDelta /= 40;
	            }
	        }
	
	        // Adjust older deltas if necessary
	        if ( shouldAdjustOldDeltas(orgEvent, absDelta) ) {
	            // Divide all the things by 40!
	            delta  /= 40;
	            deltaX /= 40;
	            deltaY /= 40;
	        }
	
	        // Get a whole, normalized value for the deltas
	        delta  = Math[ delta  >= 1 ? 'floor' : 'ceil' ](delta  / lowestDelta);
	        deltaX = Math[ deltaX >= 1 ? 'floor' : 'ceil' ](deltaX / lowestDelta);
	        deltaY = Math[ deltaY >= 1 ? 'floor' : 'ceil' ](deltaY / lowestDelta);
	
	        // Normalise offsetX and offsetY properties
	        if ( special.settings.normalizeOffset && this.getBoundingClientRect ) {
	            var boundingRect = this.getBoundingClientRect();
	            offsetX = event.clientX - boundingRect.left;
	            offsetY = event.clientY - boundingRect.top;
	        }
	
	        // Add information to the event object
	        event.deltaX = deltaX;
	        event.deltaY = deltaY;
	        event.deltaFactor = lowestDelta;
	        event.offsetX = offsetX;
	        event.offsetY = offsetY;
	        // Go ahead and set deltaMode to 0 since we converted to pixels
	        // Although this is a little odd since we overwrite the deltaX/Y
	        // properties with normalized deltas.
	        event.deltaMode = 0;
	
	        // Add event and delta to the front of the arguments
	        args.unshift(event, delta, deltaX, deltaY);
	
	        // Clearout lowestDelta after sometime to better
	        // handle multiple device types that give different
	        // a different lowestDelta
	        // Ex: trackpad = 3 and mouse wheel = 120
	        if (nullLowestDeltaTimeout) { clearTimeout(nullLowestDeltaTimeout); }
	        nullLowestDeltaTimeout = setTimeout(nullLowestDelta, 200);
	
	        return ($.event.dispatch || $.event.handle).apply(this, args);
	    }
	
	    function nullLowestDelta() {
	        lowestDelta = null;
	    }
	
	    function shouldAdjustOldDeltas(orgEvent, absDelta) {
	        // If this is an older event and the delta is divisable by 120,
	        // then we are assuming that the browser is treating this as an
	        // older mouse wheel event and that we should divide the deltas
	        // by 40 to try and get a more usable deltaFactor.
	        // Side note, this actually impacts the reported scroll distance
	        // in older browsers and can cause scrolling to be slower than native.
	        // Turn this off by setting $.event.special.mousewheel.settings.adjustOldDeltas to false.
	        return special.settings.adjustOldDeltas && orgEvent.type === 'mousewheel' && absDelta % 120 === 0;
	    }
	
	}));


/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(24);
	
	var options = {
	    width: 110,
	    height: 110,
	    dynamicDraw: true,
	    font: 'robotolight, robotolight-2, sans-serif',
	    fgColor: '#eac40a',
	    readOnly: true,
	    thickness: '.1'
	};
	
	$('.circle-diagram, .circle-grade').knob($.extend(options, {
	    inputColor: '#262626'
	}));
	
	
	$('.circle-diagram2, .circle-grade2').knob($.extend(options, {
	    inputColor: '#fff'
	}));
	
	
	// $('.circle-grade').knob({
	//     readOnly: true,
	//     thickness: '.1',
	//     inputColor: '#262626',
	//     fgColor: '#eac40a',
	//     width: 110,
	//     height: 110,
	//     dynamicDraw: true,
	//     font : 'robotolight, robotolight-2, sans-serif'
	// });
	
	//
	// $('.circle-diagram2').knob({
	//     readOnly: true,
	//     thickness: '.1',
	//     inputColor: '#fff',
	//     fgColor: '#eac40a',
	//     width: 110,
	//     height: 110,
	//     dynamicDraw: true,
	//     font: 'robotolight, robotolight-2, sans-serif'
	// });
	//
	// $('.circle-grade2').knob({
	//     readOnly: true,
	//     thickness: '.1',
	//     inputColor: '#fff',
	//     fgColor: '#eac40a',
	//     width: 110,
	//     height: 110,
	//     dynamicDraw: true,
	//     font: 'robotolight, robotolight-2, sans-serif'
	// });
	
	// animation
	
	// $('.circle-diagram').add('.circle-grade').each(function () {
	//  var elm = $(this);
	//  var perc = elm.attr("value");
	//
	//  $({value: 0}).animate({ value: perc }, {
	//  duration: 1000,
	//  easing: 'swing',
	//  progress: function () {
	//  elm.val(Math.ceil(this.value)).trigger('change')
	//  }
	//  });
	//  });


/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

	/*!jQuery Knob*/
	/**
	 * Downward compatible, touchable dial
	 *
	 * Version: 1.2.12
	 * Requires: jQuery v1.7+
	 *
	 * Copyright (c) 2012 Anthony Terrien
	 * Under MIT License (http://www.opensource.org/licenses/mit-license.php)
	 *
	 * Thanks to vor, eskimoblood, spiffistan, FabrizioC
	 */
	(function (factory) {
	    if (true) {
	        // CommonJS
	        module.exports = factory(__webpack_require__(7));
	    } else if (typeof define === 'function' && define.amd) {
	        // AMD. Register as an anonymous module.
	        define(['jquery'], factory);
	    } else {
	        // Browser globals
	        factory(jQuery);
	    }
	}(function ($) {
	
	    /**
	     * Kontrol library
	     */
	    "use strict";
	
	    /**
	     * Definition of globals and core
	     */
	    var k = {}, // kontrol
	        max = Math.max,
	        min = Math.min;
	
	    k.c = {};
	    k.c.d = $(document);
	    k.c.t = function (e) {
	        return e.originalEvent.touches.length - 1;
	    };
	
	    /**
	     * Kontrol Object
	     *
	     * Definition of an abstract UI control
	     *
	     * Each concrete component must call this one.
	     * <code>
	     * k.o.call(this);
	     * </code>
	     */
	    k.o = function () {
	        var s = this;
	
	        this.o = null; // array of options
	        this.$ = null; // jQuery wrapped element
	        this.i = null; // mixed HTMLInputElement or array of HTMLInputElement
	        this.g = null; // deprecated 2D graphics context for 'pre-rendering'
	        this.v = null; // value ; mixed array or integer
	        this.cv = null; // change value ; not commited value
	        this.x = 0; // canvas x position
	        this.y = 0; // canvas y position
	        this.w = 0; // canvas width
	        this.h = 0; // canvas height
	        this.$c = null; // jQuery canvas element
	        this.c = null; // rendered canvas context
	        this.t = 0; // touches index
	        this.isInit = false;
	        this.fgColor = null; // main color
	        this.pColor = null; // previous color
	        this.dH = null; // draw hook
	        this.cH = null; // change hook
	        this.eH = null; // cancel hook
	        this.rH = null; // release hook
	        this.scale = 1; // scale factor
	        this.relative = false;
	        this.relativeWidth = false;
	        this.relativeHeight = false;
	        this.$div = null; // component div
	
	        this.run = function () {
	            var cf = function (e, conf) {
	                var k;
	                for (k in conf) {
	                    s.o[k] = conf[k];
	                }
	                s._carve().init();
	                s._configure()
	                 ._draw();
	            };
	
	            if (this.$.data('kontroled')) return;
	            this.$.data('kontroled', true);
	
	            this.extend();
	            this.o = $.extend({
	                    // Config
	                    min: this.$.data('min') !== undefined ? this.$.data('min') : 0,
	                    max: this.$.data('max') !== undefined ? this.$.data('max') : 100,
	                    stopper: true,
	                    readOnly: this.$.data('readonly') || (this.$.attr('readonly') === 'readonly'),
	
	                    // UI
	                    cursor: this.$.data('cursor') === true && 30
	                            || this.$.data('cursor') || 0,
	                    thickness: this.$.data('thickness')
	                               && Math.max(Math.min(this.$.data('thickness'), 1), 0.01)
	                               || 0.35,
	                    lineCap: this.$.data('linecap') || 'butt',
	                    width: this.$.data('width') || 200,
	                    height: this.$.data('height') || 200,
	                    displayInput: this.$.data('displayinput') == null || this.$.data('displayinput'),
	                    displayPrevious: this.$.data('displayprevious'),
	                    fgColor: this.$.data('fgcolor') || '#87CEEB',
	                    inputColor: this.$.data('inputcolor'),
	                    font: this.$.data('font') || 'Arial',
	                    fontWeight: this.$.data('font-weight') || 'bold',
	                    inline: false,
	                    step: this.$.data('step') || 1,
	                    rotation: this.$.data('rotation'),
	
	                    // Hooks
	                    draw: null, // function () {}
	                    change: null, // function (value) {}
	                    cancel: null, // function () {}
	                    release: null, // function (value) {}
	
	                    // Output formatting, allows to add unit: %, ms ...
	                    format: function(v) {
	                        return v;
	                    },
	                    parse: function (v) {
	                        return parseFloat(v);
	                    }
	                }, this.o
	            );
	
	            // finalize options
	            this.o.flip = this.o.rotation === 'anticlockwise' || this.o.rotation === 'acw';
	            if (!this.o.inputColor) {
	                this.o.inputColor = this.o.fgColor;
	            }
	
	            // routing value
	            if (this.$.is('fieldset')) {
	
	                // fieldset = array of integer
	                this.v = {};
	                this.i = this.$.find('input');
	                this.i.each(function(k) {
	                    var $this = $(this);
	                    s.i[k] = $this;
	                    s.v[k] = s.o.parse($this.val());
	
	                    $this.bind(
	                        'change blur',
	                        function () {
	                            var val = {};
	                            val[k] = $this.val();
	                            s.val(s._validate(val));
	                        }
	                    );
	                });
	                this.$.find('legend').remove();
	            } else {
	
	                // input = integer
	                this.i = this.$;
	                this.v = this.o.parse(this.$.val());
	                this.v === '' && (this.v = this.o.min);
	                this.$.bind(
	                    'change blur',
	                    function () {
	                        s.val(s._validate(s.o.parse(s.$.val())));
	                    }
	                );
	
	            }
	
	            !this.o.displayInput && this.$.hide();
	
	            // adds needed DOM elements (canvas, div)
	            this.$c = $(document.createElement('canvas')).attr({
	                width: this.o.width,
	                height: this.o.height
	            });
	
	            // wraps all elements in a div
	            // add to DOM before Canvas init is triggered
	            this.$div = $('<div style="'
	                + (this.o.inline ? 'display:inline;' : '')
	                + 'width:' + this.o.width + 'px;height:' + this.o.height + 'px;'
	                + '"></div>');
	
	            this.$.wrap(this.$div).before(this.$c);
	            this.$div = this.$.parent();
	
	            if (typeof G_vmlCanvasManager !== 'undefined') {
	                G_vmlCanvasManager.initElement(this.$c[0]);
	            }
	
	            this.c = this.$c[0].getContext ? this.$c[0].getContext('2d') : null;
	
	            if (!this.c) {
	                throw {
	                    name:        "CanvasNotSupportedException",
	                    message:     "Canvas not supported. Please use excanvas on IE8.0.",
	                    toString:    function(){return this.name + ": " + this.message}
	                }
	            }
	
	            // hdpi support
	            this.scale = (window.devicePixelRatio || 1) / (
	                            this.c.webkitBackingStorePixelRatio ||
	                            this.c.mozBackingStorePixelRatio ||
	                            this.c.msBackingStorePixelRatio ||
	                            this.c.oBackingStorePixelRatio ||
	                            this.c.backingStorePixelRatio || 1
	                         );
	
	            // detects relative width / height
	            this.relativeWidth =  this.o.width % 1 !== 0
	                                  && this.o.width.indexOf('%');
	            this.relativeHeight = this.o.height % 1 !== 0
	                                  && this.o.height.indexOf('%');
	            this.relative = this.relativeWidth || this.relativeHeight;
	
	            // computes size and carves the component
	            this._carve();
	
	            // prepares props for transaction
	            if (this.v instanceof Object) {
	                this.cv = {};
	                this.copy(this.v, this.cv);
	            } else {
	                this.cv = this.v;
	            }
	
	            // binds configure event
	            this.$
	                .bind("configure", cf)
	                .parent()
	                .bind("configure", cf);
	
	            // finalize init
	            this._listen()
	                ._configure()
	                ._xy()
	                .init();
	
	            this.isInit = true;
	
	            this.$.val(this.o.format(this.v));
	            this._draw();
	
	            return this;
	        };
	
	        this._carve = function() {
	            if (this.relative) {
	                var w = this.relativeWidth ?
	                        this.$div.parent().width() *
	                        parseInt(this.o.width) / 100
	                        : this.$div.parent().width(),
	                    h = this.relativeHeight ?
	                        this.$div.parent().height() *
	                        parseInt(this.o.height) / 100
	                        : this.$div.parent().height();
	
	                // apply relative
	                this.w = this.h = Math.min(w, h);
	            } else {
	                this.w = this.o.width;
	                this.h = this.o.height;
	            }
	
	            // finalize div
	            this.$div.css({
	                'width': this.w + 'px',
	                'height': this.h + 'px'
	            });
	
	            // finalize canvas with computed width
	            this.$c.attr({
	                width: this.w,
	                height: this.h
	            });
	
	            // scaling
	            if (this.scale !== 1) {
	                this.$c[0].width = this.$c[0].width * this.scale;
	                this.$c[0].height = this.$c[0].height * this.scale;
	                this.$c.width(this.w);
	                this.$c.height(this.h);
	            }
	
	            return this;
	        };
	
	        this._draw = function () {
	
	            // canvas pre-rendering
	            var d = true;
	
	            s.g = s.c;
	
	            s.clear();
	
	            s.dH && (d = s.dH());
	
	            d !== false && s.draw();
	        };
	
	        this._touch = function (e) {
	            var touchMove = function (e) {
	                var v = s.xy2val(
	                            e.originalEvent.touches[s.t].pageX,
	                            e.originalEvent.touches[s.t].pageY
	                        );
	
	                if (v == s.cv) return;
	
	                if (s.cH && s.cH(v) === false) return;
	
	                s.change(s._validate(v));
	                s._draw();
	            };
	
	            // get touches index
	            this.t = k.c.t(e);
	
	            // First touch
	            touchMove(e);
	
	            // Touch events listeners
	            k.c.d
	                .bind("touchmove.k", touchMove)
	                .bind(
	                    "touchend.k",
	                    function () {
	                        k.c.d.unbind('touchmove.k touchend.k');
	                        s.val(s.cv);
	                    }
	                );
	
	            return this;
	        };
	
	        this._mouse = function (e) {
	            var mouseMove = function (e) {
	                var v = s.xy2val(e.pageX, e.pageY);
	
	                if (v == s.cv) return;
	
	                if (s.cH && (s.cH(v) === false)) return;
	
	                s.change(s._validate(v));
	                s._draw();
	            };
	
	            // First click
	            mouseMove(e);
	
	            // Mouse events listeners
	            k.c.d
	                .bind("mousemove.k", mouseMove)
	                .bind(
	                    // Escape key cancel current change
	                    "keyup.k",
	                    function (e) {
	                        if (e.keyCode === 27) {
	                            k.c.d.unbind("mouseup.k mousemove.k keyup.k");
	
	                            if (s.eH && s.eH() === false)
	                                return;
	
	                            s.cancel();
	                        }
	                    }
	                )
	                .bind(
	                    "mouseup.k",
	                    function (e) {
	                        k.c.d.unbind('mousemove.k mouseup.k keyup.k');
	                        s.val(s.cv);
	                    }
	                );
	
	            return this;
	        };
	
	        this._xy = function () {
	            var o = this.$c.offset();
	            this.x = o.left;
	            this.y = o.top;
	
	            return this;
	        };
	
	        this._listen = function () {
	            if (!this.o.readOnly) {
	                this.$c
	                    .bind(
	                        "mousedown",
	                        function (e) {
	                            e.preventDefault();
	                            s._xy()._mouse(e);
	                        }
	                    )
	                    .bind(
	                        "touchstart",
	                        function (e) {
	                            e.preventDefault();
	                            s._xy()._touch(e);
	                        }
	                    );
	
	                this.listen();
	            } else {
	                this.$.attr('readonly', 'readonly');
	            }
	
	            if (this.relative) {
	                $(window).resize(function() {
	                    s._carve().init();
	                    s._draw();
	                });
	            }
	
	            return this;
	        };
	
	        this._configure = function () {
	
	            // Hooks
	            if (this.o.draw) this.dH = this.o.draw;
	            if (this.o.change) this.cH = this.o.change;
	            if (this.o.cancel) this.eH = this.o.cancel;
	            if (this.o.release) this.rH = this.o.release;
	
	            if (this.o.displayPrevious) {
	                this.pColor = this.h2rgba(this.o.fgColor, "0.4");
	                this.fgColor = this.h2rgba(this.o.fgColor, "0.6");
	            } else {
	                this.fgColor = this.o.fgColor;
	            }
	
	            return this;
	        };
	
	        this._clear = function () {
	            this.$c[0].width = this.$c[0].width;
	        };
	
	        this._validate = function (v) {
	            var val = (~~ (((v < 0) ? -0.5 : 0.5) + (v/this.o.step))) * this.o.step;
	            return Math.round(val * 100) / 100;
	        };
	
	        // Abstract methods
	        this.listen = function () {}; // on start, one time
	        this.extend = function () {}; // each time configure triggered
	        this.init = function () {}; // each time configure triggered
	        this.change = function (v) {}; // on change
	        this.val = function (v) {}; // on release
	        this.xy2val = function (x, y) {}; //
	        this.draw = function () {}; // on change / on release
	        this.clear = function () { this._clear(); };
	
	        // Utils
	        this.h2rgba = function (h, a) {
	            var rgb;
	            h = h.substring(1,7);
	            rgb = [
	                parseInt(h.substring(0,2), 16),
	                parseInt(h.substring(2,4), 16),
	                parseInt(h.substring(4,6), 16)
	            ];
	
	            return "rgba(" + rgb[0] + "," + rgb[1] + "," + rgb[2] + "," + a + ")";
	        };
	
	        this.copy = function (f, t) {
	            for (var i in f) {
	                t[i] = f[i];
	            }
	        };
	    };
	
	
	    /**
	     * k.Dial
	     */
	    k.Dial = function () {
	        k.o.call(this);
	
	        this.startAngle = null;
	        this.xy = null;
	        this.radius = null;
	        this.lineWidth = null;
	        this.cursorExt = null;
	        this.w2 = null;
	        this.PI2 = 2*Math.PI;
	
	        this.extend = function () {
	            this.o = $.extend({
	                bgColor: this.$.data('bgcolor') || '#EEEEEE',
	                angleOffset: this.$.data('angleoffset') || 0,
	                angleArc: this.$.data('anglearc') || 360,
	                inline: true
	            }, this.o);
	        };
	
	        this.val = function (v, triggerRelease) {
	            if (null != v) {
	
	                // reverse format
	                v = this.o.parse(v);
	
	                if (triggerRelease !== false
	                    && v != this.v
	                    && this.rH
	                    && this.rH(v) === false) { return; }
	
	                this.cv = this.o.stopper ? max(min(v, this.o.max), this.o.min) : v;
	                this.v = this.cv;
	                this.$.val(this.o.format(this.v));
	                this._draw();
	            } else {
	                return this.v;
	            }
	        };
	
	        this.xy2val = function (x, y) {
	            var a, ret;
	
	            a = Math.atan2(
	                        x - (this.x + this.w2),
	                        - (y - this.y - this.w2)
	                    ) - this.angleOffset;
	
	            if (this.o.flip) {
	                a = this.angleArc - a - this.PI2;
	            }
	
	            if (this.angleArc != this.PI2 && (a < 0) && (a > -0.5)) {
	
	                // if isset angleArc option, set to min if .5 under min
	                a = 0;
	            } else if (a < 0) {
	                a += this.PI2;
	            }
	
	            ret = (a * (this.o.max - this.o.min) / this.angleArc) + this.o.min;
	
	            this.o.stopper && (ret = max(min(ret, this.o.max), this.o.min));
	
	            return ret;
	        };
	
	        this.listen = function () {
	
	            // bind MouseWheel
	            var s = this, mwTimerStop,
	                mwTimerRelease,
	                mw = function (e) {
	                    e.preventDefault();
	
	                    var ori = e.originalEvent,
	                        deltaX = ori.detail || ori.wheelDeltaX,
	                        deltaY = ori.detail || ori.wheelDeltaY,
	                        v = s._validate(s.o.parse(s.$.val()))
	                            + (
	                                deltaX > 0 || deltaY > 0
	                                ? s.o.step
	                                : deltaX < 0 || deltaY < 0 ? -s.o.step : 0
	                              );
	
	                    v = max(min(v, s.o.max), s.o.min);
	
	                    s.val(v, false);
	
	                    if (s.rH) {
	                        // Handle mousewheel stop
	                        clearTimeout(mwTimerStop);
	                        mwTimerStop = setTimeout(function () {
	                            s.rH(v);
	                            mwTimerStop = null;
	                        }, 100);
	
	                        // Handle mousewheel releases
	                        if (!mwTimerRelease) {
	                            mwTimerRelease = setTimeout(function () {
	                                if (mwTimerStop)
	                                    s.rH(v);
	                                mwTimerRelease = null;
	                            }, 200);
	                        }
	                    }
	                },
	                kval,
	                to,
	                m = 1,
	                kv = {
	                    37: -s.o.step,
	                    38: s.o.step,
	                    39: s.o.step,
	                    40: -s.o.step
	                };
	
	            this.$
	                .bind(
	                    "keydown",
	                    function (e) {
	                        var kc = e.keyCode;
	
	                        // numpad support
	                        if (kc >= 96 && kc <= 105) {
	                            kc = e.keyCode = kc - 48;
	                        }
	
	                        kval = parseInt(String.fromCharCode(kc));
	
	                        if (isNaN(kval)) {
	                            (kc !== 13)                     // enter
	                            && kc !== 8                     // bs
	                            && kc !== 9                     // tab
	                            && kc !== 189                   // -
	                            && (kc !== 190
	                                || s.$.val().match(/\./))   // . allowed once
	                            && e.preventDefault();
	
	                            // arrows
	                            if ($.inArray(kc,[37,38,39,40]) > -1) {
	                                e.preventDefault();
	
	                                var v = s.o.parse(s.$.val()) + kv[kc] * m;
	                                s.o.stopper && (v = max(min(v, s.o.max), s.o.min));
	
	                                s.change(s._validate(v));
	                                s._draw();
	
	                                // long time keydown speed-up
	                                to = window.setTimeout(function () {
	                                    m *= 2;
	                                }, 30);
	                            }
	                        }
	                    }
	                )
	                .bind(
	                    "keyup",
	                    function (e) {
	                        if (isNaN(kval)) {
	                            if (to) {
	                                window.clearTimeout(to);
	                                to = null;
	                                m = 1;
	                                s.val(s.$.val());
	                            }
	                        } else {
	                            // kval postcond
	                            (s.$.val() > s.o.max && s.$.val(s.o.max))
	                            || (s.$.val() < s.o.min && s.$.val(s.o.min));
	                        }
	                    }
	                );
	
	            this.$c.bind("mousewheel DOMMouseScroll", mw);
	            this.$.bind("mousewheel DOMMouseScroll", mw);
	        };
	
	        this.init = function () {
	            if (this.v < this.o.min
	                || this.v > this.o.max) { this.v = this.o.min; }
	
	            this.$.val(this.v);
	            this.w2 = this.w / 2;
	            this.cursorExt = this.o.cursor / 100;
	            this.xy = this.w2 * this.scale;
	            this.lineWidth = this.xy * this.o.thickness;
	            this.lineCap = this.o.lineCap;
	            this.radius = this.xy - this.lineWidth / 2;
	
	            this.o.angleOffset
	            && (this.o.angleOffset = isNaN(this.o.angleOffset) ? 0 : this.o.angleOffset);
	
	            this.o.angleArc
	            && (this.o.angleArc = isNaN(this.o.angleArc) ? this.PI2 : this.o.angleArc);
	
	            // deg to rad
	            this.angleOffset = this.o.angleOffset * Math.PI / 180;
	            this.angleArc = this.o.angleArc * Math.PI / 180;
	
	            // compute start and end angles
	            this.startAngle = 1.5 * Math.PI + this.angleOffset;
	            this.endAngle = 1.5 * Math.PI + this.angleOffset + this.angleArc;
	
	            var s = max(
	                String(Math.abs(this.o.max)).length,
	                String(Math.abs(this.o.min)).length,
	                2
	            ) + 2;
	
	            this.o.displayInput
	                && this.i.css({
	                        'width' : ((this.w / 2 + 4) >> 0) + 'px',
	                        'height' : ((this.w / 3) >> 0) + 'px',
	                        'position' : 'absolute',
	                        'vertical-align' : 'middle',
	                        'margin-top' : ((this.w / 3) >> 0) + 'px',
	                        'margin-left' : '-' + ((this.w * 3 / 4 + 2) >> 0) + 'px',
	                        'border' : 0,
	                        'background' : 'none',
	                        'font' : this.o.fontWeight + ' ' + ((this.w / s) >> 0) + 'px ' + this.o.font,
	                        'text-align' : 'center',
	                        'color' : this.o.inputColor || this.o.fgColor,
	                        'padding' : '0px',
	                        '-webkit-appearance': 'none'
	                        }) || this.i.css({
	                            'width': '0px',
	                            'visibility': 'hidden'
	                        });
	        };
	
	        this.change = function (v) {
	            this.cv = v;
	            this.$.val(this.o.format(v));
	        };
	
	        this.angle = function (v) {
	            return (v - this.o.min) * this.angleArc / (this.o.max - this.o.min);
	        };
	
	        this.arc = function (v) {
	          var sa, ea;
	          v = this.angle(v);
	          if (this.o.flip) {
	              sa = this.endAngle + 0.00001;
	              ea = sa - v - 0.00001;
	          } else {
	              sa = this.startAngle - 0.00001;
	              ea = sa + v + 0.00001;
	          }
	          this.o.cursor
	              && (sa = ea - this.cursorExt)
	              && (ea = ea + this.cursorExt);
	
	          return {
	              s: sa,
	              e: ea,
	              d: this.o.flip && !this.o.cursor
	          };
	        };
	
	        this.draw = function () {
	            var c = this.g,                 // context
	                a = this.arc(this.cv),      // Arc
	                pa,                         // Previous arc
	                r = 1;
	
	            c.lineWidth = this.lineWidth;
	            c.lineCap = this.lineCap;
	
	            if (this.o.bgColor !== "none") {
	                c.beginPath();
	                    c.strokeStyle = this.o.bgColor;
	                    c.arc(this.xy, this.xy, this.radius, this.endAngle - 0.00001, this.startAngle + 0.00001, true);
	                c.stroke();
	            }
	
	            if (this.o.displayPrevious) {
	                pa = this.arc(this.v);
	                c.beginPath();
	                c.strokeStyle = this.pColor;
	                c.arc(this.xy, this.xy, this.radius, pa.s, pa.e, pa.d);
	                c.stroke();
	                r = this.cv == this.v;
	            }
	
	            c.beginPath();
	            c.strokeStyle = r ? this.o.fgColor : this.fgColor ;
	            c.arc(this.xy, this.xy, this.radius, a.s, a.e, a.d);
	            c.stroke();
	        };
	
	        this.cancel = function () {
	            this.val(this.v);
	        };
	    };
	
	    $.fn.dial = $.fn.knob = function (o) {
	        return this.each(
	            function () {
	                var d = new k.Dial();
	                d.o = o;
	                d.$ = $(this);
	                d.run();
	            }
	        ).parent();
	    };
	
	}));


/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(26);
	
	$('.magnific-popup').magnificPopup({
	    type:'image',
	    closeOnContentClick: true,
	    zoom: {
	        enabled: true,
	        duration: 300
	    }
	});

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*! Magnific Popup - v1.1.0 - 2016-02-20
	* http://dimsemenov.com/plugins/magnific-popup/
	* Copyright (c) 2016 Dmitry Semenov; */
	;(function (factory) { 
	if (true) { 
	 // AMD. Register as an anonymous module. 
	 !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(7)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); 
	 } else if (typeof exports === 'object') { 
	 // Node/CommonJS 
	 factory(require('jquery')); 
	 } else { 
	 // Browser globals 
	 factory(window.jQuery || window.Zepto); 
	 } 
	 }(function($) { 
	
	/*>>core*/
	/**
	 * 
	 * Magnific Popup Core JS file
	 * 
	 */
	
	
	/**
	 * Private static constants
	 */
	var CLOSE_EVENT = 'Close',
		BEFORE_CLOSE_EVENT = 'BeforeClose',
		AFTER_CLOSE_EVENT = 'AfterClose',
		BEFORE_APPEND_EVENT = 'BeforeAppend',
		MARKUP_PARSE_EVENT = 'MarkupParse',
		OPEN_EVENT = 'Open',
		CHANGE_EVENT = 'Change',
		NS = 'mfp',
		EVENT_NS = '.' + NS,
		READY_CLASS = 'mfp-ready',
		REMOVING_CLASS = 'mfp-removing',
		PREVENT_CLOSE_CLASS = 'mfp-prevent-close';
	
	
	/**
	 * Private vars 
	 */
	/*jshint -W079 */
	var mfp, // As we have only one instance of MagnificPopup object, we define it locally to not to use 'this'
		MagnificPopup = function(){},
		_isJQ = !!(window.jQuery),
		_prevStatus,
		_window = $(window),
		_document,
		_prevContentType,
		_wrapClasses,
		_currPopupType;
	
	
	/**
	 * Private functions
	 */
	var _mfpOn = function(name, f) {
			mfp.ev.on(NS + name + EVENT_NS, f);
		},
		_getEl = function(className, appendTo, html, raw) {
			var el = document.createElement('div');
			el.className = 'mfp-'+className;
			if(html) {
				el.innerHTML = html;
			}
			if(!raw) {
				el = $(el);
				if(appendTo) {
					el.appendTo(appendTo);
				}
			} else if(appendTo) {
				appendTo.appendChild(el);
			}
			return el;
		},
		_mfpTrigger = function(e, data) {
			mfp.ev.triggerHandler(NS + e, data);
	
			if(mfp.st.callbacks) {
				// converts "mfpEventName" to "eventName" callback and triggers it if it's present
				e = e.charAt(0).toLowerCase() + e.slice(1);
				if(mfp.st.callbacks[e]) {
					mfp.st.callbacks[e].apply(mfp, $.isArray(data) ? data : [data]);
				}
			}
		},
		_getCloseBtn = function(type) {
			if(type !== _currPopupType || !mfp.currTemplate.closeBtn) {
				mfp.currTemplate.closeBtn = $( mfp.st.closeMarkup.replace('%title%', mfp.st.tClose ) );
				_currPopupType = type;
			}
			return mfp.currTemplate.closeBtn;
		},
		// Initialize Magnific Popup only when called at least once
		_checkInstance = function() {
			if(!$.magnificPopup.instance) {
				/*jshint -W020 */
				mfp = new MagnificPopup();
				mfp.init();
				$.magnificPopup.instance = mfp;
			}
		},
		// CSS transition detection, http://stackoverflow.com/questions/7264899/detect-css-transitions-using-javascript-and-without-modernizr
		supportsTransitions = function() {
			var s = document.createElement('p').style, // 's' for style. better to create an element if body yet to exist
				v = ['ms','O','Moz','Webkit']; // 'v' for vendor
	
			if( s['transition'] !== undefined ) {
				return true; 
			}
				
			while( v.length ) {
				if( v.pop() + 'Transition' in s ) {
					return true;
				}
			}
					
			return false;
		};
	
	
	
	/**
	 * Public functions
	 */
	MagnificPopup.prototype = {
	
		constructor: MagnificPopup,
	
		/**
		 * Initializes Magnific Popup plugin. 
		 * This function is triggered only once when $.fn.magnificPopup or $.magnificPopup is executed
		 */
		init: function() {
			var appVersion = navigator.appVersion;
			mfp.isLowIE = mfp.isIE8 = document.all && !document.addEventListener;
			mfp.isAndroid = (/android/gi).test(appVersion);
			mfp.isIOS = (/iphone|ipad|ipod/gi).test(appVersion);
			mfp.supportsTransition = supportsTransitions();
	
			// We disable fixed positioned lightbox on devices that don't handle it nicely.
			// If you know a better way of detecting this - let me know.
			mfp.probablyMobile = (mfp.isAndroid || mfp.isIOS || /(Opera Mini)|Kindle|webOS|BlackBerry|(Opera Mobi)|(Windows Phone)|IEMobile/i.test(navigator.userAgent) );
			_document = $(document);
	
			mfp.popupsCache = {};
		},
	
		/**
		 * Opens popup
		 * @param  data [description]
		 */
		open: function(data) {
	
			var i;
	
			if(data.isObj === false) { 
				// convert jQuery collection to array to avoid conflicts later
				mfp.items = data.items.toArray();
	
				mfp.index = 0;
				var items = data.items,
					item;
				for(i = 0; i < items.length; i++) {
					item = items[i];
					if(item.parsed) {
						item = item.el[0];
					}
					if(item === data.el[0]) {
						mfp.index = i;
						break;
					}
				}
			} else {
				mfp.items = $.isArray(data.items) ? data.items : [data.items];
				mfp.index = data.index || 0;
			}
	
			// if popup is already opened - we just update the content
			if(mfp.isOpen) {
				mfp.updateItemHTML();
				return;
			}
			
			mfp.types = []; 
			_wrapClasses = '';
			if(data.mainEl && data.mainEl.length) {
				mfp.ev = data.mainEl.eq(0);
			} else {
				mfp.ev = _document;
			}
	
			if(data.key) {
				if(!mfp.popupsCache[data.key]) {
					mfp.popupsCache[data.key] = {};
				}
				mfp.currTemplate = mfp.popupsCache[data.key];
			} else {
				mfp.currTemplate = {};
			}
	
	
	
			mfp.st = $.extend(true, {}, $.magnificPopup.defaults, data ); 
			mfp.fixedContentPos = mfp.st.fixedContentPos === 'auto' ? !mfp.probablyMobile : mfp.st.fixedContentPos;
	
			if(mfp.st.modal) {
				mfp.st.closeOnContentClick = false;
				mfp.st.closeOnBgClick = false;
				mfp.st.showCloseBtn = false;
				mfp.st.enableEscapeKey = false;
			}
			
	
			// Building markup
			// main containers are created only once
			if(!mfp.bgOverlay) {
	
				// Dark overlay
				mfp.bgOverlay = _getEl('bg').on('click'+EVENT_NS, function() {
					mfp.close();
				});
	
				mfp.wrap = _getEl('wrap').attr('tabindex', -1).on('click'+EVENT_NS, function(e) {
					if(mfp._checkIfClose(e.target)) {
						mfp.close();
					}
				});
	
				mfp.container = _getEl('container', mfp.wrap);
			}
	
			mfp.contentContainer = _getEl('content');
			if(mfp.st.preloader) {
				mfp.preloader = _getEl('preloader', mfp.container, mfp.st.tLoading);
			}
	
	
			// Initializing modules
			var modules = $.magnificPopup.modules;
			for(i = 0; i < modules.length; i++) {
				var n = modules[i];
				n = n.charAt(0).toUpperCase() + n.slice(1);
				mfp['init'+n].call(mfp);
			}
			_mfpTrigger('BeforeOpen');
	
	
			if(mfp.st.showCloseBtn) {
				// Close button
				if(!mfp.st.closeBtnInside) {
					mfp.wrap.append( _getCloseBtn() );
				} else {
					_mfpOn(MARKUP_PARSE_EVENT, function(e, template, values, item) {
						values.close_replaceWith = _getCloseBtn(item.type);
					});
					_wrapClasses += ' mfp-close-btn-in';
				}
			}
	
			if(mfp.st.alignTop) {
				_wrapClasses += ' mfp-align-top';
			}
	
		
	
			if(mfp.fixedContentPos) {
				mfp.wrap.css({
					overflow: mfp.st.overflowY,
					overflowX: 'hidden',
					overflowY: mfp.st.overflowY
				});
			} else {
				mfp.wrap.css({ 
					top: _window.scrollTop(),
					position: 'absolute'
				});
			}
			if( mfp.st.fixedBgPos === false || (mfp.st.fixedBgPos === 'auto' && !mfp.fixedContentPos) ) {
				mfp.bgOverlay.css({
					height: _document.height(),
					position: 'absolute'
				});
			}
	
			
	
			if(mfp.st.enableEscapeKey) {
				// Close on ESC key
				_document.on('keyup' + EVENT_NS, function(e) {
					if(e.keyCode === 27) {
						mfp.close();
					}
				});
			}
	
			_window.on('resize' + EVENT_NS, function() {
				mfp.updateSize();
			});
	
	
			if(!mfp.st.closeOnContentClick) {
				_wrapClasses += ' mfp-auto-cursor';
			}
			
			if(_wrapClasses)
				mfp.wrap.addClass(_wrapClasses);
	
	
			// this triggers recalculation of layout, so we get it once to not to trigger twice
			var windowHeight = mfp.wH = _window.height();
	
			
			var windowStyles = {};
	
			if( mfp.fixedContentPos ) {
	            if(mfp._hasScrollBar(windowHeight)){
	                var s = mfp._getScrollbarSize();
	                if(s) {
	                    windowStyles.marginRight = s;
	                }
	            }
	        }
	
			if(mfp.fixedContentPos) {
				if(!mfp.isIE7) {
					windowStyles.overflow = 'hidden';
				} else {
					// ie7 double-scroll bug
					$('body, html').css('overflow', 'hidden');
				}
			}
	
			
			
			var classesToadd = mfp.st.mainClass;
			if(mfp.isIE7) {
				classesToadd += ' mfp-ie7';
			}
			if(classesToadd) {
				mfp._addClassToMFP( classesToadd );
			}
	
			// add content
			mfp.updateItemHTML();
	
			_mfpTrigger('BuildControls');
	
			// remove scrollbar, add margin e.t.c
			$('html').css(windowStyles);
			
			// add everything to DOM
			mfp.bgOverlay.add(mfp.wrap).prependTo( mfp.st.prependTo || $(document.body) );
	
			// Save last focused element
			mfp._lastFocusedEl = document.activeElement;
			
			// Wait for next cycle to allow CSS transition
			setTimeout(function() {
				
				if(mfp.content) {
					mfp._addClassToMFP(READY_CLASS);
					mfp._setFocus();
				} else {
					// if content is not defined (not loaded e.t.c) we add class only for BG
					mfp.bgOverlay.addClass(READY_CLASS);
				}
				
				// Trap the focus in popup
				_document.on('focusin' + EVENT_NS, mfp._onFocusIn);
	
			}, 16);
	
			mfp.isOpen = true;
			mfp.updateSize(windowHeight);
			_mfpTrigger(OPEN_EVENT);
	
			return data;
		},
	
		/**
		 * Closes the popup
		 */
		close: function() {
			if(!mfp.isOpen) return;
			_mfpTrigger(BEFORE_CLOSE_EVENT);
	
			mfp.isOpen = false;
			// for CSS3 animation
			if(mfp.st.removalDelay && !mfp.isLowIE && mfp.supportsTransition )  {
				mfp._addClassToMFP(REMOVING_CLASS);
				setTimeout(function() {
					mfp._close();
				}, mfp.st.removalDelay);
			} else {
				mfp._close();
			}
		},
	
		/**
		 * Helper for close() function
		 */
		_close: function() {
			_mfpTrigger(CLOSE_EVENT);
	
			var classesToRemove = REMOVING_CLASS + ' ' + READY_CLASS + ' ';
	
			mfp.bgOverlay.detach();
			mfp.wrap.detach();
			mfp.container.empty();
	
			if(mfp.st.mainClass) {
				classesToRemove += mfp.st.mainClass + ' ';
			}
	
			mfp._removeClassFromMFP(classesToRemove);
	
			if(mfp.fixedContentPos) {
				var windowStyles = {marginRight: ''};
				if(mfp.isIE7) {
					$('body, html').css('overflow', '');
				} else {
					windowStyles.overflow = '';
				}
				$('html').css(windowStyles);
			}
			
			_document.off('keyup' + EVENT_NS + ' focusin' + EVENT_NS);
			mfp.ev.off(EVENT_NS);
	
			// clean up DOM elements that aren't removed
			mfp.wrap.attr('class', 'mfp-wrap').removeAttr('style');
			mfp.bgOverlay.attr('class', 'mfp-bg');
			mfp.container.attr('class', 'mfp-container');
	
			// remove close button from target element
			if(mfp.st.showCloseBtn &&
			(!mfp.st.closeBtnInside || mfp.currTemplate[mfp.currItem.type] === true)) {
				if(mfp.currTemplate.closeBtn)
					mfp.currTemplate.closeBtn.detach();
			}
	
	
			if(mfp.st.autoFocusLast && mfp._lastFocusedEl) {
				$(mfp._lastFocusedEl).focus(); // put tab focus back
			}
			mfp.currItem = null;	
			mfp.content = null;
			mfp.currTemplate = null;
			mfp.prevHeight = 0;
	
			_mfpTrigger(AFTER_CLOSE_EVENT);
		},
		
		updateSize: function(winHeight) {
	
			if(mfp.isIOS) {
				// fixes iOS nav bars https://github.com/dimsemenov/Magnific-Popup/issues/2
				var zoomLevel = document.documentElement.clientWidth / window.innerWidth;
				var height = window.innerHeight * zoomLevel;
				mfp.wrap.css('height', height);
				mfp.wH = height;
			} else {
				mfp.wH = winHeight || _window.height();
			}
			// Fixes #84: popup incorrectly positioned with position:relative on body
			if(!mfp.fixedContentPos) {
				mfp.wrap.css('height', mfp.wH);
			}
	
			_mfpTrigger('Resize');
	
		},
	
		/**
		 * Set content of popup based on current index
		 */
		updateItemHTML: function() {
			var item = mfp.items[mfp.index];
	
			// Detach and perform modifications
			mfp.contentContainer.detach();
	
			if(mfp.content)
				mfp.content.detach();
	
			if(!item.parsed) {
				item = mfp.parseEl( mfp.index );
			}
	
			var type = item.type;
	
			_mfpTrigger('BeforeChange', [mfp.currItem ? mfp.currItem.type : '', type]);
			// BeforeChange event works like so:
			// _mfpOn('BeforeChange', function(e, prevType, newType) { });
	
			mfp.currItem = item;
	
			if(!mfp.currTemplate[type]) {
				var markup = mfp.st[type] ? mfp.st[type].markup : false;
	
				// allows to modify markup
				_mfpTrigger('FirstMarkupParse', markup);
	
				if(markup) {
					mfp.currTemplate[type] = $(markup);
				} else {
					// if there is no markup found we just define that template is parsed
					mfp.currTemplate[type] = true;
				}
			}
	
			if(_prevContentType && _prevContentType !== item.type) {
				mfp.container.removeClass('mfp-'+_prevContentType+'-holder');
			}
	
			var newContent = mfp['get' + type.charAt(0).toUpperCase() + type.slice(1)](item, mfp.currTemplate[type]);
			mfp.appendContent(newContent, type);
	
			item.preloaded = true;
	
			_mfpTrigger(CHANGE_EVENT, item);
			_prevContentType = item.type;
	
			// Append container back after its content changed
			mfp.container.prepend(mfp.contentContainer);
	
			_mfpTrigger('AfterChange');
		},
	
	
		/**
		 * Set HTML content of popup
		 */
		appendContent: function(newContent, type) {
			mfp.content = newContent;
	
			if(newContent) {
				if(mfp.st.showCloseBtn && mfp.st.closeBtnInside &&
					mfp.currTemplate[type] === true) {
					// if there is no markup, we just append close button element inside
					if(!mfp.content.find('.mfp-close').length) {
						mfp.content.append(_getCloseBtn());
					}
				} else {
					mfp.content = newContent;
				}
			} else {
				mfp.content = '';
			}
	
			_mfpTrigger(BEFORE_APPEND_EVENT);
			mfp.container.addClass('mfp-'+type+'-holder');
	
			mfp.contentContainer.append(mfp.content);
		},
	
	
		/**
		 * Creates Magnific Popup data object based on given data
		 * @param  {int} index Index of item to parse
		 */
		parseEl: function(index) {
			var item = mfp.items[index],
				type;
	
			if(item.tagName) {
				item = { el: $(item) };
			} else {
				type = item.type;
				item = { data: item, src: item.src };
			}
	
			if(item.el) {
				var types = mfp.types;
	
				// check for 'mfp-TYPE' class
				for(var i = 0; i < types.length; i++) {
					if( item.el.hasClass('mfp-'+types[i]) ) {
						type = types[i];
						break;
					}
				}
	
				item.src = item.el.attr('data-mfp-src');
				if(!item.src) {
					item.src = item.el.attr('href');
				}
			}
	
			item.type = type || mfp.st.type || 'inline';
			item.index = index;
			item.parsed = true;
			mfp.items[index] = item;
			_mfpTrigger('ElementParse', item);
	
			return mfp.items[index];
		},
	
	
		/**
		 * Initializes single popup or a group of popups
		 */
		addGroup: function(el, options) {
			var eHandler = function(e) {
				e.mfpEl = this;
				mfp._openClick(e, el, options);
			};
	
			if(!options) {
				options = {};
			}
	
			var eName = 'click.magnificPopup';
			options.mainEl = el;
	
			if(options.items) {
				options.isObj = true;
				el.off(eName).on(eName, eHandler);
			} else {
				options.isObj = false;
				if(options.delegate) {
					el.off(eName).on(eName, options.delegate , eHandler);
				} else {
					options.items = el;
					el.off(eName).on(eName, eHandler);
				}
			}
		},
		_openClick: function(e, el, options) {
			var midClick = options.midClick !== undefined ? options.midClick : $.magnificPopup.defaults.midClick;
	
	
			if(!midClick && ( e.which === 2 || e.ctrlKey || e.metaKey || e.altKey || e.shiftKey ) ) {
				return;
			}
	
			var disableOn = options.disableOn !== undefined ? options.disableOn : $.magnificPopup.defaults.disableOn;
	
			if(disableOn) {
				if($.isFunction(disableOn)) {
					if( !disableOn.call(mfp) ) {
						return true;
					}
				} else { // else it's number
					if( _window.width() < disableOn ) {
						return true;
					}
				}
			}
	
			if(e.type) {
				e.preventDefault();
	
				// This will prevent popup from closing if element is inside and popup is already opened
				if(mfp.isOpen) {
					e.stopPropagation();
				}
			}
	
			options.el = $(e.mfpEl);
			if(options.delegate) {
				options.items = el.find(options.delegate);
			}
			mfp.open(options);
		},
	
	
		/**
		 * Updates text on preloader
		 */
		updateStatus: function(status, text) {
	
			if(mfp.preloader) {
				if(_prevStatus !== status) {
					mfp.container.removeClass('mfp-s-'+_prevStatus);
				}
	
				if(!text && status === 'loading') {
					text = mfp.st.tLoading;
				}
	
				var data = {
					status: status,
					text: text
				};
				// allows to modify status
				_mfpTrigger('UpdateStatus', data);
	
				status = data.status;
				text = data.text;
	
				mfp.preloader.html(text);
	
				mfp.preloader.find('a').on('click', function(e) {
					e.stopImmediatePropagation();
				});
	
				mfp.container.addClass('mfp-s-'+status);
				_prevStatus = status;
			}
		},
	
	
		/*
			"Private" helpers that aren't private at all
		 */
		// Check to close popup or not
		// "target" is an element that was clicked
		_checkIfClose: function(target) {
	
			if($(target).hasClass(PREVENT_CLOSE_CLASS)) {
				return;
			}
	
			var closeOnContent = mfp.st.closeOnContentClick;
			var closeOnBg = mfp.st.closeOnBgClick;
	
			if(closeOnContent && closeOnBg) {
				return true;
			} else {
	
				// We close the popup if click is on close button or on preloader. Or if there is no content.
				if(!mfp.content || $(target).hasClass('mfp-close') || (mfp.preloader && target === mfp.preloader[0]) ) {
					return true;
				}
	
				// if click is outside the content
				if(  (target !== mfp.content[0] && !$.contains(mfp.content[0], target))  ) {
					if(closeOnBg) {
						// last check, if the clicked element is in DOM, (in case it's removed onclick)
						if( $.contains(document, target) ) {
							return true;
						}
					}
				} else if(closeOnContent) {
					return true;
				}
	
			}
			return false;
		},
		_addClassToMFP: function(cName) {
			mfp.bgOverlay.addClass(cName);
			mfp.wrap.addClass(cName);
		},
		_removeClassFromMFP: function(cName) {
			this.bgOverlay.removeClass(cName);
			mfp.wrap.removeClass(cName);
		},
		_hasScrollBar: function(winHeight) {
			return (  (mfp.isIE7 ? _document.height() : document.body.scrollHeight) > (winHeight || _window.height()) );
		},
		_setFocus: function() {
			(mfp.st.focus ? mfp.content.find(mfp.st.focus).eq(0) : mfp.wrap).focus();
		},
		_onFocusIn: function(e) {
			if( e.target !== mfp.wrap[0] && !$.contains(mfp.wrap[0], e.target) ) {
				mfp._setFocus();
				return false;
			}
		},
		_parseMarkup: function(template, values, item) {
			var arr;
			if(item.data) {
				values = $.extend(item.data, values);
			}
			_mfpTrigger(MARKUP_PARSE_EVENT, [template, values, item] );
	
			$.each(values, function(key, value) {
				if(value === undefined || value === false) {
					return true;
				}
				arr = key.split('_');
				if(arr.length > 1) {
					var el = template.find(EVENT_NS + '-'+arr[0]);
	
					if(el.length > 0) {
						var attr = arr[1];
						if(attr === 'replaceWith') {
							if(el[0] !== value[0]) {
								el.replaceWith(value);
							}
						} else if(attr === 'img') {
							if(el.is('img')) {
								el.attr('src', value);
							} else {
								el.replaceWith( $('<img>').attr('src', value).attr('class', el.attr('class')) );
							}
						} else {
							el.attr(arr[1], value);
						}
					}
	
				} else {
					template.find(EVENT_NS + '-'+key).html(value);
				}
			});
		},
	
		_getScrollbarSize: function() {
			// thx David
			if(mfp.scrollbarSize === undefined) {
				var scrollDiv = document.createElement("div");
				scrollDiv.style.cssText = 'width: 99px; height: 99px; overflow: scroll; position: absolute; top: -9999px;';
				document.body.appendChild(scrollDiv);
				mfp.scrollbarSize = scrollDiv.offsetWidth - scrollDiv.clientWidth;
				document.body.removeChild(scrollDiv);
			}
			return mfp.scrollbarSize;
		}
	
	}; /* MagnificPopup core prototype end */
	
	
	
	
	/**
	 * Public static functions
	 */
	$.magnificPopup = {
		instance: null,
		proto: MagnificPopup.prototype,
		modules: [],
	
		open: function(options, index) {
			_checkInstance();
	
			if(!options) {
				options = {};
			} else {
				options = $.extend(true, {}, options);
			}
	
			options.isObj = true;
			options.index = index || 0;
			return this.instance.open(options);
		},
	
		close: function() {
			return $.magnificPopup.instance && $.magnificPopup.instance.close();
		},
	
		registerModule: function(name, module) {
			if(module.options) {
				$.magnificPopup.defaults[name] = module.options;
			}
			$.extend(this.proto, module.proto);
			this.modules.push(name);
		},
	
		defaults: {
	
			// Info about options is in docs:
			// http://dimsemenov.com/plugins/magnific-popup/documentation.html#options
	
			disableOn: 0,
	
			key: null,
	
			midClick: false,
	
			mainClass: '',
	
			preloader: true,
	
			focus: '', // CSS selector of input to focus after popup is opened
	
			closeOnContentClick: false,
	
			closeOnBgClick: true,
	
			closeBtnInside: true,
	
			showCloseBtn: true,
	
			enableEscapeKey: true,
	
			modal: false,
	
			alignTop: false,
	
			removalDelay: 0,
	
			prependTo: null,
	
			fixedContentPos: 'auto',
	
			fixedBgPos: 'auto',
	
			overflowY: 'auto',
	
			closeMarkup: '<button title="%title%" type="button" class="mfp-close">&#215;</button>',
	
			tClose: 'Close (Esc)',
	
			tLoading: 'Loading...',
	
			autoFocusLast: true
	
		}
	};
	
	
	
	$.fn.magnificPopup = function(options) {
		_checkInstance();
	
		var jqEl = $(this);
	
		// We call some API method of first param is a string
		if (typeof options === "string" ) {
	
			if(options === 'open') {
				var items,
					itemOpts = _isJQ ? jqEl.data('magnificPopup') : jqEl[0].magnificPopup,
					index = parseInt(arguments[1], 10) || 0;
	
				if(itemOpts.items) {
					items = itemOpts.items[index];
				} else {
					items = jqEl;
					if(itemOpts.delegate) {
						items = items.find(itemOpts.delegate);
					}
					items = items.eq( index );
				}
				mfp._openClick({mfpEl:items}, jqEl, itemOpts);
			} else {
				if(mfp.isOpen)
					mfp[options].apply(mfp, Array.prototype.slice.call(arguments, 1));
			}
	
		} else {
			// clone options obj
			options = $.extend(true, {}, options);
	
			/*
			 * As Zepto doesn't support .data() method for objects
			 * and it works only in normal browsers
			 * we assign "options" object directly to the DOM element. FTW!
			 */
			if(_isJQ) {
				jqEl.data('magnificPopup', options);
			} else {
				jqEl[0].magnificPopup = options;
			}
	
			mfp.addGroup(jqEl, options);
	
		}
		return jqEl;
	};
	
	/*>>core*/
	
	/*>>inline*/
	
	var INLINE_NS = 'inline',
		_hiddenClass,
		_inlinePlaceholder,
		_lastInlineElement,
		_putInlineElementsBack = function() {
			if(_lastInlineElement) {
				_inlinePlaceholder.after( _lastInlineElement.addClass(_hiddenClass) ).detach();
				_lastInlineElement = null;
			}
		};
	
	$.magnificPopup.registerModule(INLINE_NS, {
		options: {
			hiddenClass: 'hide', // will be appended with `mfp-` prefix
			markup: '',
			tNotFound: 'Content not found'
		},
		proto: {
	
			initInline: function() {
				mfp.types.push(INLINE_NS);
	
				_mfpOn(CLOSE_EVENT+'.'+INLINE_NS, function() {
					_putInlineElementsBack();
				});
			},
	
			getInline: function(item, template) {
	
				_putInlineElementsBack();
	
				if(item.src) {
					var inlineSt = mfp.st.inline,
						el = $(item.src);
	
					if(el.length) {
	
						// If target element has parent - we replace it with placeholder and put it back after popup is closed
						var parent = el[0].parentNode;
						if(parent && parent.tagName) {
							if(!_inlinePlaceholder) {
								_hiddenClass = inlineSt.hiddenClass;
								_inlinePlaceholder = _getEl(_hiddenClass);
								_hiddenClass = 'mfp-'+_hiddenClass;
							}
							// replace target inline element with placeholder
							_lastInlineElement = el.after(_inlinePlaceholder).detach().removeClass(_hiddenClass);
						}
	
						mfp.updateStatus('ready');
					} else {
						mfp.updateStatus('error', inlineSt.tNotFound);
						el = $('<div>');
					}
	
					item.inlineElement = el;
					return el;
				}
	
				mfp.updateStatus('ready');
				mfp._parseMarkup(template, {}, item);
				return template;
			}
		}
	});
	
	/*>>inline*/
	
	/*>>ajax*/
	var AJAX_NS = 'ajax',
		_ajaxCur,
		_removeAjaxCursor = function() {
			if(_ajaxCur) {
				$(document.body).removeClass(_ajaxCur);
			}
		},
		_destroyAjaxRequest = function() {
			_removeAjaxCursor();
			if(mfp.req) {
				mfp.req.abort();
			}
		};
	
	$.magnificPopup.registerModule(AJAX_NS, {
	
		options: {
			settings: null,
			cursor: 'mfp-ajax-cur',
			tError: '<a href="%url%">The content</a> could not be loaded.'
		},
	
		proto: {
			initAjax: function() {
				mfp.types.push(AJAX_NS);
				_ajaxCur = mfp.st.ajax.cursor;
	
				_mfpOn(CLOSE_EVENT+'.'+AJAX_NS, _destroyAjaxRequest);
				_mfpOn('BeforeChange.' + AJAX_NS, _destroyAjaxRequest);
			},
			getAjax: function(item) {
	
				if(_ajaxCur) {
					$(document.body).addClass(_ajaxCur);
				}
	
				mfp.updateStatus('loading');
	
				var opts = $.extend({
					url: item.src,
					success: function(data, textStatus, jqXHR) {
						var temp = {
							data:data,
							xhr:jqXHR
						};
	
						_mfpTrigger('ParseAjax', temp);
	
						mfp.appendContent( $(temp.data), AJAX_NS );
	
						item.finished = true;
	
						_removeAjaxCursor();
	
						mfp._setFocus();
	
						setTimeout(function() {
							mfp.wrap.addClass(READY_CLASS);
						}, 16);
	
						mfp.updateStatus('ready');
	
						_mfpTrigger('AjaxContentAdded');
					},
					error: function() {
						_removeAjaxCursor();
						item.finished = item.loadError = true;
						mfp.updateStatus('error', mfp.st.ajax.tError.replace('%url%', item.src));
					}
				}, mfp.st.ajax.settings);
	
				mfp.req = $.ajax(opts);
	
				return '';
			}
		}
	});
	
	/*>>ajax*/
	
	/*>>image*/
	var _imgInterval,
		_getTitle = function(item) {
			if(item.data && item.data.title !== undefined)
				return item.data.title;
	
			var src = mfp.st.image.titleSrc;
	
			if(src) {
				if($.isFunction(src)) {
					return src.call(mfp, item);
				} else if(item.el) {
					return item.el.attr(src) || '';
				}
			}
			return '';
		};
	
	$.magnificPopup.registerModule('image', {
	
		options: {
			markup: '<div class="mfp-figure">'+
						'<div class="mfp-close"></div>'+
						'<figure>'+
							'<div class="mfp-img"></div>'+
							'<figcaption>'+
								'<div class="mfp-bottom-bar">'+
									'<div class="mfp-title"></div>'+
									'<div class="mfp-counter"></div>'+
								'</div>'+
							'</figcaption>'+
						'</figure>'+
					'</div>',
			cursor: 'mfp-zoom-out-cur',
			titleSrc: 'title',
			verticalFit: true,
			tError: '<a href="%url%">The image</a> could not be loaded.'
		},
	
		proto: {
			initImage: function() {
				var imgSt = mfp.st.image,
					ns = '.image';
	
				mfp.types.push('image');
	
				_mfpOn(OPEN_EVENT+ns, function() {
					if(mfp.currItem.type === 'image' && imgSt.cursor) {
						$(document.body).addClass(imgSt.cursor);
					}
				});
	
				_mfpOn(CLOSE_EVENT+ns, function() {
					if(imgSt.cursor) {
						$(document.body).removeClass(imgSt.cursor);
					}
					_window.off('resize' + EVENT_NS);
				});
	
				_mfpOn('Resize'+ns, mfp.resizeImage);
				if(mfp.isLowIE) {
					_mfpOn('AfterChange', mfp.resizeImage);
				}
			},
			resizeImage: function() {
				var item = mfp.currItem;
				if(!item || !item.img) return;
	
				if(mfp.st.image.verticalFit) {
					var decr = 0;
					// fix box-sizing in ie7/8
					if(mfp.isLowIE) {
						decr = parseInt(item.img.css('padding-top'), 10) + parseInt(item.img.css('padding-bottom'),10);
					}
					item.img.css('max-height', mfp.wH-decr);
				}
			},
			_onImageHasSize: function(item) {
				if(item.img) {
	
					item.hasSize = true;
	
					if(_imgInterval) {
						clearInterval(_imgInterval);
					}
	
					item.isCheckingImgSize = false;
	
					_mfpTrigger('ImageHasSize', item);
	
					if(item.imgHidden) {
						if(mfp.content)
							mfp.content.removeClass('mfp-loading');
	
						item.imgHidden = false;
					}
	
				}
			},
	
			/**
			 * Function that loops until the image has size to display elements that rely on it asap
			 */
			findImageSize: function(item) {
	
				var counter = 0,
					img = item.img[0],
					mfpSetInterval = function(delay) {
	
						if(_imgInterval) {
							clearInterval(_imgInterval);
						}
						// decelerating interval that checks for size of an image
						_imgInterval = setInterval(function() {
							if(img.naturalWidth > 0) {
								mfp._onImageHasSize(item);
								return;
							}
	
							if(counter > 200) {
								clearInterval(_imgInterval);
							}
	
							counter++;
							if(counter === 3) {
								mfpSetInterval(10);
							} else if(counter === 40) {
								mfpSetInterval(50);
							} else if(counter === 100) {
								mfpSetInterval(500);
							}
						}, delay);
					};
	
				mfpSetInterval(1);
			},
	
			getImage: function(item, template) {
	
				var guard = 0,
	
					// image load complete handler
					onLoadComplete = function() {
						if(item) {
							if (item.img[0].complete) {
								item.img.off('.mfploader');
	
								if(item === mfp.currItem){
									mfp._onImageHasSize(item);
	
									mfp.updateStatus('ready');
								}
	
								item.hasSize = true;
								item.loaded = true;
	
								_mfpTrigger('ImageLoadComplete');
	
							}
							else {
								// if image complete check fails 200 times (20 sec), we assume that there was an error.
								guard++;
								if(guard < 200) {
									setTimeout(onLoadComplete,100);
								} else {
									onLoadError();
								}
							}
						}
					},
	
					// image error handler
					onLoadError = function() {
						if(item) {
							item.img.off('.mfploader');
							if(item === mfp.currItem){
								mfp._onImageHasSize(item);
								mfp.updateStatus('error', imgSt.tError.replace('%url%', item.src) );
							}
	
							item.hasSize = true;
							item.loaded = true;
							item.loadError = true;
						}
					},
					imgSt = mfp.st.image;
	
	
				var el = template.find('.mfp-img');
				if(el.length) {
					var img = document.createElement('img');
					img.className = 'mfp-img';
					if(item.el && item.el.find('img').length) {
						img.alt = item.el.find('img').attr('alt');
					}
					item.img = $(img).on('load.mfploader', onLoadComplete).on('error.mfploader', onLoadError);
					img.src = item.src;
	
					// without clone() "error" event is not firing when IMG is replaced by new IMG
					// TODO: find a way to avoid such cloning
					if(el.is('img')) {
						item.img = item.img.clone();
					}
	
					img = item.img[0];
					if(img.naturalWidth > 0) {
						item.hasSize = true;
					} else if(!img.width) {
						item.hasSize = false;
					}
				}
	
				mfp._parseMarkup(template, {
					title: _getTitle(item),
					img_replaceWith: item.img
				}, item);
	
				mfp.resizeImage();
	
				if(item.hasSize) {
					if(_imgInterval) clearInterval(_imgInterval);
	
					if(item.loadError) {
						template.addClass('mfp-loading');
						mfp.updateStatus('error', imgSt.tError.replace('%url%', item.src) );
					} else {
						template.removeClass('mfp-loading');
						mfp.updateStatus('ready');
					}
					return template;
				}
	
				mfp.updateStatus('loading');
				item.loading = true;
	
				if(!item.hasSize) {
					item.imgHidden = true;
					template.addClass('mfp-loading');
					mfp.findImageSize(item);
				}
	
				return template;
			}
		}
	});
	
	/*>>image*/
	
	/*>>zoom*/
	var hasMozTransform,
		getHasMozTransform = function() {
			if(hasMozTransform === undefined) {
				hasMozTransform = document.createElement('p').style.MozTransform !== undefined;
			}
			return hasMozTransform;
		};
	
	$.magnificPopup.registerModule('zoom', {
	
		options: {
			enabled: false,
			easing: 'ease-in-out',
			duration: 300,
			opener: function(element) {
				return element.is('img') ? element : element.find('img');
			}
		},
	
		proto: {
	
			initZoom: function() {
				var zoomSt = mfp.st.zoom,
					ns = '.zoom',
					image;
	
				if(!zoomSt.enabled || !mfp.supportsTransition) {
					return;
				}
	
				var duration = zoomSt.duration,
					getElToAnimate = function(image) {
						var newImg = image.clone().removeAttr('style').removeAttr('class').addClass('mfp-animated-image'),
							transition = 'all '+(zoomSt.duration/1000)+'s ' + zoomSt.easing,
							cssObj = {
								position: 'fixed',
								zIndex: 9999,
								left: 0,
								top: 0,
								'-webkit-backface-visibility': 'hidden'
							},
							t = 'transition';
	
						cssObj['-webkit-'+t] = cssObj['-moz-'+t] = cssObj['-o-'+t] = cssObj[t] = transition;
	
						newImg.css(cssObj);
						return newImg;
					},
					showMainContent = function() {
						mfp.content.css('visibility', 'visible');
					},
					openTimeout,
					animatedImg;
	
				_mfpOn('BuildControls'+ns, function() {
					if(mfp._allowZoom()) {
	
						clearTimeout(openTimeout);
						mfp.content.css('visibility', 'hidden');
	
						// Basically, all code below does is clones existing image, puts in on top of the current one and animated it
	
						image = mfp._getItemToZoom();
	
						if(!image) {
							showMainContent();
							return;
						}
	
						animatedImg = getElToAnimate(image);
	
						animatedImg.css( mfp._getOffset() );
	
						mfp.wrap.append(animatedImg);
	
						openTimeout = setTimeout(function() {
							animatedImg.css( mfp._getOffset( true ) );
							openTimeout = setTimeout(function() {
	
								showMainContent();
	
								setTimeout(function() {
									animatedImg.remove();
									image = animatedImg = null;
									_mfpTrigger('ZoomAnimationEnded');
								}, 16); // avoid blink when switching images
	
							}, duration); // this timeout equals animation duration
	
						}, 16); // by adding this timeout we avoid short glitch at the beginning of animation
	
	
						// Lots of timeouts...
					}
				});
				_mfpOn(BEFORE_CLOSE_EVENT+ns, function() {
					if(mfp._allowZoom()) {
	
						clearTimeout(openTimeout);
	
						mfp.st.removalDelay = duration;
	
						if(!image) {
							image = mfp._getItemToZoom();
							if(!image) {
								return;
							}
							animatedImg = getElToAnimate(image);
						}
	
						animatedImg.css( mfp._getOffset(true) );
						mfp.wrap.append(animatedImg);
						mfp.content.css('visibility', 'hidden');
	
						setTimeout(function() {
							animatedImg.css( mfp._getOffset() );
						}, 16);
					}
	
				});
	
				_mfpOn(CLOSE_EVENT+ns, function() {
					if(mfp._allowZoom()) {
						showMainContent();
						if(animatedImg) {
							animatedImg.remove();
						}
						image = null;
					}
				});
			},
	
			_allowZoom: function() {
				return mfp.currItem.type === 'image';
			},
	
			_getItemToZoom: function() {
				if(mfp.currItem.hasSize) {
					return mfp.currItem.img;
				} else {
					return false;
				}
			},
	
			// Get element postion relative to viewport
			_getOffset: function(isLarge) {
				var el;
				if(isLarge) {
					el = mfp.currItem.img;
				} else {
					el = mfp.st.zoom.opener(mfp.currItem.el || mfp.currItem);
				}
	
				var offset = el.offset();
				var paddingTop = parseInt(el.css('padding-top'),10);
				var paddingBottom = parseInt(el.css('padding-bottom'),10);
				offset.top -= ( $(window).scrollTop() - paddingTop );
	
	
				/*
	
				Animating left + top + width/height looks glitchy in Firefox, but perfect in Chrome. And vice-versa.
	
				 */
				var obj = {
					width: el.width(),
					// fix Zepto height+padding issue
					height: (_isJQ ? el.innerHeight() : el[0].offsetHeight) - paddingBottom - paddingTop
				};
	
				// I hate to do this, but there is no another option
				if( getHasMozTransform() ) {
					obj['-moz-transform'] = obj['transform'] = 'translate(' + offset.left + 'px,' + offset.top + 'px)';
				} else {
					obj.left = offset.left;
					obj.top = offset.top;
				}
				return obj;
			}
	
		}
	});
	
	
	
	/*>>zoom*/
	
	/*>>iframe*/
	
	var IFRAME_NS = 'iframe',
		_emptyPage = '//about:blank',
	
		_fixIframeBugs = function(isShowing) {
			if(mfp.currTemplate[IFRAME_NS]) {
				var el = mfp.currTemplate[IFRAME_NS].find('iframe');
				if(el.length) {
					// reset src after the popup is closed to avoid "video keeps playing after popup is closed" bug
					if(!isShowing) {
						el[0].src = _emptyPage;
					}
	
					// IE8 black screen bug fix
					if(mfp.isIE8) {
						el.css('display', isShowing ? 'block' : 'none');
					}
				}
			}
		};
	
	$.magnificPopup.registerModule(IFRAME_NS, {
	
		options: {
			markup: '<div class="mfp-iframe-scaler">'+
						'<div class="mfp-close"></div>'+
						'<iframe class="mfp-iframe" src="//about:blank" frameborder="0" allowfullscreen></iframe>'+
					'</div>',
	
			srcAction: 'iframe_src',
	
			// we don't care and support only one default type of URL by default
			patterns: {
				youtube: {
					index: 'youtube.com',
					id: 'v=',
					src: '//www.youtube.com/embed/%id%?autoplay=1'
				},
				vimeo: {
					index: 'vimeo.com/',
					id: '/',
					src: '//player.vimeo.com/video/%id%?autoplay=1'
				},
				gmaps: {
					index: '//maps.google.',
					src: '%id%&output=embed'
				}
			}
		},
	
		proto: {
			initIframe: function() {
				mfp.types.push(IFRAME_NS);
	
				_mfpOn('BeforeChange', function(e, prevType, newType) {
					if(prevType !== newType) {
						if(prevType === IFRAME_NS) {
							_fixIframeBugs(); // iframe if removed
						} else if(newType === IFRAME_NS) {
							_fixIframeBugs(true); // iframe is showing
						}
					}// else {
						// iframe source is switched, don't do anything
					//}
				});
	
				_mfpOn(CLOSE_EVENT + '.' + IFRAME_NS, function() {
					_fixIframeBugs();
				});
			},
	
			getIframe: function(item, template) {
				var embedSrc = item.src;
				var iframeSt = mfp.st.iframe;
	
				$.each(iframeSt.patterns, function() {
					if(embedSrc.indexOf( this.index ) > -1) {
						if(this.id) {
							if(typeof this.id === 'string') {
								embedSrc = embedSrc.substr(embedSrc.lastIndexOf(this.id)+this.id.length, embedSrc.length);
							} else {
								embedSrc = this.id.call( this, embedSrc );
							}
						}
						embedSrc = this.src.replace('%id%', embedSrc );
						return false; // break;
					}
				});
	
				var dataObj = {};
				if(iframeSt.srcAction) {
					dataObj[iframeSt.srcAction] = embedSrc;
				}
				mfp._parseMarkup(template, dataObj, item);
	
				mfp.updateStatus('ready');
	
				return template;
			}
		}
	});
	
	
	
	/*>>iframe*/
	
	/*>>gallery*/
	/**
	 * Get looped index depending on number of slides
	 */
	var _getLoopedId = function(index) {
			var numSlides = mfp.items.length;
			if(index > numSlides - 1) {
				return index - numSlides;
			} else  if(index < 0) {
				return numSlides + index;
			}
			return index;
		},
		_replaceCurrTotal = function(text, curr, total) {
			return text.replace(/%curr%/gi, curr + 1).replace(/%total%/gi, total);
		};
	
	$.magnificPopup.registerModule('gallery', {
	
		options: {
			enabled: false,
			arrowMarkup: '<button title="%title%" type="button" class="mfp-arrow mfp-arrow-%dir%"></button>',
			preload: [0,2],
			navigateByImgClick: true,
			arrows: true,
	
			tPrev: 'Previous (Left arrow key)',
			tNext: 'Next (Right arrow key)',
			tCounter: '%curr% of %total%'
		},
	
		proto: {
			initGallery: function() {
	
				var gSt = mfp.st.gallery,
					ns = '.mfp-gallery';
	
				mfp.direction = true; // true - next, false - prev
	
				if(!gSt || !gSt.enabled ) return false;
	
				_wrapClasses += ' mfp-gallery';
	
				_mfpOn(OPEN_EVENT+ns, function() {
	
					if(gSt.navigateByImgClick) {
						mfp.wrap.on('click'+ns, '.mfp-img', function() {
							if(mfp.items.length > 1) {
								mfp.next();
								return false;
							}
						});
					}
	
					_document.on('keydown'+ns, function(e) {
						if (e.keyCode === 37) {
							mfp.prev();
						} else if (e.keyCode === 39) {
							mfp.next();
						}
					});
				});
	
				_mfpOn('UpdateStatus'+ns, function(e, data) {
					if(data.text) {
						data.text = _replaceCurrTotal(data.text, mfp.currItem.index, mfp.items.length);
					}
				});
	
				_mfpOn(MARKUP_PARSE_EVENT+ns, function(e, element, values, item) {
					var l = mfp.items.length;
					values.counter = l > 1 ? _replaceCurrTotal(gSt.tCounter, item.index, l) : '';
				});
	
				_mfpOn('BuildControls' + ns, function() {
					if(mfp.items.length > 1 && gSt.arrows && !mfp.arrowLeft) {
						var markup = gSt.arrowMarkup,
							arrowLeft = mfp.arrowLeft = $( markup.replace(/%title%/gi, gSt.tPrev).replace(/%dir%/gi, 'left') ).addClass(PREVENT_CLOSE_CLASS),
							arrowRight = mfp.arrowRight = $( markup.replace(/%title%/gi, gSt.tNext).replace(/%dir%/gi, 'right') ).addClass(PREVENT_CLOSE_CLASS);
	
						arrowLeft.click(function() {
							mfp.prev();
						});
						arrowRight.click(function() {
							mfp.next();
						});
	
						mfp.container.append(arrowLeft.add(arrowRight));
					}
				});
	
				_mfpOn(CHANGE_EVENT+ns, function() {
					if(mfp._preloadTimeout) clearTimeout(mfp._preloadTimeout);
	
					mfp._preloadTimeout = setTimeout(function() {
						mfp.preloadNearbyImages();
						mfp._preloadTimeout = null;
					}, 16);
				});
	
	
				_mfpOn(CLOSE_EVENT+ns, function() {
					_document.off(ns);
					mfp.wrap.off('click'+ns);
					mfp.arrowRight = mfp.arrowLeft = null;
				});
	
			},
			next: function() {
				mfp.direction = true;
				mfp.index = _getLoopedId(mfp.index + 1);
				mfp.updateItemHTML();
			},
			prev: function() {
				mfp.direction = false;
				mfp.index = _getLoopedId(mfp.index - 1);
				mfp.updateItemHTML();
			},
			goTo: function(newIndex) {
				mfp.direction = (newIndex >= mfp.index);
				mfp.index = newIndex;
				mfp.updateItemHTML();
			},
			preloadNearbyImages: function() {
				var p = mfp.st.gallery.preload,
					preloadBefore = Math.min(p[0], mfp.items.length),
					preloadAfter = Math.min(p[1], mfp.items.length),
					i;
	
				for(i = 1; i <= (mfp.direction ? preloadAfter : preloadBefore); i++) {
					mfp._preloadItem(mfp.index+i);
				}
				for(i = 1; i <= (mfp.direction ? preloadBefore : preloadAfter); i++) {
					mfp._preloadItem(mfp.index-i);
				}
			},
			_preloadItem: function(index) {
				index = _getLoopedId(index);
	
				if(mfp.items[index].preloaded) {
					return;
				}
	
				var item = mfp.items[index];
				if(!item.parsed) {
					item = mfp.parseEl( index );
				}
	
				_mfpTrigger('LazyLoad', item);
	
				if(item.type === 'image') {
					item.img = $('<img class="mfp-img" />').on('load.mfploader', function() {
						item.hasSize = true;
					}).on('error.mfploader', function() {
						item.hasSize = true;
						item.loadError = true;
						_mfpTrigger('LazyLoadError', item);
					}).attr('src', item.src);
				}
	
	
				item.preloaded = true;
			}
		}
	});
	
	/*>>gallery*/
	
	/*>>retina*/
	
	var RETINA_NS = 'retina';
	
	$.magnificPopup.registerModule(RETINA_NS, {
		options: {
			replaceSrc: function(item) {
				return item.src.replace(/\.\w+$/, function(m) { return '@2x' + m; });
			},
			ratio: 1 // Function or number.  Set to 1 to disable.
		},
		proto: {
			initRetina: function() {
				if(window.devicePixelRatio > 1) {
	
					var st = mfp.st.retina,
						ratio = st.ratio;
	
					ratio = !isNaN(ratio) ? ratio : ratio();
	
					if(ratio > 1) {
						_mfpOn('ImageHasSize' + '.' + RETINA_NS, function(e, item) {
							item.img.css({
								'max-width': item.img[0].naturalWidth / ratio,
								'width': '100%'
							});
						});
						_mfpOn('ElementParse' + '.' + RETINA_NS, function(e, item) {
							item.src = st.replaceSrc(item, ratio);
						});
					}
				}
	
			}
		}
	});
	
	/*>>retina*/
	 _checkInstance(); }));

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(28);
	__webpack_require__(29);
	
	$("._owl").owlCarousel({
	    items:1,
	    nav: true,
	    singleItem: true,
	    pagination: false,
	    lazyLoad: true,
	    loop: true,
	    animateIn: "fadeIn",
	    animateOut: "fadeOut",
	    navigationText: '',
	    autoplay:true,
	    autoplayTimeout:15000,
	    // autoplayHoverPause:true,
	    smartSpeed: 1000,
	    paginationSpeed: 100,
	    autoHeight: false,
	});
	
	$('._owl-small').owlCarousel({
	    items:1,
	    loop: true,
	    navigation: false,
	    dots: true,
	    smartSpeed: 600,
	    pagination: true,
	    rewindSpeed: 1000,
	    autoplay:true,
	    autoplayTimeout:5000,
	    // autoplayHoverPause:true,
	    autoHeight: false,
	});

/***/ }),
/* 28 */
/***/ (function(module, exports) {

	/*! modernizr 3.3.1 (Custom Build) | MIT *
	 * https://modernizr.com/download/?-csstransforms3d-setclasses !*/
	!function(e,n,t){function r(e,n){return typeof e===n}function s(){var e,n,t,s,o,i,a;for(var f in C)if(C.hasOwnProperty(f)){if(e=[],n=C[f],n.name&&(e.push(n.name.toLowerCase()),n.options&&n.options.aliases&&n.options.aliases.length))for(t=0;t<n.options.aliases.length;t++)e.push(n.options.aliases[t].toLowerCase());for(s=r(n.fn,"function")?n.fn():n.fn,o=0;o<e.length;o++)i=e[o],a=i.split("."),1===a.length?Modernizr[a[0]]=s:(!Modernizr[a[0]]||Modernizr[a[0]]instanceof Boolean||(Modernizr[a[0]]=new Boolean(Modernizr[a[0]])),Modernizr[a[0]][a[1]]=s),y.push((s?"":"no-")+a.join("-"))}}function o(e){var n=S.className,t=Modernizr._config.classPrefix||"";if(x&&(n=n.baseVal),Modernizr._config.enableJSClass){var r=new RegExp("(^|\\s)"+t+"no-js(\\s|$)");n=n.replace(r,"$1"+t+"js$2")}Modernizr._config.enableClasses&&(n+=" "+t+e.join(" "+t),x?S.className.baseVal=n:S.className=n)}function i(){return"function"!=typeof n.createElement?n.createElement(arguments[0]):x?n.createElementNS.call(n,"http://www.w3.org/2000/svg",arguments[0]):n.createElement.apply(n,arguments)}function a(){var e=n.body;return e||(e=i(x?"svg":"body"),e.fake=!0),e}function f(e,t,r,s){var o,f,l,u,p="modernizr",d=i("div"),c=a();if(parseInt(r,10))for(;r--;)l=i("div"),l.id=s?s[r]:p+(r+1),d.appendChild(l);return o=i("style"),o.type="text/css",o.id="s"+p,(c.fake?c:d).appendChild(o),c.appendChild(d),o.styleSheet?o.styleSheet.cssText=e:o.appendChild(n.createTextNode(e)),d.id=p,c.fake&&(c.style.background="",c.style.overflow="hidden",u=S.style.overflow,S.style.overflow="hidden",S.appendChild(c)),f=t(d,e),c.fake?(c.parentNode.removeChild(c),S.style.overflow=u,S.offsetHeight):d.parentNode.removeChild(d),!!f}function l(e,n){return!!~(""+e).indexOf(n)}function u(e){return e.replace(/([a-z])-([a-z])/g,function(e,n,t){return n+t.toUpperCase()}).replace(/^-/,"")}function p(e,n){return function(){return e.apply(n,arguments)}}function d(e,n,t){var s;for(var o in e)if(e[o]in n)return t===!1?e[o]:(s=n[e[o]],r(s,"function")?p(s,t||n):s);return!1}function c(e){return e.replace(/([A-Z])/g,function(e,n){return"-"+n.toLowerCase()}).replace(/^ms-/,"-ms-")}function m(n,r){var s=n.length;if("CSS"in e&&"supports"in e.CSS){for(;s--;)if(e.CSS.supports(c(n[s]),r))return!0;return!1}if("CSSSupportsRule"in e){for(var o=[];s--;)o.push("("+c(n[s])+":"+r+")");return o=o.join(" or "),f("@supports ("+o+") { #modernizr { position: absolute; } }",function(e){return"absolute"==getComputedStyle(e,null).position})}return t}function h(e,n,s,o){function a(){p&&(delete k.style,delete k.modElem)}if(o=r(o,"undefined")?!1:o,!r(s,"undefined")){var f=m(e,s);if(!r(f,"undefined"))return f}for(var p,d,c,h,v,g=["modernizr","tspan","samp"];!k.style&&g.length;)p=!0,k.modElem=i(g.shift()),k.style=k.modElem.style;for(c=e.length,d=0;c>d;d++)if(h=e[d],v=k.style[h],l(h,"-")&&(h=u(h)),k.style[h]!==t){if(o||r(s,"undefined"))return a(),"pfx"==n?h:!0;try{k.style[h]=s}catch(y){}if(k.style[h]!=v)return a(),"pfx"==n?h:!0}return a(),!1}function v(e,n,t,s,o){var i=e.charAt(0).toUpperCase()+e.slice(1),a=(e+" "+E.join(i+" ")+i).split(" ");return r(n,"string")||r(n,"undefined")?h(a,n,s,o):(a=(e+" "+N.join(i+" ")+i).split(" "),d(a,n,t))}function g(e,n,r){return v(e,t,t,n,r)}var y=[],C=[],w={_version:"3.3.1",_config:{classPrefix:"",enableClasses:!0,enableJSClass:!0,usePrefixes:!0},_q:[],on:function(e,n){var t=this;setTimeout(function(){n(t[e])},0)},addTest:function(e,n,t){C.push({name:e,fn:n,options:t})},addAsyncTest:function(e){C.push({name:null,fn:e})}},Modernizr=function(){};Modernizr.prototype=w,Modernizr=new Modernizr;var S=n.documentElement,x="svg"===S.nodeName.toLowerCase(),_="CSS"in e&&"supports"in e.CSS,b="supportsCSS"in e;Modernizr.addTest("supports",_||b);var P=w.testStyles=f,z="Moz O ms Webkit",E=w._config.usePrefixes?z.split(" "):[];w._cssomPrefixes=E;var N=w._config.usePrefixes?z.toLowerCase().split(" "):[];w._domPrefixes=N;var T={elem:i("modernizr")};Modernizr._q.push(function(){delete T.elem});var k={style:T.elem.style};Modernizr._q.unshift(function(){delete k.style}),w.testAllProps=v,w.testAllProps=g,Modernizr.addTest("csstransforms3d",function(){var e=!!g("perspective","1px",!0),n=Modernizr._config.usePrefixes;if(e&&(!n||"webkitPerspective"in S.style)){var t,r="#modernizr{width:0;height:0}";Modernizr.supports?t="@supports (perspective: 1px)":(t="@media (transform-3d)",n&&(t+=",(-webkit-transform-3d)")),t+="{#modernizr{width:7px;height:18px;margin:0;padding:0;border:0}}",P(r+t,function(n){e=7===n.offsetWidth&&18===n.offsetHeight})}return e}),s(),o(y),delete w.addTest,delete w.addAsyncTest;for(var j=0;j<Modernizr._q.length;j++)Modernizr._q[j]();e.Modernizr=Modernizr}(window,document);

/***/ }),
/* 29 */
/***/ (function(module, exports) {

	/**
	 * Owl Carousel v2.3.4
	 * Copyright 2013-2018 David Deutsch
	 * Licensed under: SEE LICENSE IN https://github.com/OwlCarousel2/OwlCarousel2/blob/master/LICENSE
	 */
	/**
	 * Owl carousel
	 * @version 2.3.4
	 * @author Bartosz Wojciechowski
	 * @author David Deutsch
	 * @license The MIT License (MIT)
	 * @todo Lazy Load Icon
	 * @todo prevent animationend bubling
	 * @todo itemsScaleUp
	 * @todo Test Zepto
	 * @todo stagePadding calculate wrong active classes
	 */
	;(function($, window, document, undefined) {
	
		/**
		 * Creates a carousel.
		 * @class The Owl Carousel.
		 * @public
		 * @param {HTMLElement|jQuery} element - The element to create the carousel for.
		 * @param {Object} [options] - The options
		 */
		function Owl(element, options) {
	
			/**
			 * Current settings for the carousel.
			 * @public
			 */
			this.settings = null;
	
			/**
			 * Current options set by the caller including defaults.
			 * @public
			 */
			this.options = $.extend({}, Owl.Defaults, options);
	
			/**
			 * Plugin element.
			 * @public
			 */
			this.$element = $(element);
	
			/**
			 * Proxied event handlers.
			 * @protected
			 */
			this._handlers = {};
	
			/**
			 * References to the running plugins of this carousel.
			 * @protected
			 */
			this._plugins = {};
	
			/**
			 * Currently suppressed events to prevent them from being retriggered.
			 * @protected
			 */
			this._supress = {};
	
			/**
			 * Absolute current position.
			 * @protected
			 */
			this._current = null;
	
			/**
			 * Animation speed in milliseconds.
			 * @protected
			 */
			this._speed = null;
	
			/**
			 * Coordinates of all items in pixel.
			 * @todo The name of this member is missleading.
			 * @protected
			 */
			this._coordinates = [];
	
			/**
			 * Current breakpoint.
			 * @todo Real media queries would be nice.
			 * @protected
			 */
			this._breakpoint = null;
	
			/**
			 * Current width of the plugin element.
			 */
			this._width = null;
	
			/**
			 * All real items.
			 * @protected
			 */
			this._items = [];
	
			/**
			 * All cloned items.
			 * @protected
			 */
			this._clones = [];
	
			/**
			 * Merge values of all items.
			 * @todo Maybe this could be part of a plugin.
			 * @protected
			 */
			this._mergers = [];
	
			/**
			 * Widths of all items.
			 */
			this._widths = [];
	
			/**
			 * Invalidated parts within the update process.
			 * @protected
			 */
			this._invalidated = {};
	
			/**
			 * Ordered list of workers for the update process.
			 * @protected
			 */
			this._pipe = [];
	
			/**
			 * Current state information for the drag operation.
			 * @todo #261
			 * @protected
			 */
			this._drag = {
				time: null,
				target: null,
				pointer: null,
				stage: {
					start: null,
					current: null
				},
				direction: null
			};
	
			/**
			 * Current state information and their tags.
			 * @type {Object}
			 * @protected
			 */
			this._states = {
				current: {},
				tags: {
					'initializing': [ 'busy' ],
					'animating': [ 'busy' ],
					'dragging': [ 'interacting' ]
				}
			};
	
			$.each([ 'onResize', 'onThrottledResize' ], $.proxy(function(i, handler) {
				this._handlers[handler] = $.proxy(this[handler], this);
			}, this));
	
			$.each(Owl.Plugins, $.proxy(function(key, plugin) {
				this._plugins[key.charAt(0).toLowerCase() + key.slice(1)]
					= new plugin(this);
			}, this));
	
			$.each(Owl.Workers, $.proxy(function(priority, worker) {
				this._pipe.push({
					'filter': worker.filter,
					'run': $.proxy(worker.run, this)
				});
			}, this));
	
			this.setup();
			this.initialize();
		}
	
		/**
		 * Default options for the carousel.
		 * @public
		 */
		Owl.Defaults = {
			items: 3,
			loop: false,
			center: false,
			rewind: false,
			checkVisibility: true,
	
			mouseDrag: true,
			touchDrag: true,
			pullDrag: true,
			freeDrag: false,
	
			margin: 0,
			stagePadding: 0,
	
			merge: false,
			mergeFit: true,
			autoWidth: false,
	
			startPosition: 0,
			rtl: false,
	
			smartSpeed: 250,
			fluidSpeed: false,
			dragEndSpeed: false,
	
			responsive: {},
			responsiveRefreshRate: 200,
			responsiveBaseElement: window,
	
			fallbackEasing: 'swing',
			slideTransition: '',
	
			info: false,
	
			nestedItemSelector: false,
			itemElement: 'div',
			stageElement: 'div',
	
			refreshClass: 'owl-refresh',
			loadedClass: 'owl-loaded',
			loadingClass: 'owl-loading',
			rtlClass: 'owl-rtl',
			responsiveClass: 'owl-responsive',
			dragClass: 'owl-drag',
			itemClass: 'owl-item',
			stageClass: 'owl-stage',
			stageOuterClass: 'owl-stage-outer',
			grabClass: 'owl-grab'
		};
	
		/**
		 * Enumeration for width.
		 * @public
		 * @readonly
		 * @enum {String}
		 */
		Owl.Width = {
			Default: 'default',
			Inner: 'inner',
			Outer: 'outer'
		};
	
		/**
		 * Enumeration for types.
		 * @public
		 * @readonly
		 * @enum {String}
		 */
		Owl.Type = {
			Event: 'event',
			State: 'state'
		};
	
		/**
		 * Contains all registered plugins.
		 * @public
		 */
		Owl.Plugins = {};
	
		/**
		 * List of workers involved in the update process.
		 */
		Owl.Workers = [ {
			filter: [ 'width', 'settings' ],
			run: function() {
				this._width = this.$element.width();
			}
		}, {
			filter: [ 'width', 'items', 'settings' ],
			run: function(cache) {
				cache.current = this._items && this._items[this.relative(this._current)];
			}
		}, {
			filter: [ 'items', 'settings' ],
			run: function() {
				this.$stage.children('.cloned').remove();
			}
		}, {
			filter: [ 'width', 'items', 'settings' ],
			run: function(cache) {
				var margin = this.settings.margin || '',
					grid = !this.settings.autoWidth,
					rtl = this.settings.rtl,
					css = {
						'width': 'auto',
						'margin-left': rtl ? margin : '',
						'margin-right': rtl ? '' : margin
					};
	
				!grid && this.$stage.children().css(css);
	
				cache.css = css;
			}
		}, {
			filter: [ 'width', 'items', 'settings' ],
			run: function(cache) {
				var width = (this.width() / this.settings.items).toFixed(3) - this.settings.margin,
					merge = null,
					iterator = this._items.length,
					grid = !this.settings.autoWidth,
					widths = [];
	
				cache.items = {
					merge: false,
					width: width
				};
	
				while (iterator--) {
					merge = this._mergers[iterator];
					merge = this.settings.mergeFit && Math.min(merge, this.settings.items) || merge;
	
					cache.items.merge = merge > 1 || cache.items.merge;
	
					widths[iterator] = !grid ? this._items[iterator].width() : width * merge;
				}
	
				this._widths = widths;
			}
		}, {
			filter: [ 'items', 'settings' ],
			run: function() {
				var clones = [],
					items = this._items,
					settings = this.settings,
					// TODO: Should be computed from number of min width items in stage
					view = Math.max(settings.items * 2, 4),
					size = Math.ceil(items.length / 2) * 2,
					repeat = settings.loop && items.length ? settings.rewind ? view : Math.max(view, size) : 0,
					append = '',
					prepend = '';
	
				repeat /= 2;
	
				while (repeat > 0) {
					// Switch to only using appended clones
					clones.push(this.normalize(clones.length / 2, true));
					append = append + items[clones[clones.length - 1]][0].outerHTML;
					clones.push(this.normalize(items.length - 1 - (clones.length - 1) / 2, true));
					prepend = items[clones[clones.length - 1]][0].outerHTML + prepend;
					repeat -= 1;
				}
	
				this._clones = clones;
	
				$(append).addClass('cloned').appendTo(this.$stage);
				$(prepend).addClass('cloned').prependTo(this.$stage);
			}
		}, {
			filter: [ 'width', 'items', 'settings' ],
			run: function() {
				var rtl = this.settings.rtl ? 1 : -1,
					size = this._clones.length + this._items.length,
					iterator = -1,
					previous = 0,
					current = 0,
					coordinates = [];
	
				while (++iterator < size) {
					previous = coordinates[iterator - 1] || 0;
					current = this._widths[this.relative(iterator)] + this.settings.margin;
					coordinates.push(previous + current * rtl);
				}
	
				this._coordinates = coordinates;
			}
		}, {
			filter: [ 'width', 'items', 'settings' ],
			run: function() {
				var padding = this.settings.stagePadding,
					coordinates = this._coordinates,
					css = {
						'width': Math.ceil(Math.abs(coordinates[coordinates.length - 1])) + padding * 2,
						'padding-left': padding || '',
						'padding-right': padding || ''
					};
	
				this.$stage.css(css);
			}
		}, {
			filter: [ 'width', 'items', 'settings' ],
			run: function(cache) {
				var iterator = this._coordinates.length,
					grid = !this.settings.autoWidth,
					items = this.$stage.children();
	
				if (grid && cache.items.merge) {
					while (iterator--) {
						cache.css.width = this._widths[this.relative(iterator)];
						items.eq(iterator).css(cache.css);
					}
				} else if (grid) {
					cache.css.width = cache.items.width;
					items.css(cache.css);
				}
			}
		}, {
			filter: [ 'items' ],
			run: function() {
				this._coordinates.length < 1 && this.$stage.removeAttr('style');
			}
		}, {
			filter: [ 'width', 'items', 'settings' ],
			run: function(cache) {
				cache.current = cache.current ? this.$stage.children().index(cache.current) : 0;
				cache.current = Math.max(this.minimum(), Math.min(this.maximum(), cache.current));
				this.reset(cache.current);
			}
		}, {
			filter: [ 'position' ],
			run: function() {
				this.animate(this.coordinates(this._current));
			}
		}, {
			filter: [ 'width', 'position', 'items', 'settings' ],
			run: function() {
				var rtl = this.settings.rtl ? 1 : -1,
					padding = this.settings.stagePadding * 2,
					begin = this.coordinates(this.current()) + padding,
					end = begin + this.width() * rtl,
					inner, outer, matches = [], i, n;
	
				for (i = 0, n = this._coordinates.length; i < n; i++) {
					inner = this._coordinates[i - 1] || 0;
					outer = Math.abs(this._coordinates[i]) + padding * rtl;
	
					if ((this.op(inner, '<=', begin) && (this.op(inner, '>', end)))
						|| (this.op(outer, '<', begin) && this.op(outer, '>', end))) {
						matches.push(i);
					}
				}
	
				this.$stage.children('.active').removeClass('active');
				this.$stage.children(':eq(' + matches.join('), :eq(') + ')').addClass('active');
	
				this.$stage.children('.center').removeClass('center');
				if (this.settings.center) {
					this.$stage.children().eq(this.current()).addClass('center');
				}
			}
		} ];
	
		/**
		 * Create the stage DOM element
		 */
		Owl.prototype.initializeStage = function() {
			this.$stage = this.$element.find('.' + this.settings.stageClass);
	
			// if the stage is already in the DOM, grab it and skip stage initialization
			if (this.$stage.length) {
				return;
			}
	
			this.$element.addClass(this.options.loadingClass);
	
			// create stage
			this.$stage = $('<' + this.settings.stageElement + '>', {
				"class": this.settings.stageClass
			}).wrap( $( '<div/>', {
				"class": this.settings.stageOuterClass
			}));
	
			// append stage
			this.$element.append(this.$stage.parent());
		};
	
		/**
		 * Create item DOM elements
		 */
		Owl.prototype.initializeItems = function() {
			var $items = this.$element.find('.owl-item');
	
			// if the items are already in the DOM, grab them and skip item initialization
			if ($items.length) {
				this._items = $items.get().map(function(item) {
					return $(item);
				});
	
				this._mergers = this._items.map(function() {
					return 1;
				});
	
				this.refresh();
	
				return;
			}
	
			// append content
			this.replace(this.$element.children().not(this.$stage.parent()));
	
			// check visibility
			if (this.isVisible()) {
				// update view
				this.refresh();
			} else {
				// invalidate width
				this.invalidate('width');
			}
	
			this.$element
				.removeClass(this.options.loadingClass)
				.addClass(this.options.loadedClass);
		};
	
		/**
		 * Initializes the carousel.
		 * @protected
		 */
		Owl.prototype.initialize = function() {
			this.enter('initializing');
			this.trigger('initialize');
	
			this.$element.toggleClass(this.settings.rtlClass, this.settings.rtl);
	
			if (this.settings.autoWidth && !this.is('pre-loading')) {
				var imgs, nestedSelector, width;
				imgs = this.$element.find('img');
				nestedSelector = this.settings.nestedItemSelector ? '.' + this.settings.nestedItemSelector : undefined;
				width = this.$element.children(nestedSelector).width();
	
				if (imgs.length && width <= 0) {
					this.preloadAutoWidthImages(imgs);
				}
			}
	
			this.initializeStage();
			this.initializeItems();
	
			// register event handlers
			this.registerEventHandlers();
	
			this.leave('initializing');
			this.trigger('initialized');
		};
	
		/**
		 * @returns {Boolean} visibility of $element
		 *                    if you know the carousel will always be visible you can set `checkVisibility` to `false` to
		 *                    prevent the expensive browser layout forced reflow the $element.is(':visible') does
		 */
		Owl.prototype.isVisible = function() {
			return this.settings.checkVisibility
				? this.$element.is(':visible')
				: true;
		};
	
		/**
		 * Setups the current settings.
		 * @todo Remove responsive classes. Why should adaptive designs be brought into IE8?
		 * @todo Support for media queries by using `matchMedia` would be nice.
		 * @public
		 */
		Owl.prototype.setup = function() {
			var viewport = this.viewport(),
				overwrites = this.options.responsive,
				match = -1,
				settings = null;
	
			if (!overwrites) {
				settings = $.extend({}, this.options);
			} else {
				$.each(overwrites, function(breakpoint) {
					if (breakpoint <= viewport && breakpoint > match) {
						match = Number(breakpoint);
					}
				});
	
				settings = $.extend({}, this.options, overwrites[match]);
				if (typeof settings.stagePadding === 'function') {
					settings.stagePadding = settings.stagePadding();
				}
				delete settings.responsive;
	
				// responsive class
				if (settings.responsiveClass) {
					this.$element.attr('class',
						this.$element.attr('class').replace(new RegExp('(' + this.options.responsiveClass + '-)\\S+\\s', 'g'), '$1' + match)
					);
				}
			}
	
			this.trigger('change', { property: { name: 'settings', value: settings } });
			this._breakpoint = match;
			this.settings = settings;
			this.invalidate('settings');
			this.trigger('changed', { property: { name: 'settings', value: this.settings } });
		};
	
		/**
		 * Updates option logic if necessery.
		 * @protected
		 */
		Owl.prototype.optionsLogic = function() {
			if (this.settings.autoWidth) {
				this.settings.stagePadding = false;
				this.settings.merge = false;
			}
		};
	
		/**
		 * Prepares an item before add.
		 * @todo Rename event parameter `content` to `item`.
		 * @protected
		 * @returns {jQuery|HTMLElement} - The item container.
		 */
		Owl.prototype.prepare = function(item) {
			var event = this.trigger('prepare', { content: item });
	
			if (!event.data) {
				event.data = $('<' + this.settings.itemElement + '/>')
					.addClass(this.options.itemClass).append(item)
			}
	
			this.trigger('prepared', { content: event.data });
	
			return event.data;
		};
	
		/**
		 * Updates the view.
		 * @public
		 */
		Owl.prototype.update = function() {
			var i = 0,
				n = this._pipe.length,
				filter = $.proxy(function(p) { return this[p] }, this._invalidated),
				cache = {};
	
			while (i < n) {
				if (this._invalidated.all || $.grep(this._pipe[i].filter, filter).length > 0) {
					this._pipe[i].run(cache);
				}
				i++;
			}
	
			this._invalidated = {};
	
			!this.is('valid') && this.enter('valid');
		};
	
		/**
		 * Gets the width of the view.
		 * @public
		 * @param {Owl.Width} [dimension=Owl.Width.Default] - The dimension to return.
		 * @returns {Number} - The width of the view in pixel.
		 */
		Owl.prototype.width = function(dimension) {
			dimension = dimension || Owl.Width.Default;
			switch (dimension) {
				case Owl.Width.Inner:
				case Owl.Width.Outer:
					return this._width;
				default:
					return this._width - this.settings.stagePadding * 2 + this.settings.margin;
			}
		};
	
		/**
		 * Refreshes the carousel primarily for adaptive purposes.
		 * @public
		 */
		Owl.prototype.refresh = function() {
			this.enter('refreshing');
			this.trigger('refresh');
	
			this.setup();
	
			this.optionsLogic();
	
			this.$element.addClass(this.options.refreshClass);
	
			this.update();
	
			this.$element.removeClass(this.options.refreshClass);
	
			this.leave('refreshing');
			this.trigger('refreshed');
		};
	
		/**
		 * Checks window `resize` event.
		 * @protected
		 */
		Owl.prototype.onThrottledResize = function() {
			window.clearTimeout(this.resizeTimer);
			this.resizeTimer = window.setTimeout(this._handlers.onResize, this.settings.responsiveRefreshRate);
		};
	
		/**
		 * Checks window `resize` event.
		 * @protected
		 */
		Owl.prototype.onResize = function() {
			if (!this._items.length) {
				return false;
			}
	
			if (this._width === this.$element.width()) {
				return false;
			}
	
			if (!this.isVisible()) {
				return false;
			}
	
			this.enter('resizing');
	
			if (this.trigger('resize').isDefaultPrevented()) {
				this.leave('resizing');
				return false;
			}
	
			this.invalidate('width');
	
			this.refresh();
	
			this.leave('resizing');
			this.trigger('resized');
		};
	
		/**
		 * Registers event handlers.
		 * @todo Check `msPointerEnabled`
		 * @todo #261
		 * @protected
		 */
		Owl.prototype.registerEventHandlers = function() {
			if ($.support.transition) {
				this.$stage.on($.support.transition.end + '.owl.core', $.proxy(this.onTransitionEnd, this));
			}
	
			if (this.settings.responsive !== false) {
				this.on(window, 'resize', this._handlers.onThrottledResize);
			}
	
			if (this.settings.mouseDrag) {
				this.$element.addClass(this.options.dragClass);
				this.$stage.on('mousedown.owl.core', $.proxy(this.onDragStart, this));
				this.$stage.on('dragstart.owl.core selectstart.owl.core', function() { return false });
			}
	
			if (this.settings.touchDrag){
				this.$stage.on('touchstart.owl.core', $.proxy(this.onDragStart, this));
				this.$stage.on('touchcancel.owl.core', $.proxy(this.onDragEnd, this));
			}
		};
	
		/**
		 * Handles `touchstart` and `mousedown` events.
		 * @todo Horizontal swipe threshold as option
		 * @todo #261
		 * @protected
		 * @param {Event} event - The event arguments.
		 */
		Owl.prototype.onDragStart = function(event) {
			var stage = null;
	
			if (event.which === 3) {
				return;
			}
	
			if ($.support.transform) {
				stage = this.$stage.css('transform').replace(/.*\(|\)| /g, '').split(',');
				stage = {
					x: stage[stage.length === 16 ? 12 : 4],
					y: stage[stage.length === 16 ? 13 : 5]
				};
			} else {
				stage = this.$stage.position();
				stage = {
					x: this.settings.rtl ?
						stage.left + this.$stage.width() - this.width() + this.settings.margin :
						stage.left,
					y: stage.top
				};
			}
	
			if (this.is('animating')) {
				$.support.transform ? this.animate(stage.x) : this.$stage.stop()
				this.invalidate('position');
			}
	
			this.$element.toggleClass(this.options.grabClass, event.type === 'mousedown');
	
			this.speed(0);
	
			this._drag.time = new Date().getTime();
			this._drag.target = $(event.target);
			this._drag.stage.start = stage;
			this._drag.stage.current = stage;
			this._drag.pointer = this.pointer(event);
	
			$(document).on('mouseup.owl.core touchend.owl.core', $.proxy(this.onDragEnd, this));
	
			$(document).one('mousemove.owl.core touchmove.owl.core', $.proxy(function(event) {
				var delta = this.difference(this._drag.pointer, this.pointer(event));
	
				$(document).on('mousemove.owl.core touchmove.owl.core', $.proxy(this.onDragMove, this));
	
				if (Math.abs(delta.x) < Math.abs(delta.y) && this.is('valid')) {
					return;
				}
	
				event.preventDefault();
	
				this.enter('dragging');
				this.trigger('drag');
			}, this));
		};
	
		/**
		 * Handles the `touchmove` and `mousemove` events.
		 * @todo #261
		 * @protected
		 * @param {Event} event - The event arguments.
		 */
		Owl.prototype.onDragMove = function(event) {
			var minimum = null,
				maximum = null,
				pull = null,
				delta = this.difference(this._drag.pointer, this.pointer(event)),
				stage = this.difference(this._drag.stage.start, delta);
	
			if (!this.is('dragging')) {
				return;
			}
	
			event.preventDefault();
	
			if (this.settings.loop) {
				minimum = this.coordinates(this.minimum());
				maximum = this.coordinates(this.maximum() + 1) - minimum;
				stage.x = (((stage.x - minimum) % maximum + maximum) % maximum) + minimum;
			} else {
				minimum = this.settings.rtl ? this.coordinates(this.maximum()) : this.coordinates(this.minimum());
				maximum = this.settings.rtl ? this.coordinates(this.minimum()) : this.coordinates(this.maximum());
				pull = this.settings.pullDrag ? -1 * delta.x / 5 : 0;
				stage.x = Math.max(Math.min(stage.x, minimum + pull), maximum + pull);
			}
	
			this._drag.stage.current = stage;
	
			this.animate(stage.x);
		};
	
		/**
		 * Handles the `touchend` and `mouseup` events.
		 * @todo #261
		 * @todo Threshold for click event
		 * @protected
		 * @param {Event} event - The event arguments.
		 */
		Owl.prototype.onDragEnd = function(event) {
			var delta = this.difference(this._drag.pointer, this.pointer(event)),
				stage = this._drag.stage.current,
				direction = delta.x > 0 ^ this.settings.rtl ? 'left' : 'right';
	
			$(document).off('.owl.core');
	
			this.$element.removeClass(this.options.grabClass);
	
			if (delta.x !== 0 && this.is('dragging') || !this.is('valid')) {
				this.speed(this.settings.dragEndSpeed || this.settings.smartSpeed);
				this.current(this.closest(stage.x, delta.x !== 0 ? direction : this._drag.direction));
				this.invalidate('position');
				this.update();
	
				this._drag.direction = direction;
	
				if (Math.abs(delta.x) > 3 || new Date().getTime() - this._drag.time > 300) {
					this._drag.target.one('click.owl.core', function() { return false; });
				}
			}
	
			if (!this.is('dragging')) {
				return;
			}
	
			this.leave('dragging');
			this.trigger('dragged');
		};
	
		/**
		 * Gets absolute position of the closest item for a coordinate.
		 * @todo Setting `freeDrag` makes `closest` not reusable. See #165.
		 * @protected
		 * @param {Number} coordinate - The coordinate in pixel.
		 * @param {String} direction - The direction to check for the closest item. Ether `left` or `right`.
		 * @return {Number} - The absolute position of the closest item.
		 */
		Owl.prototype.closest = function(coordinate, direction) {
			var position = -1,
				pull = 30,
				width = this.width(),
				coordinates = this.coordinates();
	
			if (!this.settings.freeDrag) {
				// check closest item
				$.each(coordinates, $.proxy(function(index, value) {
					// on a left pull, check on current index
					if (direction === 'left' && coordinate > value - pull && coordinate < value + pull) {
						position = index;
					// on a right pull, check on previous index
					// to do so, subtract width from value and set position = index + 1
					} else if (direction === 'right' && coordinate > value - width - pull && coordinate < value - width + pull) {
						position = index + 1;
					} else if (this.op(coordinate, '<', value)
						&& this.op(coordinate, '>', coordinates[index + 1] !== undefined ? coordinates[index + 1] : value - width)) {
						position = direction === 'left' ? index + 1 : index;
					}
					return position === -1;
				}, this));
			}
	
			if (!this.settings.loop) {
				// non loop boundries
				if (this.op(coordinate, '>', coordinates[this.minimum()])) {
					position = coordinate = this.minimum();
				} else if (this.op(coordinate, '<', coordinates[this.maximum()])) {
					position = coordinate = this.maximum();
				}
			}
	
			return position;
		};
	
		/**
		 * Animates the stage.
		 * @todo #270
		 * @public
		 * @param {Number} coordinate - The coordinate in pixels.
		 */
		Owl.prototype.animate = function(coordinate) {
			var animate = this.speed() > 0;
	
			this.is('animating') && this.onTransitionEnd();
	
			if (animate) {
				this.enter('animating');
				this.trigger('translate');
			}
	
			if ($.support.transform3d && $.support.transition) {
				this.$stage.css({
					transform: 'translate3d(' + coordinate + 'px,0px,0px)',
					transition: (this.speed() / 1000) + 's' + (
						this.settings.slideTransition ? ' ' + this.settings.slideTransition : ''
					)
				});
			} else if (animate) {
				this.$stage.animate({
					left: coordinate + 'px'
				}, this.speed(), this.settings.fallbackEasing, $.proxy(this.onTransitionEnd, this));
			} else {
				this.$stage.css({
					left: coordinate + 'px'
				});
			}
		};
	
		/**
		 * Checks whether the carousel is in a specific state or not.
		 * @param {String} state - The state to check.
		 * @returns {Boolean} - The flag which indicates if the carousel is busy.
		 */
		Owl.prototype.is = function(state) {
			return this._states.current[state] && this._states.current[state] > 0;
		};
	
		/**
		 * Sets the absolute position of the current item.
		 * @public
		 * @param {Number} [position] - The new absolute position or nothing to leave it unchanged.
		 * @returns {Number} - The absolute position of the current item.
		 */
		Owl.prototype.current = function(position) {
			if (position === undefined) {
				return this._current;
			}
	
			if (this._items.length === 0) {
				return undefined;
			}
	
			position = this.normalize(position);
	
			if (this._current !== position) {
				var event = this.trigger('change', { property: { name: 'position', value: position } });
	
				if (event.data !== undefined) {
					position = this.normalize(event.data);
				}
	
				this._current = position;
	
				this.invalidate('position');
	
				this.trigger('changed', { property: { name: 'position', value: this._current } });
			}
	
			return this._current;
		};
	
		/**
		 * Invalidates the given part of the update routine.
		 * @param {String} [part] - The part to invalidate.
		 * @returns {Array.<String>} - The invalidated parts.
		 */
		Owl.prototype.invalidate = function(part) {
			if ($.type(part) === 'string') {
				this._invalidated[part] = true;
				this.is('valid') && this.leave('valid');
			}
			return $.map(this._invalidated, function(v, i) { return i });
		};
	
		/**
		 * Resets the absolute position of the current item.
		 * @public
		 * @param {Number} position - The absolute position of the new item.
		 */
		Owl.prototype.reset = function(position) {
			position = this.normalize(position);
	
			if (position === undefined) {
				return;
			}
	
			this._speed = 0;
			this._current = position;
	
			this.suppress([ 'translate', 'translated' ]);
	
			this.animate(this.coordinates(position));
	
			this.release([ 'translate', 'translated' ]);
		};
	
		/**
		 * Normalizes an absolute or a relative position of an item.
		 * @public
		 * @param {Number} position - The absolute or relative position to normalize.
		 * @param {Boolean} [relative=false] - Whether the given position is relative or not.
		 * @returns {Number} - The normalized position.
		 */
		Owl.prototype.normalize = function(position, relative) {
			var n = this._items.length,
				m = relative ? 0 : this._clones.length;
	
			if (!this.isNumeric(position) || n < 1) {
				position = undefined;
			} else if (position < 0 || position >= n + m) {
				position = ((position - m / 2) % n + n) % n + m / 2;
			}
	
			return position;
		};
	
		/**
		 * Converts an absolute position of an item into a relative one.
		 * @public
		 * @param {Number} position - The absolute position to convert.
		 * @returns {Number} - The converted position.
		 */
		Owl.prototype.relative = function(position) {
			position -= this._clones.length / 2;
			return this.normalize(position, true);
		};
	
		/**
		 * Gets the maximum position for the current item.
		 * @public
		 * @param {Boolean} [relative=false] - Whether to return an absolute position or a relative position.
		 * @returns {Number}
		 */
		Owl.prototype.maximum = function(relative) {
			var settings = this.settings,
				maximum = this._coordinates.length,
				iterator,
				reciprocalItemsWidth,
				elementWidth;
	
			if (settings.loop) {
				maximum = this._clones.length / 2 + this._items.length - 1;
			} else if (settings.autoWidth || settings.merge) {
				iterator = this._items.length;
				if (iterator) {
					reciprocalItemsWidth = this._items[--iterator].width();
					elementWidth = this.$element.width();
					while (iterator--) {
						reciprocalItemsWidth += this._items[iterator].width() + this.settings.margin;
						if (reciprocalItemsWidth > elementWidth) {
							break;
						}
					}
				}
				maximum = iterator + 1;
			} else if (settings.center) {
				maximum = this._items.length - 1;
			} else {
				maximum = this._items.length - settings.items;
			}
	
			if (relative) {
				maximum -= this._clones.length / 2;
			}
	
			return Math.max(maximum, 0);
		};
	
		/**
		 * Gets the minimum position for the current item.
		 * @public
		 * @param {Boolean} [relative=false] - Whether to return an absolute position or a relative position.
		 * @returns {Number}
		 */
		Owl.prototype.minimum = function(relative) {
			return relative ? 0 : this._clones.length / 2;
		};
	
		/**
		 * Gets an item at the specified relative position.
		 * @public
		 * @param {Number} [position] - The relative position of the item.
		 * @return {jQuery|Array.<jQuery>} - The item at the given position or all items if no position was given.
		 */
		Owl.prototype.items = function(position) {
			if (position === undefined) {
				return this._items.slice();
			}
	
			position = this.normalize(position, true);
			return this._items[position];
		};
	
		/**
		 * Gets an item at the specified relative position.
		 * @public
		 * @param {Number} [position] - The relative position of the item.
		 * @return {jQuery|Array.<jQuery>} - The item at the given position or all items if no position was given.
		 */
		Owl.prototype.mergers = function(position) {
			if (position === undefined) {
				return this._mergers.slice();
			}
	
			position = this.normalize(position, true);
			return this._mergers[position];
		};
	
		/**
		 * Gets the absolute positions of clones for an item.
		 * @public
		 * @param {Number} [position] - The relative position of the item.
		 * @returns {Array.<Number>} - The absolute positions of clones for the item or all if no position was given.
		 */
		Owl.prototype.clones = function(position) {
			var odd = this._clones.length / 2,
				even = odd + this._items.length,
				map = function(index) { return index % 2 === 0 ? even + index / 2 : odd - (index + 1) / 2 };
	
			if (position === undefined) {
				return $.map(this._clones, function(v, i) { return map(i) });
			}
	
			return $.map(this._clones, function(v, i) { return v === position ? map(i) : null });
		};
	
		/**
		 * Sets the current animation speed.
		 * @public
		 * @param {Number} [speed] - The animation speed in milliseconds or nothing to leave it unchanged.
		 * @returns {Number} - The current animation speed in milliseconds.
		 */
		Owl.prototype.speed = function(speed) {
			if (speed !== undefined) {
				this._speed = speed;
			}
	
			return this._speed;
		};
	
		/**
		 * Gets the coordinate of an item.
		 * @todo The name of this method is missleanding.
		 * @public
		 * @param {Number} position - The absolute position of the item within `minimum()` and `maximum()`.
		 * @returns {Number|Array.<Number>} - The coordinate of the item in pixel or all coordinates.
		 */
		Owl.prototype.coordinates = function(position) {
			var multiplier = 1,
				newPosition = position - 1,
				coordinate;
	
			if (position === undefined) {
				return $.map(this._coordinates, $.proxy(function(coordinate, index) {
					return this.coordinates(index);
				}, this));
			}
	
			if (this.settings.center) {
				if (this.settings.rtl) {
					multiplier = -1;
					newPosition = position + 1;
				}
	
				coordinate = this._coordinates[position];
				coordinate += (this.width() - coordinate + (this._coordinates[newPosition] || 0)) / 2 * multiplier;
			} else {
				coordinate = this._coordinates[newPosition] || 0;
			}
	
			coordinate = Math.ceil(coordinate);
	
			return coordinate;
		};
	
		/**
		 * Calculates the speed for a translation.
		 * @protected
		 * @param {Number} from - The absolute position of the start item.
		 * @param {Number} to - The absolute position of the target item.
		 * @param {Number} [factor=undefined] - The time factor in milliseconds.
		 * @returns {Number} - The time in milliseconds for the translation.
		 */
		Owl.prototype.duration = function(from, to, factor) {
			if (factor === 0) {
				return 0;
			}
	
			return Math.min(Math.max(Math.abs(to - from), 1), 6) * Math.abs((factor || this.settings.smartSpeed));
		};
	
		/**
		 * Slides to the specified item.
		 * @public
		 * @param {Number} position - The position of the item.
		 * @param {Number} [speed] - The time in milliseconds for the transition.
		 */
		Owl.prototype.to = function(position, speed) {
			var current = this.current(),
				revert = null,
				distance = position - this.relative(current),
				direction = (distance > 0) - (distance < 0),
				items = this._items.length,
				minimum = this.minimum(),
				maximum = this.maximum();
	
			if (this.settings.loop) {
				if (!this.settings.rewind && Math.abs(distance) > items / 2) {
					distance += direction * -1 * items;
				}
	
				position = current + distance;
				revert = ((position - minimum) % items + items) % items + minimum;
	
				if (revert !== position && revert - distance <= maximum && revert - distance > 0) {
					current = revert - distance;
					position = revert;
					this.reset(current);
				}
			} else if (this.settings.rewind) {
				maximum += 1;
				position = (position % maximum + maximum) % maximum;
			} else {
				position = Math.max(minimum, Math.min(maximum, position));
			}
	
			this.speed(this.duration(current, position, speed));
			this.current(position);
	
			if (this.isVisible()) {
				this.update();
			}
		};
	
		/**
		 * Slides to the next item.
		 * @public
		 * @param {Number} [speed] - The time in milliseconds for the transition.
		 */
		Owl.prototype.next = function(speed) {
			speed = speed || false;
			this.to(this.relative(this.current()) + 1, speed);
		};
	
		/**
		 * Slides to the previous item.
		 * @public
		 * @param {Number} [speed] - The time in milliseconds for the transition.
		 */
		Owl.prototype.prev = function(speed) {
			speed = speed || false;
			this.to(this.relative(this.current()) - 1, speed);
		};
	
		/**
		 * Handles the end of an animation.
		 * @protected
		 * @param {Event} event - The event arguments.
		 */
		Owl.prototype.onTransitionEnd = function(event) {
	
			// if css2 animation then event object is undefined
			if (event !== undefined) {
				event.stopPropagation();
	
				// Catch only owl-stage transitionEnd event
				if ((event.target || event.srcElement || event.originalTarget) !== this.$stage.get(0)) {
					return false;
				}
			}
	
			this.leave('animating');
			this.trigger('translated');
		};
	
		/**
		 * Gets viewport width.
		 * @protected
		 * @return {Number} - The width in pixel.
		 */
		Owl.prototype.viewport = function() {
			var width;
			if (this.options.responsiveBaseElement !== window) {
				width = $(this.options.responsiveBaseElement).width();
			} else if (window.innerWidth) {
				width = window.innerWidth;
			} else if (document.documentElement && document.documentElement.clientWidth) {
				width = document.documentElement.clientWidth;
			} else {
				console.warn('Can not detect viewport width.');
			}
			return width;
		};
	
		/**
		 * Replaces the current content.
		 * @public
		 * @param {HTMLElement|jQuery|String} content - The new content.
		 */
		Owl.prototype.replace = function(content) {
			this.$stage.empty();
			this._items = [];
	
			if (content) {
				content = (content instanceof jQuery) ? content : $(content);
			}
	
			if (this.settings.nestedItemSelector) {
				content = content.find('.' + this.settings.nestedItemSelector);
			}
	
			content.filter(function() {
				return this.nodeType === 1;
			}).each($.proxy(function(index, item) {
				item = this.prepare(item);
				this.$stage.append(item);
				this._items.push(item);
				this._mergers.push(item.find('[data-merge]').addBack('[data-merge]').attr('data-merge') * 1 || 1);
			}, this));
	
			this.reset(this.isNumeric(this.settings.startPosition) ? this.settings.startPosition : 0);
	
			this.invalidate('items');
		};
	
		/**
		 * Adds an item.
		 * @todo Use `item` instead of `content` for the event arguments.
		 * @public
		 * @param {HTMLElement|jQuery|String} content - The item content to add.
		 * @param {Number} [position] - The relative position at which to insert the item otherwise the item will be added to the end.
		 */
		Owl.prototype.add = function(content, position) {
			var current = this.relative(this._current);
	
			position = position === undefined ? this._items.length : this.normalize(position, true);
			content = content instanceof jQuery ? content : $(content);
	
			this.trigger('add', { content: content, position: position });
	
			content = this.prepare(content);
	
			if (this._items.length === 0 || position === this._items.length) {
				this._items.length === 0 && this.$stage.append(content);
				this._items.length !== 0 && this._items[position - 1].after(content);
				this._items.push(content);
				this._mergers.push(content.find('[data-merge]').addBack('[data-merge]').attr('data-merge') * 1 || 1);
			} else {
				this._items[position].before(content);
				this._items.splice(position, 0, content);
				this._mergers.splice(position, 0, content.find('[data-merge]').addBack('[data-merge]').attr('data-merge') * 1 || 1);
			}
	
			this._items[current] && this.reset(this._items[current].index());
	
			this.invalidate('items');
	
			this.trigger('added', { content: content, position: position });
		};
	
		/**
		 * Removes an item by its position.
		 * @todo Use `item` instead of `content` for the event arguments.
		 * @public
		 * @param {Number} position - The relative position of the item to remove.
		 */
		Owl.prototype.remove = function(position) {
			position = this.normalize(position, true);
	
			if (position === undefined) {
				return;
			}
	
			this.trigger('remove', { content: this._items[position], position: position });
	
			this._items[position].remove();
			this._items.splice(position, 1);
			this._mergers.splice(position, 1);
	
			this.invalidate('items');
	
			this.trigger('removed', { content: null, position: position });
		};
	
		/**
		 * Preloads images with auto width.
		 * @todo Replace by a more generic approach
		 * @protected
		 */
		Owl.prototype.preloadAutoWidthImages = function(images) {
			images.each($.proxy(function(i, element) {
				this.enter('pre-loading');
				element = $(element);
				$(new Image()).one('load', $.proxy(function(e) {
					element.attr('src', e.target.src);
					element.css('opacity', 1);
					this.leave('pre-loading');
					!this.is('pre-loading') && !this.is('initializing') && this.refresh();
				}, this)).attr('src', element.attr('src') || element.attr('data-src') || element.attr('data-src-retina'));
			}, this));
		};
	
		/**
		 * Destroys the carousel.
		 * @public
		 */
		Owl.prototype.destroy = function() {
	
			this.$element.off('.owl.core');
			this.$stage.off('.owl.core');
			$(document).off('.owl.core');
	
			if (this.settings.responsive !== false) {
				window.clearTimeout(this.resizeTimer);
				this.off(window, 'resize', this._handlers.onThrottledResize);
			}
	
			for (var i in this._plugins) {
				this._plugins[i].destroy();
			}
	
			this.$stage.children('.cloned').remove();
	
			this.$stage.unwrap();
			this.$stage.children().contents().unwrap();
			this.$stage.children().unwrap();
			this.$stage.remove();
			this.$element
				.removeClass(this.options.refreshClass)
				.removeClass(this.options.loadingClass)
				.removeClass(this.options.loadedClass)
				.removeClass(this.options.rtlClass)
				.removeClass(this.options.dragClass)
				.removeClass(this.options.grabClass)
				.attr('class', this.$element.attr('class').replace(new RegExp(this.options.responsiveClass + '-\\S+\\s', 'g'), ''))
				.removeData('owl.carousel');
		};
	
		/**
		 * Operators to calculate right-to-left and left-to-right.
		 * @protected
		 * @param {Number} [a] - The left side operand.
		 * @param {String} [o] - The operator.
		 * @param {Number} [b] - The right side operand.
		 */
		Owl.prototype.op = function(a, o, b) {
			var rtl = this.settings.rtl;
			switch (o) {
				case '<':
					return rtl ? a > b : a < b;
				case '>':
					return rtl ? a < b : a > b;
				case '>=':
					return rtl ? a <= b : a >= b;
				case '<=':
					return rtl ? a >= b : a <= b;
				default:
					break;
			}
		};
	
		/**
		 * Attaches to an internal event.
		 * @protected
		 * @param {HTMLElement} element - The event source.
		 * @param {String} event - The event name.
		 * @param {Function} listener - The event handler to attach.
		 * @param {Boolean} capture - Wether the event should be handled at the capturing phase or not.
		 */
		Owl.prototype.on = function(element, event, listener, capture) {
			if (element.addEventListener) {
				element.addEventListener(event, listener, capture);
			} else if (element.attachEvent) {
				element.attachEvent('on' + event, listener);
			}
		};
	
		/**
		 * Detaches from an internal event.
		 * @protected
		 * @param {HTMLElement} element - The event source.
		 * @param {String} event - The event name.
		 * @param {Function} listener - The attached event handler to detach.
		 * @param {Boolean} capture - Wether the attached event handler was registered as a capturing listener or not.
		 */
		Owl.prototype.off = function(element, event, listener, capture) {
			if (element.removeEventListener) {
				element.removeEventListener(event, listener, capture);
			} else if (element.detachEvent) {
				element.detachEvent('on' + event, listener);
			}
		};
	
		/**
		 * Triggers a public event.
		 * @todo Remove `status`, `relatedTarget` should be used instead.
		 * @protected
		 * @param {String} name - The event name.
		 * @param {*} [data=null] - The event data.
		 * @param {String} [namespace=carousel] - The event namespace.
		 * @param {String} [state] - The state which is associated with the event.
		 * @param {Boolean} [enter=false] - Indicates if the call enters the specified state or not.
		 * @returns {Event} - The event arguments.
		 */
		Owl.prototype.trigger = function(name, data, namespace, state, enter) {
			var status = {
				item: { count: this._items.length, index: this.current() }
			}, handler = $.camelCase(
				$.grep([ 'on', name, namespace ], function(v) { return v })
					.join('-').toLowerCase()
			), event = $.Event(
				[ name, 'owl', namespace || 'carousel' ].join('.').toLowerCase(),
				$.extend({ relatedTarget: this }, status, data)
			);
	
			if (!this._supress[name]) {
				$.each(this._plugins, function(name, plugin) {
					if (plugin.onTrigger) {
						plugin.onTrigger(event);
					}
				});
	
				this.register({ type: Owl.Type.Event, name: name });
				this.$element.trigger(event);
	
				if (this.settings && typeof this.settings[handler] === 'function') {
					this.settings[handler].call(this, event);
				}
			}
	
			return event;
		};
	
		/**
		 * Enters a state.
		 * @param name - The state name.
		 */
		Owl.prototype.enter = function(name) {
			$.each([ name ].concat(this._states.tags[name] || []), $.proxy(function(i, name) {
				if (this._states.current[name] === undefined) {
					this._states.current[name] = 0;
				}
	
				this._states.current[name]++;
			}, this));
		};
	
		/**
		 * Leaves a state.
		 * @param name - The state name.
		 */
		Owl.prototype.leave = function(name) {
			$.each([ name ].concat(this._states.tags[name] || []), $.proxy(function(i, name) {
				this._states.current[name]--;
			}, this));
		};
	
		/**
		 * Registers an event or state.
		 * @public
		 * @param {Object} object - The event or state to register.
		 */
		Owl.prototype.register = function(object) {
			if (object.type === Owl.Type.Event) {
				if (!$.event.special[object.name]) {
					$.event.special[object.name] = {};
				}
	
				if (!$.event.special[object.name].owl) {
					var _default = $.event.special[object.name]._default;
					$.event.special[object.name]._default = function(e) {
						if (_default && _default.apply && (!e.namespace || e.namespace.indexOf('owl') === -1)) {
							return _default.apply(this, arguments);
						}
						return e.namespace && e.namespace.indexOf('owl') > -1;
					};
					$.event.special[object.name].owl = true;
				}
			} else if (object.type === Owl.Type.State) {
				if (!this._states.tags[object.name]) {
					this._states.tags[object.name] = object.tags;
				} else {
					this._states.tags[object.name] = this._states.tags[object.name].concat(object.tags);
				}
	
				this._states.tags[object.name] = $.grep(this._states.tags[object.name], $.proxy(function(tag, i) {
					return $.inArray(tag, this._states.tags[object.name]) === i;
				}, this));
			}
		};
	
		/**
		 * Suppresses events.
		 * @protected
		 * @param {Array.<String>} events - The events to suppress.
		 */
		Owl.prototype.suppress = function(events) {
			$.each(events, $.proxy(function(index, event) {
				this._supress[event] = true;
			}, this));
		};
	
		/**
		 * Releases suppressed events.
		 * @protected
		 * @param {Array.<String>} events - The events to release.
		 */
		Owl.prototype.release = function(events) {
			$.each(events, $.proxy(function(index, event) {
				delete this._supress[event];
			}, this));
		};
	
		/**
		 * Gets unified pointer coordinates from event.
		 * @todo #261
		 * @protected
		 * @param {Event} - The `mousedown` or `touchstart` event.
		 * @returns {Object} - Contains `x` and `y` coordinates of current pointer position.
		 */
		Owl.prototype.pointer = function(event) {
			var result = { x: null, y: null };
	
			event = event.originalEvent || event || window.event;
	
			event = event.touches && event.touches.length ?
				event.touches[0] : event.changedTouches && event.changedTouches.length ?
					event.changedTouches[0] : event;
	
			if (event.pageX) {
				result.x = event.pageX;
				result.y = event.pageY;
			} else {
				result.x = event.clientX;
				result.y = event.clientY;
			}
	
			return result;
		};
	
		/**
		 * Determines if the input is a Number or something that can be coerced to a Number
		 * @protected
		 * @param {Number|String|Object|Array|Boolean|RegExp|Function|Symbol} - The input to be tested
		 * @returns {Boolean} - An indication if the input is a Number or can be coerced to a Number
		 */
		Owl.prototype.isNumeric = function(number) {
			return !isNaN(parseFloat(number));
		};
	
		/**
		 * Gets the difference of two vectors.
		 * @todo #261
		 * @protected
		 * @param {Object} - The first vector.
		 * @param {Object} - The second vector.
		 * @returns {Object} - The difference.
		 */
		Owl.prototype.difference = function(first, second) {
			return {
				x: first.x - second.x,
				y: first.y - second.y
			};
		};
	
		/**
		 * The jQuery Plugin for the Owl Carousel
		 * @todo Navigation plugin `next` and `prev`
		 * @public
		 */
		$.fn.owlCarousel = function(option) {
			var args = Array.prototype.slice.call(arguments, 1);
	
			return this.each(function() {
				var $this = $(this),
					data = $this.data('owl.carousel');
	
				if (!data) {
					data = new Owl(this, typeof option == 'object' && option);
					$this.data('owl.carousel', data);
	
					$.each([
						'next', 'prev', 'to', 'destroy', 'refresh', 'replace', 'add', 'remove'
					], function(i, event) {
						data.register({ type: Owl.Type.Event, name: event });
						data.$element.on(event + '.owl.carousel.core', $.proxy(function(e) {
							if (e.namespace && e.relatedTarget !== this) {
								this.suppress([ event ]);
								data[event].apply(this, [].slice.call(arguments, 1));
								this.release([ event ]);
							}
						}, data));
					});
				}
	
				if (typeof option == 'string' && option.charAt(0) !== '_') {
					data[option].apply(data, args);
				}
			});
		};
	
		/**
		 * The constructor for the jQuery Plugin
		 * @public
		 */
		$.fn.owlCarousel.Constructor = Owl;
	
	})(window.Zepto || window.jQuery, window, document);
	
	/**
	 * AutoRefresh Plugin
	 * @version 2.3.4
	 * @author Artus Kolanowski
	 * @author David Deutsch
	 * @license The MIT License (MIT)
	 */
	;(function($, window, document, undefined) {
	
		/**
		 * Creates the auto refresh plugin.
		 * @class The Auto Refresh Plugin
		 * @param {Owl} carousel - The Owl Carousel
		 */
		var AutoRefresh = function(carousel) {
			/**
			 * Reference to the core.
			 * @protected
			 * @type {Owl}
			 */
			this._core = carousel;
	
			/**
			 * Refresh interval.
			 * @protected
			 * @type {number}
			 */
			this._interval = null;
	
			/**
			 * Whether the element is currently visible or not.
			 * @protected
			 * @type {Boolean}
			 */
			this._visible = null;
	
			/**
			 * All event handlers.
			 * @protected
			 * @type {Object}
			 */
			this._handlers = {
				'initialized.owl.carousel': $.proxy(function(e) {
					if (e.namespace && this._core.settings.autoRefresh) {
						this.watch();
					}
				}, this)
			};
	
			// set default options
			this._core.options = $.extend({}, AutoRefresh.Defaults, this._core.options);
	
			// register event handlers
			this._core.$element.on(this._handlers);
		};
	
		/**
		 * Default options.
		 * @public
		 */
		AutoRefresh.Defaults = {
			autoRefresh: true,
			autoRefreshInterval: 500
		};
	
		/**
		 * Watches the element.
		 */
		AutoRefresh.prototype.watch = function() {
			if (this._interval) {
				return;
			}
	
			this._visible = this._core.isVisible();
			this._interval = window.setInterval($.proxy(this.refresh, this), this._core.settings.autoRefreshInterval);
		};
	
		/**
		 * Refreshes the element.
		 */
		AutoRefresh.prototype.refresh = function() {
			if (this._core.isVisible() === this._visible) {
				return;
			}
	
			this._visible = !this._visible;
	
			this._core.$element.toggleClass('owl-hidden', !this._visible);
	
			this._visible && (this._core.invalidate('width') && this._core.refresh());
		};
	
		/**
		 * Destroys the plugin.
		 */
		AutoRefresh.prototype.destroy = function() {
			var handler, property;
	
			window.clearInterval(this._interval);
	
			for (handler in this._handlers) {
				this._core.$element.off(handler, this._handlers[handler]);
			}
			for (property in Object.getOwnPropertyNames(this)) {
				typeof this[property] != 'function' && (this[property] = null);
			}
		};
	
		$.fn.owlCarousel.Constructor.Plugins.AutoRefresh = AutoRefresh;
	
	})(window.Zepto || window.jQuery, window, document);
	
	/**
	 * Lazy Plugin
	 * @version 2.3.4
	 * @author Bartosz Wojciechowski
	 * @author David Deutsch
	 * @license The MIT License (MIT)
	 */
	;(function($, window, document, undefined) {
	
		/**
		 * Creates the lazy plugin.
		 * @class The Lazy Plugin
		 * @param {Owl} carousel - The Owl Carousel
		 */
		var Lazy = function(carousel) {
	
			/**
			 * Reference to the core.
			 * @protected
			 * @type {Owl}
			 */
			this._core = carousel;
	
			/**
			 * Already loaded items.
			 * @protected
			 * @type {Array.<jQuery>}
			 */
			this._loaded = [];
	
			/**
			 * Event handlers.
			 * @protected
			 * @type {Object}
			 */
			this._handlers = {
				'initialized.owl.carousel change.owl.carousel resized.owl.carousel': $.proxy(function(e) {
					if (!e.namespace) {
						return;
					}
	
					if (!this._core.settings || !this._core.settings.lazyLoad) {
						return;
					}
	
					if ((e.property && e.property.name == 'position') || e.type == 'initialized') {
						var settings = this._core.settings,
							n = (settings.center && Math.ceil(settings.items / 2) || settings.items),
							i = ((settings.center && n * -1) || 0),
							position = (e.property && e.property.value !== undefined ? e.property.value : this._core.current()) + i,
							clones = this._core.clones().length,
							load = $.proxy(function(i, v) { this.load(v) }, this);
						//TODO: Need documentation for this new option
						if (settings.lazyLoadEager > 0) {
							n += settings.lazyLoadEager;
							// If the carousel is looping also preload images that are to the "left"
							if (settings.loop) {
	              position -= settings.lazyLoadEager;
	              n++;
	            }
						}
	
						while (i++ < n) {
							this.load(clones / 2 + this._core.relative(position));
							clones && $.each(this._core.clones(this._core.relative(position)), load);
							position++;
						}
					}
				}, this)
			};
	
			// set the default options
			this._core.options = $.extend({}, Lazy.Defaults, this._core.options);
	
			// register event handler
			this._core.$element.on(this._handlers);
		};
	
		/**
		 * Default options.
		 * @public
		 */
		Lazy.Defaults = {
			lazyLoad: false,
			lazyLoadEager: 0
		};
	
		/**
		 * Loads all resources of an item at the specified position.
		 * @param {Number} position - The absolute position of the item.
		 * @protected
		 */
		Lazy.prototype.load = function(position) {
			var $item = this._core.$stage.children().eq(position),
				$elements = $item && $item.find('.owl-lazy');
	
			if (!$elements || $.inArray($item.get(0), this._loaded) > -1) {
				return;
			}
	
			$elements.each($.proxy(function(index, element) {
				var $element = $(element), image,
	                url = (window.devicePixelRatio > 1 && $element.attr('data-src-retina')) || $element.attr('data-src') || $element.attr('data-srcset');
	
				this._core.trigger('load', { element: $element, url: url }, 'lazy');
	
				if ($element.is('img')) {
					$element.one('load.owl.lazy', $.proxy(function() {
						$element.css('opacity', 1);
						this._core.trigger('loaded', { element: $element, url: url }, 'lazy');
					}, this)).attr('src', url);
	            } else if ($element.is('source')) {
	                $element.one('load.owl.lazy', $.proxy(function() {
	                    this._core.trigger('loaded', { element: $element, url: url }, 'lazy');
	                }, this)).attr('srcset', url);
				} else {
					image = new Image();
					image.onload = $.proxy(function() {
						$element.css({
							'background-image': 'url("' + url + '")',
							'opacity': '1'
						});
						this._core.trigger('loaded', { element: $element, url: url }, 'lazy');
					}, this);
					image.src = url;
				}
			}, this));
	
			this._loaded.push($item.get(0));
		};
	
		/**
		 * Destroys the plugin.
		 * @public
		 */
		Lazy.prototype.destroy = function() {
			var handler, property;
	
			for (handler in this.handlers) {
				this._core.$element.off(handler, this.handlers[handler]);
			}
			for (property in Object.getOwnPropertyNames(this)) {
				typeof this[property] != 'function' && (this[property] = null);
			}
		};
	
		$.fn.owlCarousel.Constructor.Plugins.Lazy = Lazy;
	
	})(window.Zepto || window.jQuery, window, document);
	
	/**
	 * AutoHeight Plugin
	 * @version 2.3.4
	 * @author Bartosz Wojciechowski
	 * @author David Deutsch
	 * @license The MIT License (MIT)
	 */
	;(function($, window, document, undefined) {
	
		/**
		 * Creates the auto height plugin.
		 * @class The Auto Height Plugin
		 * @param {Owl} carousel - The Owl Carousel
		 */
		var AutoHeight = function(carousel) {
			/**
			 * Reference to the core.
			 * @protected
			 * @type {Owl}
			 */
			this._core = carousel;
	
			this._previousHeight = null;
	
			/**
			 * All event handlers.
			 * @protected
			 * @type {Object}
			 */
			this._handlers = {
				'initialized.owl.carousel refreshed.owl.carousel': $.proxy(function(e) {
					if (e.namespace && this._core.settings.autoHeight) {
						this.update();
					}
				}, this),
				'changed.owl.carousel': $.proxy(function(e) {
					if (e.namespace && this._core.settings.autoHeight && e.property.name === 'position'){
						this.update();
					}
				}, this),
				'loaded.owl.lazy': $.proxy(function(e) {
					if (e.namespace && this._core.settings.autoHeight
						&& e.element.closest('.' + this._core.settings.itemClass).index() === this._core.current()) {
						this.update();
					}
				}, this)
			};
	
			// set default options
			this._core.options = $.extend({}, AutoHeight.Defaults, this._core.options);
	
			// register event handlers
			this._core.$element.on(this._handlers);
			this._intervalId = null;
			var refThis = this;
	
			// These changes have been taken from a PR by gavrochelegnou proposed in #1575
			// and have been made compatible with the latest jQuery version
			$(window).on('load', function() {
				if (refThis._core.settings.autoHeight) {
					refThis.update();
				}
			});
	
			// Autoresize the height of the carousel when window is resized
			// When carousel has images, the height is dependent on the width
			// and should also change on resize
			$(window).resize(function() {
				if (refThis._core.settings.autoHeight) {
					if (refThis._intervalId != null) {
						clearTimeout(refThis._intervalId);
					}
	
					refThis._intervalId = setTimeout(function() {
						refThis.update();
					}, 250);
				}
			});
	
		};
	
		/**
		 * Default options.
		 * @public
		 */
		AutoHeight.Defaults = {
			autoHeight: false,
			autoHeightClass: 'owl-height'
		};
	
		/**
		 * Updates the view.
		 */
		AutoHeight.prototype.update = function() {
			var start = this._core._current,
				end = start + this._core.settings.items,
				lazyLoadEnabled = this._core.settings.lazyLoad,
				visible = this._core.$stage.children().toArray().slice(start, end),
				heights = [],
				maxheight = 0;
	
			$.each(visible, function(index, item) {
				heights.push($(item).height());
			});
	
			maxheight = Math.max.apply(null, heights);
	
			if (maxheight <= 1 && lazyLoadEnabled && this._previousHeight) {
				maxheight = this._previousHeight;
			}
	
			this._previousHeight = maxheight;
	
			this._core.$stage.parent()
				.height(maxheight)
				.addClass(this._core.settings.autoHeightClass);
		};
	
		AutoHeight.prototype.destroy = function() {
			var handler, property;
	
			for (handler in this._handlers) {
				this._core.$element.off(handler, this._handlers[handler]);
			}
			for (property in Object.getOwnPropertyNames(this)) {
				typeof this[property] !== 'function' && (this[property] = null);
			}
		};
	
		$.fn.owlCarousel.Constructor.Plugins.AutoHeight = AutoHeight;
	
	})(window.Zepto || window.jQuery, window, document);
	
	/**
	 * Video Plugin
	 * @version 2.3.4
	 * @author Bartosz Wojciechowski
	 * @author David Deutsch
	 * @license The MIT License (MIT)
	 */
	;(function($, window, document, undefined) {
	
		/**
		 * Creates the video plugin.
		 * @class The Video Plugin
		 * @param {Owl} carousel - The Owl Carousel
		 */
		var Video = function(carousel) {
			/**
			 * Reference to the core.
			 * @protected
			 * @type {Owl}
			 */
			this._core = carousel;
	
			/**
			 * Cache all video URLs.
			 * @protected
			 * @type {Object}
			 */
			this._videos = {};
	
			/**
			 * Current playing item.
			 * @protected
			 * @type {jQuery}
			 */
			this._playing = null;
	
			/**
			 * All event handlers.
			 * @todo The cloned content removale is too late
			 * @protected
			 * @type {Object}
			 */
			this._handlers = {
				'initialized.owl.carousel': $.proxy(function(e) {
					if (e.namespace) {
						this._core.register({ type: 'state', name: 'playing', tags: [ 'interacting' ] });
					}
				}, this),
				'resize.owl.carousel': $.proxy(function(e) {
					if (e.namespace && this._core.settings.video && this.isInFullScreen()) {
						e.preventDefault();
					}
				}, this),
				'refreshed.owl.carousel': $.proxy(function(e) {
					if (e.namespace && this._core.is('resizing')) {
						this._core.$stage.find('.cloned .owl-video-frame').remove();
					}
				}, this),
				'changed.owl.carousel': $.proxy(function(e) {
					if (e.namespace && e.property.name === 'position' && this._playing) {
						this.stop();
					}
				}, this),
				'prepared.owl.carousel': $.proxy(function(e) {
					if (!e.namespace) {
						return;
					}
	
					var $element = $(e.content).find('.owl-video');
	
					if ($element.length) {
						$element.css('display', 'none');
						this.fetch($element, $(e.content));
					}
				}, this)
			};
	
			// set default options
			this._core.options = $.extend({}, Video.Defaults, this._core.options);
	
			// register event handlers
			this._core.$element.on(this._handlers);
	
			this._core.$element.on('click.owl.video', '.owl-video-play-icon', $.proxy(function(e) {
				this.play(e);
			}, this));
		};
	
		/**
		 * Default options.
		 * @public
		 */
		Video.Defaults = {
			video: false,
			videoHeight: false,
			videoWidth: false
		};
	
		/**
		 * Gets the video ID and the type (YouTube/Vimeo/vzaar only).
		 * @protected
		 * @param {jQuery} target - The target containing the video data.
		 * @param {jQuery} item - The item containing the video.
		 */
		Video.prototype.fetch = function(target, item) {
				var type = (function() {
						if (target.attr('data-vimeo-id')) {
							return 'vimeo';
						} else if (target.attr('data-vzaar-id')) {
							return 'vzaar'
						} else {
							return 'youtube';
						}
					})(),
					id = target.attr('data-vimeo-id') || target.attr('data-youtube-id') || target.attr('data-vzaar-id'),
					width = target.attr('data-width') || this._core.settings.videoWidth,
					height = target.attr('data-height') || this._core.settings.videoHeight,
					url = target.attr('href');
	
			if (url) {
	
				/*
						Parses the id's out of the following urls (and probably more):
						https://www.youtube.com/watch?v=:id
						https://youtu.be/:id
						https://vimeo.com/:id
						https://vimeo.com/channels/:channel/:id
						https://vimeo.com/groups/:group/videos/:id
						https://app.vzaar.com/videos/:id
	
						Visual example: https://regexper.com/#(http%3A%7Chttps%3A%7C)%5C%2F%5C%2F(player.%7Cwww.%7Capp.)%3F(vimeo%5C.com%7Cyoutu(be%5C.com%7C%5C.be%7Cbe%5C.googleapis%5C.com)%7Cvzaar%5C.com)%5C%2F(video%5C%2F%7Cvideos%5C%2F%7Cembed%5C%2F%7Cchannels%5C%2F.%2B%5C%2F%7Cgroups%5C%2F.%2B%5C%2F%7Cwatch%5C%3Fv%3D%7Cv%5C%2F)%3F(%5BA-Za-z0-9._%25-%5D*)(%5C%26%5CS%2B)%3F
				*/
	
				id = url.match(/(http:|https:|)\/\/(player.|www.|app.)?(vimeo\.com|youtu(be\.com|\.be|be\.googleapis\.com|be\-nocookie\.com)|vzaar\.com)\/(video\/|videos\/|embed\/|channels\/.+\/|groups\/.+\/|watch\?v=|v\/)?([A-Za-z0-9._%-]*)(\&\S+)?/);
	
				if (id[3].indexOf('youtu') > -1) {
					type = 'youtube';
				} else if (id[3].indexOf('vimeo') > -1) {
					type = 'vimeo';
				} else if (id[3].indexOf('vzaar') > -1) {
					type = 'vzaar';
				} else {
					throw new Error('Video URL not supported.');
				}
				id = id[6];
			} else {
				throw new Error('Missing video URL.');
			}
	
			this._videos[url] = {
				type: type,
				id: id,
				width: width,
				height: height
			};
	
			item.attr('data-video', url);
	
			this.thumbnail(target, this._videos[url]);
		};
	
		/**
		 * Creates video thumbnail.
		 * @protected
		 * @param {jQuery} target - The target containing the video data.
		 * @param {Object} info - The video info object.
		 * @see `fetch`
		 */
		Video.prototype.thumbnail = function(target, video) {
			var tnLink,
				icon,
				path,
				dimensions = video.width && video.height ? 'width:' + video.width + 'px;height:' + video.height + 'px;' : '',
				customTn = target.find('img'),
				srcType = 'src',
				lazyClass = '',
				settings = this._core.settings,
				create = function(path) {
					icon = '<div class="owl-video-play-icon"></div>';
	
					if (settings.lazyLoad) {
						tnLink = $('<div/>',{
							"class": 'owl-video-tn ' + lazyClass,
							"srcType": path
						});
					} else {
						tnLink = $( '<div/>', {
							"class": "owl-video-tn",
							"style": 'opacity:1;background-image:url(' + path + ')'
						});
					}
					target.after(tnLink);
					target.after(icon);
				};
	
			// wrap video content into owl-video-wrapper div
			target.wrap( $( '<div/>', {
				"class": "owl-video-wrapper",
				"style": dimensions
			}));
	
			if (this._core.settings.lazyLoad) {
				srcType = 'data-src';
				lazyClass = 'owl-lazy';
			}
	
			// custom thumbnail
			if (customTn.length) {
				create(customTn.attr(srcType));
				customTn.remove();
				return false;
			}
	
			if (video.type === 'youtube') {
				path = "//img.youtube.com/vi/" + video.id + "/hqdefault.jpg";
				create(path);
			} else if (video.type === 'vimeo') {
				$.ajax({
					type: 'GET',
					url: '//vimeo.com/api/v2/video/' + video.id + '.json',
					jsonp: 'callback',
					dataType: 'jsonp',
					success: function(data) {
						path = data[0].thumbnail_large;
						create(path);
					}
				});
			} else if (video.type === 'vzaar') {
				$.ajax({
					type: 'GET',
					url: '//vzaar.com/api/videos/' + video.id + '.json',
					jsonp: 'callback',
					dataType: 'jsonp',
					success: function(data) {
						path = data.framegrab_url;
						create(path);
					}
				});
			}
		};
	
		/**
		 * Stops the current video.
		 * @public
		 */
		Video.prototype.stop = function() {
			this._core.trigger('stop', null, 'video');
			this._playing.find('.owl-video-frame').remove();
			this._playing.removeClass('owl-video-playing');
			this._playing = null;
			this._core.leave('playing');
			this._core.trigger('stopped', null, 'video');
		};
	
		/**
		 * Starts the current video.
		 * @public
		 * @param {Event} event - The event arguments.
		 */
		Video.prototype.play = function(event) {
			var target = $(event.target),
				item = target.closest('.' + this._core.settings.itemClass),
				video = this._videos[item.attr('data-video')],
				width = video.width || '100%',
				height = video.height || this._core.$stage.height(),
				html,
				iframe;
	
			if (this._playing) {
				return;
			}
	
			this._core.enter('playing');
			this._core.trigger('play', null, 'video');
	
			item = this._core.items(this._core.relative(item.index()));
	
			this._core.reset(item.index());
	
			html = $( '<iframe frameborder="0" allowfullscreen mozallowfullscreen webkitAllowFullScreen ></iframe>' );
			html.attr( 'height', height );
			html.attr( 'width', width );
			if (video.type === 'youtube') {
				html.attr( 'src', '//www.youtube.com/embed/' + video.id + '?autoplay=1&rel=0&v=' + video.id );
			} else if (video.type === 'vimeo') {
				html.attr( 'src', '//player.vimeo.com/video/' + video.id + '?autoplay=1' );
			} else if (video.type === 'vzaar') {
				html.attr( 'src', '//view.vzaar.com/' + video.id + '/player?autoplay=true' );
			}
	
			iframe = $(html).wrap( '<div class="owl-video-frame" />' ).insertAfter(item.find('.owl-video'));
	
			this._playing = item.addClass('owl-video-playing');
		};
	
		/**
		 * Checks whether an video is currently in full screen mode or not.
		 * @todo Bad style because looks like a readonly method but changes members.
		 * @protected
		 * @returns {Boolean}
		 */
		Video.prototype.isInFullScreen = function() {
			var element = document.fullscreenElement || document.mozFullScreenElement ||
					document.webkitFullscreenElement;
	
			return element && $(element).parent().hasClass('owl-video-frame');
		};
	
		/**
		 * Destroys the plugin.
		 */
		Video.prototype.destroy = function() {
			var handler, property;
	
			this._core.$element.off('click.owl.video');
	
			for (handler in this._handlers) {
				this._core.$element.off(handler, this._handlers[handler]);
			}
			for (property in Object.getOwnPropertyNames(this)) {
				typeof this[property] != 'function' && (this[property] = null);
			}
		};
	
		$.fn.owlCarousel.Constructor.Plugins.Video = Video;
	
	})(window.Zepto || window.jQuery, window, document);
	
	/**
	 * Animate Plugin
	 * @version 2.3.4
	 * @author Bartosz Wojciechowski
	 * @author David Deutsch
	 * @license The MIT License (MIT)
	 */
	;(function($, window, document, undefined) {
	
		/**
		 * Creates the animate plugin.
		 * @class The Navigation Plugin
		 * @param {Owl} scope - The Owl Carousel
		 */
		var Animate = function(scope) {
			this.core = scope;
			this.core.options = $.extend({}, Animate.Defaults, this.core.options);
			this.swapping = true;
			this.previous = undefined;
			this.next = undefined;
	
			this.handlers = {
				'change.owl.carousel': $.proxy(function(e) {
					if (e.namespace && e.property.name == 'position') {
						this.previous = this.core.current();
						this.next = e.property.value;
					}
				}, this),
				'drag.owl.carousel dragged.owl.carousel translated.owl.carousel': $.proxy(function(e) {
					if (e.namespace) {
						this.swapping = e.type == 'translated';
					}
				}, this),
				'translate.owl.carousel': $.proxy(function(e) {
					if (e.namespace && this.swapping && (this.core.options.animateOut || this.core.options.animateIn)) {
						this.swap();
					}
				}, this)
			};
	
			this.core.$element.on(this.handlers);
		};
	
		/**
		 * Default options.
		 * @public
		 */
		Animate.Defaults = {
			animateOut: false,
			animateIn: false
		};
	
		/**
		 * Toggles the animation classes whenever an translations starts.
		 * @protected
		 * @returns {Boolean|undefined}
		 */
		Animate.prototype.swap = function() {
	
			if (this.core.settings.items !== 1) {
				return;
			}
	
			if (!$.support.animation || !$.support.transition) {
				return;
			}
	
			this.core.speed(0);
	
			var left,
				clear = $.proxy(this.clear, this),
				previous = this.core.$stage.children().eq(this.previous),
				next = this.core.$stage.children().eq(this.next),
				incoming = this.core.settings.animateIn,
				outgoing = this.core.settings.animateOut;
	
			if (this.core.current() === this.previous) {
				return;
			}
	
			if (outgoing) {
				left = this.core.coordinates(this.previous) - this.core.coordinates(this.next);
				previous.one($.support.animation.end, clear)
					.css( { 'left': left + 'px' } )
					.addClass('animated owl-animated-out')
					.addClass(outgoing);
			}
	
			if (incoming) {
				next.one($.support.animation.end, clear)
					.addClass('animated owl-animated-in')
					.addClass(incoming);
			}
		};
	
		Animate.prototype.clear = function(e) {
			$(e.target).css( { 'left': '' } )
				.removeClass('animated owl-animated-out owl-animated-in')
				.removeClass(this.core.settings.animateIn)
				.removeClass(this.core.settings.animateOut);
			this.core.onTransitionEnd();
		};
	
		/**
		 * Destroys the plugin.
		 * @public
		 */
		Animate.prototype.destroy = function() {
			var handler, property;
	
			for (handler in this.handlers) {
				this.core.$element.off(handler, this.handlers[handler]);
			}
			for (property in Object.getOwnPropertyNames(this)) {
				typeof this[property] != 'function' && (this[property] = null);
			}
		};
	
		$.fn.owlCarousel.Constructor.Plugins.Animate = Animate;
	
	})(window.Zepto || window.jQuery, window, document);
	
	/**
	 * Autoplay Plugin
	 * @version 2.3.4
	 * @author Bartosz Wojciechowski
	 * @author Artus Kolanowski
	 * @author David Deutsch
	 * @author Tom De Caluwé
	 * @license The MIT License (MIT)
	 */
	;(function($, window, document, undefined) {
	
		/**
		 * Creates the autoplay plugin.
		 * @class The Autoplay Plugin
		 * @param {Owl} scope - The Owl Carousel
		 */
		var Autoplay = function(carousel) {
			/**
			 * Reference to the core.
			 * @protected
			 * @type {Owl}
			 */
			this._core = carousel;
	
			/**
			 * The autoplay timeout id.
			 * @type {Number}
			 */
			this._call = null;
	
			/**
			 * Depending on the state of the plugin, this variable contains either
			 * the start time of the timer or the current timer value if it's
			 * paused. Since we start in a paused state we initialize the timer
			 * value.
			 * @type {Number}
			 */
			this._time = 0;
	
			/**
			 * Stores the timeout currently used.
			 * @type {Number}
			 */
			this._timeout = 0;
	
			/**
			 * Indicates whenever the autoplay is paused.
			 * @type {Boolean}
			 */
			this._paused = true;
	
			/**
			 * All event handlers.
			 * @protected
			 * @type {Object}
			 */
			this._handlers = {
				'changed.owl.carousel': $.proxy(function(e) {
					if (e.namespace && e.property.name === 'settings') {
						if (this._core.settings.autoplay) {
							this.play();
						} else {
							this.stop();
						}
					} else if (e.namespace && e.property.name === 'position' && this._paused) {
						// Reset the timer. This code is triggered when the position
						// of the carousel was changed through user interaction.
						this._time = 0;
					}
				}, this),
				'initialized.owl.carousel': $.proxy(function(e) {
					if (e.namespace && this._core.settings.autoplay) {
						this.play();
					}
				}, this),
				'play.owl.autoplay': $.proxy(function(e, t, s) {
					if (e.namespace) {
						this.play(t, s);
					}
				}, this),
				'stop.owl.autoplay': $.proxy(function(e) {
					if (e.namespace) {
						this.stop();
					}
				}, this),
				'mouseover.owl.autoplay': $.proxy(function() {
					if (this._core.settings.autoplayHoverPause && this._core.is('rotating')) {
						this.pause();
					}
				}, this),
				'mouseleave.owl.autoplay': $.proxy(function() {
					if (this._core.settings.autoplayHoverPause && this._core.is('rotating')) {
						this.play();
					}
				}, this),
				'touchstart.owl.core': $.proxy(function() {
					if (this._core.settings.autoplayHoverPause && this._core.is('rotating')) {
						this.pause();
					}
				}, this),
				'touchend.owl.core': $.proxy(function() {
					if (this._core.settings.autoplayHoverPause) {
						this.play();
					}
				}, this)
			};
	
			// register event handlers
			this._core.$element.on(this._handlers);
	
			// set default options
			this._core.options = $.extend({}, Autoplay.Defaults, this._core.options);
		};
	
		/**
		 * Default options.
		 * @public
		 */
		Autoplay.Defaults = {
			autoplay: false,
			autoplayTimeout: 5000,
			autoplayHoverPause: false,
			autoplaySpeed: false
		};
	
		/**
		 * Transition to the next slide and set a timeout for the next transition.
		 * @private
		 * @param {Number} [speed] - The animation speed for the animations.
		 */
		Autoplay.prototype._next = function(speed) {
			this._call = window.setTimeout(
				$.proxy(this._next, this, speed),
				this._timeout * (Math.round(this.read() / this._timeout) + 1) - this.read()
			);
	
			if (this._core.is('interacting') || document.hidden) {
				return;
			}
			this._core.next(speed || this._core.settings.autoplaySpeed);
		}
	
		/**
		 * Reads the current timer value when the timer is playing.
		 * @public
		 */
		Autoplay.prototype.read = function() {
			return new Date().getTime() - this._time;
		};
	
		/**
		 * Starts the autoplay.
		 * @public
		 * @param {Number} [timeout] - The interval before the next animation starts.
		 * @param {Number} [speed] - The animation speed for the animations.
		 */
		Autoplay.prototype.play = function(timeout, speed) {
			var elapsed;
	
			if (!this._core.is('rotating')) {
				this._core.enter('rotating');
			}
	
			timeout = timeout || this._core.settings.autoplayTimeout;
	
			// Calculate the elapsed time since the last transition. If the carousel
			// wasn't playing this calculation will yield zero.
			elapsed = Math.min(this._time % (this._timeout || timeout), timeout);
	
			if (this._paused) {
				// Start the clock.
				this._time = this.read();
				this._paused = false;
			} else {
				// Clear the active timeout to allow replacement.
				window.clearTimeout(this._call);
			}
	
			// Adjust the origin of the timer to match the new timeout value.
			this._time += this.read() % timeout - elapsed;
	
			this._timeout = timeout;
			this._call = window.setTimeout($.proxy(this._next, this, speed), timeout - elapsed);
		};
	
		/**
		 * Stops the autoplay.
		 * @public
		 */
		Autoplay.prototype.stop = function() {
			if (this._core.is('rotating')) {
				// Reset the clock.
				this._time = 0;
				this._paused = true;
	
				window.clearTimeout(this._call);
				this._core.leave('rotating');
			}
		};
	
		/**
		 * Pauses the autoplay.
		 * @public
		 */
		Autoplay.prototype.pause = function() {
			if (this._core.is('rotating') && !this._paused) {
				// Pause the clock.
				this._time = this.read();
				this._paused = true;
	
				window.clearTimeout(this._call);
			}
		};
	
		/**
		 * Destroys the plugin.
		 */
		Autoplay.prototype.destroy = function() {
			var handler, property;
	
			this.stop();
	
			for (handler in this._handlers) {
				this._core.$element.off(handler, this._handlers[handler]);
			}
			for (property in Object.getOwnPropertyNames(this)) {
				typeof this[property] != 'function' && (this[property] = null);
			}
		};
	
		$.fn.owlCarousel.Constructor.Plugins.autoplay = Autoplay;
	
	})(window.Zepto || window.jQuery, window, document);
	
	/**
	 * Navigation Plugin
	 * @version 2.3.4
	 * @author Artus Kolanowski
	 * @author David Deutsch
	 * @license The MIT License (MIT)
	 */
	;(function($, window, document, undefined) {
		'use strict';
	
		/**
		 * Creates the navigation plugin.
		 * @class The Navigation Plugin
		 * @param {Owl} carousel - The Owl Carousel.
		 */
		var Navigation = function(carousel) {
			/**
			 * Reference to the core.
			 * @protected
			 * @type {Owl}
			 */
			this._core = carousel;
	
			/**
			 * Indicates whether the plugin is initialized or not.
			 * @protected
			 * @type {Boolean}
			 */
			this._initialized = false;
	
			/**
			 * The current paging indexes.
			 * @protected
			 * @type {Array}
			 */
			this._pages = [];
	
			/**
			 * All DOM elements of the user interface.
			 * @protected
			 * @type {Object}
			 */
			this._controls = {};
	
			/**
			 * Markup for an indicator.
			 * @protected
			 * @type {Array.<String>}
			 */
			this._templates = [];
	
			/**
			 * The carousel element.
			 * @type {jQuery}
			 */
			this.$element = this._core.$element;
	
			/**
			 * Overridden methods of the carousel.
			 * @protected
			 * @type {Object}
			 */
			this._overrides = {
				next: this._core.next,
				prev: this._core.prev,
				to: this._core.to
			};
	
			/**
			 * All event handlers.
			 * @protected
			 * @type {Object}
			 */
			this._handlers = {
				'prepared.owl.carousel': $.proxy(function(e) {
					if (e.namespace && this._core.settings.dotsData) {
						this._templates.push('<div class="' + this._core.settings.dotClass + '">' +
							$(e.content).find('[data-dot]').addBack('[data-dot]').attr('data-dot') + '</div>');
					}
				}, this),
				'added.owl.carousel': $.proxy(function(e) {
					if (e.namespace && this._core.settings.dotsData) {
						this._templates.splice(e.position, 0, this._templates.pop());
					}
				}, this),
				'remove.owl.carousel': $.proxy(function(e) {
					if (e.namespace && this._core.settings.dotsData) {
						this._templates.splice(e.position, 1);
					}
				}, this),
				'changed.owl.carousel': $.proxy(function(e) {
					if (e.namespace && e.property.name == 'position') {
						this.draw();
					}
				}, this),
				'initialized.owl.carousel': $.proxy(function(e) {
					if (e.namespace && !this._initialized) {
						this._core.trigger('initialize', null, 'navigation');
						this.initialize();
						this.update();
						this.draw();
						this._initialized = true;
						this._core.trigger('initialized', null, 'navigation');
					}
				}, this),
				'refreshed.owl.carousel': $.proxy(function(e) {
					if (e.namespace && this._initialized) {
						this._core.trigger('refresh', null, 'navigation');
						this.update();
						this.draw();
						this._core.trigger('refreshed', null, 'navigation');
					}
				}, this)
			};
	
			// set default options
			this._core.options = $.extend({}, Navigation.Defaults, this._core.options);
	
			// register event handlers
			this.$element.on(this._handlers);
		};
	
		/**
		 * Default options.
		 * @public
		 * @todo Rename `slideBy` to `navBy`
		 */
		Navigation.Defaults = {
			nav: false,
			navText: [
				'<span aria-label="' + 'Previous' + '">&#x2039;</span>',
				'<span aria-label="' + 'Next' + '">&#x203a;</span>'
			],
			navSpeed: false,
			navElement: 'button type="button" role="presentation"',
			navContainer: false,
			navContainerClass: 'owl-nav',
			navClass: [
				'owl-prev',
				'owl-next'
			],
			slideBy: 1,
			dotClass: 'owl-dot',
			dotsClass: 'owl-dots',
			dots: true,
			dotsEach: false,
			dotsData: false,
			dotsSpeed: false,
			dotsContainer: false
		};
	
		/**
		 * Initializes the layout of the plugin and extends the carousel.
		 * @protected
		 */
		Navigation.prototype.initialize = function() {
			var override,
				settings = this._core.settings;
	
			// create DOM structure for relative navigation
			this._controls.$relative = (settings.navContainer ? $(settings.navContainer)
				: $('<div>').addClass(settings.navContainerClass).appendTo(this.$element)).addClass('disabled');
	
			this._controls.$previous = $('<' + settings.navElement + '>')
				.addClass(settings.navClass[0])
				.html(settings.navText[0])
				.prependTo(this._controls.$relative)
				.on('click', $.proxy(function(e) {
					this.prev(settings.navSpeed);
				}, this));
			this._controls.$next = $('<' + settings.navElement + '>')
				.addClass(settings.navClass[1])
				.html(settings.navText[1])
				.appendTo(this._controls.$relative)
				.on('click', $.proxy(function(e) {
					this.next(settings.navSpeed);
				}, this));
	
			// create DOM structure for absolute navigation
			if (!settings.dotsData) {
				this._templates = [ $('<button role="button">')
					.addClass(settings.dotClass)
					.append($('<span>'))
					.prop('outerHTML') ];
			}
	
			this._controls.$absolute = (settings.dotsContainer ? $(settings.dotsContainer)
				: $('<div>').addClass(settings.dotsClass).appendTo(this.$element)).addClass('disabled');
	
			this._controls.$absolute.on('click', 'button', $.proxy(function(e) {
				var index = $(e.target).parent().is(this._controls.$absolute)
					? $(e.target).index() : $(e.target).parent().index();
	
				e.preventDefault();
	
				this.to(index, settings.dotsSpeed);
			}, this));
	
			/*$el.on('focusin', function() {
				$(document).off(".carousel");
	
				$(document).on('keydown.carousel', function(e) {
					if(e.keyCode == 37) {
						$el.trigger('prev.owl')
					}
					if(e.keyCode == 39) {
						$el.trigger('next.owl')
					}
				});
			});*/
	
			// override public methods of the carousel
			for (override in this._overrides) {
				this._core[override] = $.proxy(this[override], this);
			}
		};
	
		/**
		 * Destroys the plugin.
		 * @protected
		 */
		Navigation.prototype.destroy = function() {
			var handler, control, property, override, settings;
			settings = this._core.settings;
	
			for (handler in this._handlers) {
				this.$element.off(handler, this._handlers[handler]);
			}
			for (control in this._controls) {
				if (control === '$relative' && settings.navContainer) {
					this._controls[control].html('');
				} else {
					this._controls[control].remove();
				}
			}
			for (override in this.overides) {
				this._core[override] = this._overrides[override];
			}
			for (property in Object.getOwnPropertyNames(this)) {
				typeof this[property] != 'function' && (this[property] = null);
			}
		};
	
		/**
		 * Updates the internal state.
		 * @protected
		 */
		Navigation.prototype.update = function() {
			var i, j, k,
				lower = this._core.clones().length / 2,
				upper = lower + this._core.items().length,
				maximum = this._core.maximum(true),
				settings = this._core.settings,
				size = settings.center || settings.autoWidth || settings.dotsData
					? 1 : settings.dotsEach || settings.items;
	
			if (settings.slideBy !== 'page') {
				settings.slideBy = Math.min(settings.slideBy, settings.items);
			}
	
			if (settings.dots || settings.slideBy == 'page') {
				this._pages = [];
	
				for (i = lower, j = 0, k = 0; i < upper; i++) {
					if (j >= size || j === 0) {
						this._pages.push({
							start: Math.min(maximum, i - lower),
							end: i - lower + size - 1
						});
						if (Math.min(maximum, i - lower) === maximum) {
							break;
						}
						j = 0, ++k;
					}
					j += this._core.mergers(this._core.relative(i));
				}
			}
		};
	
		/**
		 * Draws the user interface.
		 * @todo The option `dotsData` wont work.
		 * @protected
		 */
		Navigation.prototype.draw = function() {
			var difference,
				settings = this._core.settings,
				disabled = this._core.items().length <= settings.items,
				index = this._core.relative(this._core.current()),
				loop = settings.loop || settings.rewind;
	
			this._controls.$relative.toggleClass('disabled', !settings.nav || disabled);
	
			if (settings.nav) {
				this._controls.$previous.toggleClass('disabled', !loop && index <= this._core.minimum(true));
				this._controls.$next.toggleClass('disabled', !loop && index >= this._core.maximum(true));
			}
	
			this._controls.$absolute.toggleClass('disabled', !settings.dots || disabled);
	
			if (settings.dots) {
				difference = this._pages.length - this._controls.$absolute.children().length;
	
				if (settings.dotsData && difference !== 0) {
					this._controls.$absolute.html(this._templates.join(''));
				} else if (difference > 0) {
					this._controls.$absolute.append(new Array(difference + 1).join(this._templates[0]));
				} else if (difference < 0) {
					this._controls.$absolute.children().slice(difference).remove();
				}
	
				this._controls.$absolute.find('.active').removeClass('active');
				this._controls.$absolute.children().eq($.inArray(this.current(), this._pages)).addClass('active');
			}
		};
	
		/**
		 * Extends event data.
		 * @protected
		 * @param {Event} event - The event object which gets thrown.
		 */
		Navigation.prototype.onTrigger = function(event) {
			var settings = this._core.settings;
	
			event.page = {
				index: $.inArray(this.current(), this._pages),
				count: this._pages.length,
				size: settings && (settings.center || settings.autoWidth || settings.dotsData
					? 1 : settings.dotsEach || settings.items)
			};
		};
	
		/**
		 * Gets the current page position of the carousel.
		 * @protected
		 * @returns {Number}
		 */
		Navigation.prototype.current = function() {
			var current = this._core.relative(this._core.current());
			return $.grep(this._pages, $.proxy(function(page, index) {
				return page.start <= current && page.end >= current;
			}, this)).pop();
		};
	
		/**
		 * Gets the current succesor/predecessor position.
		 * @protected
		 * @returns {Number}
		 */
		Navigation.prototype.getPosition = function(successor) {
			var position, length,
				settings = this._core.settings;
	
			if (settings.slideBy == 'page') {
				position = $.inArray(this.current(), this._pages);
				length = this._pages.length;
				successor ? ++position : --position;
				position = this._pages[((position % length) + length) % length].start;
			} else {
				position = this._core.relative(this._core.current());
				length = this._core.items().length;
				successor ? position += settings.slideBy : position -= settings.slideBy;
			}
	
			return position;
		};
	
		/**
		 * Slides to the next item or page.
		 * @public
		 * @param {Number} [speed=false] - The time in milliseconds for the transition.
		 */
		Navigation.prototype.next = function(speed) {
			$.proxy(this._overrides.to, this._core)(this.getPosition(true), speed);
		};
	
		/**
		 * Slides to the previous item or page.
		 * @public
		 * @param {Number} [speed=false] - The time in milliseconds for the transition.
		 */
		Navigation.prototype.prev = function(speed) {
			$.proxy(this._overrides.to, this._core)(this.getPosition(false), speed);
		};
	
		/**
		 * Slides to the specified item or page.
		 * @public
		 * @param {Number} position - The position of the item or page.
		 * @param {Number} [speed] - The time in milliseconds for the transition.
		 * @param {Boolean} [standard=false] - Whether to use the standard behaviour or not.
		 */
		Navigation.prototype.to = function(position, speed, standard) {
			var length;
	
			if (!standard && this._pages.length) {
				length = this._pages.length;
				$.proxy(this._overrides.to, this._core)(this._pages[((position % length) + length) % length].start, speed);
			} else {
				$.proxy(this._overrides.to, this._core)(position, speed);
			}
		};
	
		$.fn.owlCarousel.Constructor.Plugins.Navigation = Navigation;
	
	})(window.Zepto || window.jQuery, window, document);
	
	/**
	 * Hash Plugin
	 * @version 2.3.4
	 * @author Artus Kolanowski
	 * @author David Deutsch
	 * @license The MIT License (MIT)
	 */
	;(function($, window, document, undefined) {
		'use strict';
	
		/**
		 * Creates the hash plugin.
		 * @class The Hash Plugin
		 * @param {Owl} carousel - The Owl Carousel
		 */
		var Hash = function(carousel) {
			/**
			 * Reference to the core.
			 * @protected
			 * @type {Owl}
			 */
			this._core = carousel;
	
			/**
			 * Hash index for the items.
			 * @protected
			 * @type {Object}
			 */
			this._hashes = {};
	
			/**
			 * The carousel element.
			 * @type {jQuery}
			 */
			this.$element = this._core.$element;
	
			/**
			 * All event handlers.
			 * @protected
			 * @type {Object}
			 */
			this._handlers = {
				'initialized.owl.carousel': $.proxy(function(e) {
					if (e.namespace && this._core.settings.startPosition === 'URLHash') {
						$(window).trigger('hashchange.owl.navigation');
					}
				}, this),
				'prepared.owl.carousel': $.proxy(function(e) {
					if (e.namespace) {
						var hash = $(e.content).find('[data-hash]').addBack('[data-hash]').attr('data-hash');
	
						if (!hash) {
							return;
						}
	
						this._hashes[hash] = e.content;
					}
				}, this),
				'changed.owl.carousel': $.proxy(function(e) {
					if (e.namespace && e.property.name === 'position') {
						var current = this._core.items(this._core.relative(this._core.current())),
							hash = $.map(this._hashes, function(item, hash) {
								return item === current ? hash : null;
							}).join();
	
						if (!hash || window.location.hash.slice(1) === hash) {
							return;
						}
	
						window.location.hash = hash;
					}
				}, this)
			};
	
			// set default options
			this._core.options = $.extend({}, Hash.Defaults, this._core.options);
	
			// register the event handlers
			this.$element.on(this._handlers);
	
			// register event listener for hash navigation
			$(window).on('hashchange.owl.navigation', $.proxy(function(e) {
				var hash = window.location.hash.substring(1),
					items = this._core.$stage.children(),
					position = this._hashes[hash] && items.index(this._hashes[hash]);
	
				if (position === undefined || position === this._core.current()) {
					return;
				}
	
				this._core.to(this._core.relative(position), false, true);
			}, this));
		};
	
		/**
		 * Default options.
		 * @public
		 */
		Hash.Defaults = {
			URLhashListener: false
		};
	
		/**
		 * Destroys the plugin.
		 * @public
		 */
		Hash.prototype.destroy = function() {
			var handler, property;
	
			$(window).off('hashchange.owl.navigation');
	
			for (handler in this._handlers) {
				this._core.$element.off(handler, this._handlers[handler]);
			}
			for (property in Object.getOwnPropertyNames(this)) {
				typeof this[property] != 'function' && (this[property] = null);
			}
		};
	
		$.fn.owlCarousel.Constructor.Plugins.Hash = Hash;
	
	})(window.Zepto || window.jQuery, window, document);
	
	/**
	 * Support Plugin
	 *
	 * @version 2.3.4
	 * @author Vivid Planet Software GmbH
	 * @author Artus Kolanowski
	 * @author David Deutsch
	 * @license The MIT License (MIT)
	 */
	;(function($, window, document, undefined) {
	
		var style = $('<support>').get(0).style,
			prefixes = 'Webkit Moz O ms'.split(' '),
			events = {
				transition: {
					end: {
						WebkitTransition: 'webkitTransitionEnd',
						MozTransition: 'transitionend',
						OTransition: 'oTransitionEnd',
						transition: 'transitionend'
					}
				},
				animation: {
					end: {
						WebkitAnimation: 'webkitAnimationEnd',
						MozAnimation: 'animationend',
						OAnimation: 'oAnimationEnd',
						animation: 'animationend'
					}
				}
			},
			tests = {
				csstransforms: function() {
					return !!test('transform');
				},
				csstransforms3d: function() {
					return !!test('perspective');
				},
				csstransitions: function() {
					return !!test('transition');
				},
				cssanimations: function() {
					return !!test('animation');
				}
			};
	
		function test(property, prefixed) {
			var result = false,
				upper = property.charAt(0).toUpperCase() + property.slice(1);
	
			$.each((property + ' ' + prefixes.join(upper + ' ') + upper).split(' '), function(i, property) {
				if (style[property] !== undefined) {
					result = prefixed ? property : true;
					return false;
				}
			});
	
			return result;
		}
	
		function prefixed(property) {
			return test(property, true);
		}
	
		if (tests.csstransitions()) {
			/* jshint -W053 */
			$.support.transition = new String(prefixed('transition'))
			$.support.transition.end = events.transition.end[ $.support.transition ];
		}
	
		if (tests.cssanimations()) {
			/* jshint -W053 */
			$.support.animation = new String(prefixed('animation'))
			$.support.animation.end = events.animation.end[ $.support.animation ];
		}
	
		if (tests.csstransforms()) {
			/* jshint -W053 */
			$.support.transform = new String(prefixed('transform'));
			$.support.transform3d = tests.csstransforms3d();
		}
	
	})(window.Zepto || window.jQuery, window, document);


/***/ }),
/* 30 */
/***/ (function(module, exports) {

	const reshMultiSelectValue = () => {
	    const options = [...document.querySelectorAll('.multiselect__dropdown__result__option')];
	    return options
	      .filter((el) => el.querySelector('input').checked)
	      .map((el) => el.querySelector('input').value);
	}
	
	const reshMultiSelectRemove = (attr, element) => {
	    if (element) {
	        element.parentNode.querySelector('.multiselect').remove();
	        return;
	    }
	    const select = document.querySelector(`.${attr}`);
	    select.parentNode.querySelector('.multiselect').remove();
	    // document.body.querySelector('#overlay').remove();
	};
	  
	const getOptions = (options) => options
	    .map((el) => `<span class="multiselect__dropdown__result__option" data-train='${el.dataset.train}' title='${el.text}'>
	        <label>
	            <input type="checkbox" value="${el.value}"">
	            ${el.text}
	        </label>
	        </span>`)
	    .join('');
	  
	const reshMultiSelectReplace = (attr, element) => {
	    if (element) {
	        const options = [...element.querySelectorAll('option')];
	        element.style.display = 'none';
	
	        const multiselect = document.createElement('div');
	        multiselect.classList.add('multiselect');
	        multiselect.innerHTML = (`<button class="multiselect__btn" type="button">
	            Все задания
	              <div class="multiselect__btn__arrow"></div>
	            </button>
	            <div class="display-none shadow multiselect__dropdown">
	              <input class="multiselect__dropdown__search" type="text">
	              <span class="d-block multiselect__dropdown__select-all">
	                <label>
	                  <input type="checkbox">
	                  Выбрать все
	                </label>
	              </span>
	              <div class="multiselect__dropdown__result">
	                ${getOptions(options)}
	              </div>
	              <div class="multiselect__ok-cancel">
	                <button class="multiselect__ok-cancel__ok" type="button">
	                  OK
	                </button>
	                <button class="multiselect__ok-cancel__cancel" type="button">
	                  Отмена
	                </button>
	              </div>
	            </div>`);
	        // element.parentNode.querySelector('.multiselect').remove();
	        element.parentNode.append(multiselect);
	        return;
	    }
	    console.log('!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!');
	
	    const allSelect = document.querySelectorAll(`.${attr}`);
	
	    allSelect.forEach((el) => {
	      if (el.parentNode.querySelectorAll('.multiselect').length >= 1 && el.parentNode.querySelectorAll('.multiselect__dropdown__result__option').length >= 1) {
	        return false;
	      }
	
	      if (el.parentNode.querySelectorAll('.multiselect').length >= 1) {
	        el.parentNode.querySelector('.multiselect').remove();
	      }
	      
	      const options = [...el.querySelectorAll('option')];
	      el.style.display = 'none';
	
	      const selectedOptionsCount = options
	        .filter((el) => el.hasAttribute('selected'))
	        .length;
	      const btnContent = selectedOptionsCount ? `Выбрано: ${selectedOptionsCount}` : 'Все задания';
	
	      const multiselect = document.createElement('div');
	        multiselect.classList.add('multiselect');
	        multiselect.innerHTML = (`<button class="multiselect__btn" type="button">
	              ${btnContent}
	              <div class="multiselect__btn__arrow"></div>
	            </button>
	            <div class="display-none shadow multiselect__dropdown">
	              <input class="multiselect__dropdown__search" type="text">
	              <span class="d-block multiselect__dropdown__select-all">
	                <label>
	                  <input type="checkbox">
	                  Выбрать все
	                </label>
	              </span>
	              <div class="multiselect__dropdown__result">
	                ${getOptions(options)}
	              </div>
	              <div class="multiselect__ok-cancel">
	                <button class="multiselect__ok-cancel__ok" type="button">
	                  OK
	                </button>
	                <button class="multiselect__ok-cancel__cancel" type="button">
	                  Отмена
	                </button>
	              </div>
	            </div>`);
	        el.parentNode.append(multiselect);
	    });
	    
	};
	
	function isAllChecked(options) {
	  if (options.length === 0) {
	    return false;
	  }
	  const checkedCounter = [...options].filter((opt) => opt.checked);
	  return options.length === checkedCounter.length;
	};
	
	function reshMultiSelectRun() {
	  const state = {
	    dropDownIsOpen: false,
	    selectAll: false,
	    selected: 'none',
	    searchText: '',
	  };
	
	  const selectAll = document.querySelectorAll('.multiselect__dropdown__select-all input');
	  const search = document.querySelectorAll('.multiselect__dropdown__search');
	  const dropDownOpt = document.querySelectorAll('.multiselect__dropdown__result__option input');
	  const allMultiBtn = document.querySelectorAll('.multiselect__btn');
	  const okBtn = document.querySelectorAll('.multiselect__ok-cancel__ok');
	  const cancelBtn = document.querySelectorAll('.multiselect__ok-cancel__cancel');
	
	  function dropDownButtonClick(e) {
	    const multiselectArrow = e.target.querySelector('.multiselect__btn__arrow');
	    const dropDown = e.target.parentNode.querySelector('.multiselect__dropdown');
	    const selectAll = dropDown.querySelector('.multiselect__dropdown__select-all input');
	    const search = dropDown.querySelector('.multiselect__dropdown__search');
	    const dropDownOpt = dropDown.querySelectorAll('.multiselect__dropdown__result__option input');
	    const selectedOpt = [...e.target.closest('.multiselect').parentNode.querySelectorAll('option')]
	      .filter((el) => el.hasAttribute('selected'))
	      .map((el) => el.value);
	
	    state.dropDownIsOpen = !state.dropDownIsOpen;
	    state.searchText = '';
	    
	    if (state.dropDownIsOpen) {
	      multiselectArrow.style.transform = 'rotate(180deg)';
	      e.target.classList.add("open");
	      dropDown.classList.remove("display-none");
	      search.value = state.searchText;
	      dropDownOpt.forEach((el) => {
	        el.closest('.multiselect__dropdown__result__option').classList.remove("display-none");
	        if (selectedOpt.includes(el.value)) {
	          el.checked = true;
	        }
	      })
	    } else {
	      multiselectArrow.style.transform = 'rotate(0deg)';
	      e.target.classList.remove("open");
	      dropDown.classList.add("display-none");
	      dropDownOpt.forEach((el) => el.checked = false);
	    }
	    
	    state.selectAll = isAllChecked(dropDownOpt);
	    selectAll.checked = state.selectAll;
	  };
	
	  allMultiBtn.forEach((el) => {
	    el.addEventListener("click", dropDownButtonClick);
	  });
	  
	  function okBtnClick(e) {
	    const multiSelect = e.target.closest('.multiselect');
	    const multiBtn = multiSelect.querySelector('.multiselect__btn');
	    const multiArrow = multiBtn.querySelector('.multiselect__btn__arrow');
	    const dropDown = multiSelect.querySelector('.multiselect__dropdown');
	    const selectorOpt = multiSelect.parentNode.querySelectorAll('select option');
	    const checkedValues = [...dropDown.querySelectorAll('.multiselect__dropdown__result__option input')]
	      .filter((el) => el.checked)
	      .map((el) => el.value);
	    let checkedCounter = 0;
	    
	    selectorOpt.forEach((el) => {
	      if (checkedValues.includes(el.value)) {
	        el.selected = true;
	        el.setAttribute('selected', 'selected');
	        checkedCounter += 1;
	      } else {
	        el.selected = false;
	        el.removeAttribute('selected');
	      }
	    })
	
	    const btnContent = checkedCounter ? `Выбрано: ${checkedCounter}` : 'Все задания';
	    state.dropDownIsOpen = false;
	    dropDown.classList.add("display-none");
	    multiBtn.classList.remove("open");
	    multiBtn.childNodes[0].textContent = btnContent;
	    multiArrow.style.transform = 'rotate(0deg)';
	    checkedCounter = 0;
	  };
	  
	  okBtn.forEach((el) => {
	    el.addEventListener("click", okBtnClick);
	  });
	  
	  function cancelBtnClick(e) {
	    const multiSelect = e.target.closest('.multiselect');
	    const multiBtn = multiSelect.querySelector('.multiselect__btn');
	    const multiArrow = multiSelect.querySelector('.multiselect__btn__arrow');
	    const dropDown = multiSelect.querySelector('.multiselect__dropdown');
	    const dropDownOpt = dropDown.querySelectorAll('.multiselect__dropdown__result__option');
	
	    state.dropDownIsOpen = false;
	    dropDown.classList.add("display-none");
	    multiBtn.classList.remove("open");
	    multiArrow.style.transform = 'rotate(0deg)';
	    dropDownOpt.forEach((el) => el.querySelector('input').checked = false);
	  };
	  
	  cancelBtn.forEach((el) => {
	    el.addEventListener("click", cancelBtnClick);
	  });
	  
	  function selectAllChange(e) {
	    const multiSelect = e.target.closest('.multiselect');
	    const dropDownOpt = multiSelect.querySelectorAll('.multiselect__dropdown__result__option input');
	    
	    state.selectAll = !state.selectAll;
	    
	    if (state.selectAll) {
	      dropDownOpt.forEach((el) => el.checked = true);
	    } else {
	      dropDownOpt.forEach((el) => el.checked = false);
	    }
	  };
	  
	  selectAll.forEach((el) => {
	    el.addEventListener("change", selectAllChange);
	  });
	  
	  function dropDownOptChange(e) {
	    const multiSelect = e.target.closest('.multiselect');
	    const selectAll = multiSelect.querySelector('.multiselect__dropdown__select-all input');
	    const dropDownOpt = multiSelect.querySelectorAll('.multiselect__dropdown__result__option input');
	    
	    state.selectAll = isAllChecked(dropDownOpt);
	    if (state.selectAll) {
	      selectAll.checked = true;
	    } else {
	      selectAll.checked = false;
	    }
	  };
	  
	  dropDownOpt.forEach((el) => el.addEventListener('change', dropDownOptChange));
	  
	  function searchInput(e) {
	    const multiSelect = e.target.closest('.multiselect');
	    const dropDownOpt = multiSelect.querySelectorAll('.multiselect__dropdown__result__option');
	
	    state.searchText = e.target.value.toLowerCase();
	    dropDownOpt.forEach((el) => {
	      const content = el.textContent.trim().toLowerCase();
	      if(!content.includes(state.searchText)) {
	        el.classList.add("display-none");
	      } else {
	        el.classList.remove("display-none");
	      }
	    });
	  }
	
	  search.forEach((el) => el.addEventListener('input', searchInput));
	};
	
	const reshMultiSelect = {
	    run: reshMultiSelectRun,
	    load: reshMultiSelectReplace,
	    remove: reshMultiSelectRemove,
	    values: reshMultiSelectValue,
	};
	
	module.exports = reshMultiSelect;


/***/ }),
/* 31 */
/***/ (function(module, exports) {

	module.exports = function getScrollbarWidth() {
	    const outer = document.createElement("div");
	    outer.style.visibility = "hidden";
	    outer.style.width = "100px";
	    outer.style.msOverflowStyle = "scrollbar"; // needed for WinJS apps
	
	    document.body.appendChild(outer);
	
	    const widthNoScroll = outer.offsetWidth;
	    // force scrollbars
	    outer.style.overflow = "scroll";
	
	    // add innerdiv
	    const inner = document.createElement("div");
	    inner.style.width = "100%";
	    outer.appendChild(inner);
	
	    const widthWithScroll = inner.offsetWidth;
	
	    // remove divs
	    outer.parentNode.removeChild(outer);
	
	    return widthNoScroll - widthWithScroll;
	}


/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

	var svg = __webpack_require__(33);
	
	svg();

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!function(root, factory) {
	     true ? // AMD. Register as an anonymous module unless amdModuleId is set
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {
	        return root.svg4everybody = factory();
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : "object" == typeof module && module.exports ? // Node. Does not work with strict CommonJS, but
	    // only CommonJS-like environments that support module.exports,
	    // like Node.
	    module.exports = factory() : root.svg4everybody = factory();
	}(this, function() {
	    /*! svg4everybody v2.1.9 | github.com/jonathantneal/svg4everybody */
	    function embed(parent, svg, target) {
	        // if the target exists
	        if (target) {
	            // create a document fragment to hold the contents of the target
	            var fragment = document.createDocumentFragment(), viewBox = !svg.hasAttribute("viewBox") && target.getAttribute("viewBox");
	            // conditionally set the viewBox on the svg
	            viewBox && svg.setAttribute("viewBox", viewBox);
	            // copy the contents of the clone into the fragment
	            for (// clone the target
	            var clone = target.cloneNode(!0); clone.childNodes.length; ) {
	                fragment.appendChild(clone.firstChild);
	            }
	            // append the fragment into the svg
	            parent.appendChild(fragment);
	        }
	    }
	    function loadreadystatechange(xhr) {
	        // listen to changes in the request
	        xhr.onreadystatechange = function() {
	            // if the request is ready
	            if (4 === xhr.readyState) {
	                // get the cached html document
	                var cachedDocument = xhr._cachedDocument;
	                // ensure the cached html document based on the xhr response
	                cachedDocument || (cachedDocument = xhr._cachedDocument = document.implementation.createHTMLDocument(""), 
	                cachedDocument.body.innerHTML = xhr.responseText, xhr._cachedTarget = {}), // clear the xhr embeds list and embed each item
	                xhr._embeds.splice(0).map(function(item) {
	                    // get the cached target
	                    var target = xhr._cachedTarget[item.id];
	                    // ensure the cached target
	                    target || (target = xhr._cachedTarget[item.id] = cachedDocument.getElementById(item.id)), 
	                    // embed the target into the svg
	                    embed(item.parent, item.svg, target);
	                });
	            }
	        }, // test the ready state change immediately
	        xhr.onreadystatechange();
	    }
	    function svg4everybody(rawopts) {
	        function oninterval() {
	            // while the index exists in the live <use> collection
	            for (// get the cached <use> index
	            var index = 0; index < uses.length; ) {
	                // get the current <use>
	                var use = uses[index], parent = use.parentNode, svg = getSVGAncestor(parent), src = use.getAttribute("xlink:href") || use.getAttribute("href");
	                if (!src && opts.attributeName && (src = use.getAttribute(opts.attributeName)), 
	                svg && src) {
	                    if (polyfill) {
	                        if (!opts.validate || opts.validate(src, svg, use)) {
	                            // remove the <use> element
	                            parent.removeChild(use);
	                            // parse the src and get the url and id
	                            var srcSplit = src.split("#"), url = srcSplit.shift(), id = srcSplit.join("#");
	                            // if the link is external
	                            if (url.length) {
	                                // get the cached xhr request
	                                var xhr = requests[url];
	                                // ensure the xhr request exists
	                                xhr || (xhr = requests[url] = new XMLHttpRequest(), xhr.open("GET", url), xhr.send(), 
	                                xhr._embeds = []), // add the svg and id as an item to the xhr embeds list
	                                xhr._embeds.push({
	                                    parent: parent,
	                                    svg: svg,
	                                    id: id
	                                }), // prepare the xhr ready state change event
	                                loadreadystatechange(xhr);
	                            } else {
	                                // embed the local id into the svg
	                                embed(parent, svg, document.getElementById(id));
	                            }
	                        } else {
	                            // increase the index when the previous value was not "valid"
	                            ++index, ++numberOfSvgUseElementsToBypass;
	                        }
	                    }
	                } else {
	                    // increase the index when the previous value was not "valid"
	                    ++index;
	                }
	            }
	            // continue the interval
	            (!uses.length || uses.length - numberOfSvgUseElementsToBypass > 0) && requestAnimationFrame(oninterval, 67);
	        }
	        var polyfill, opts = Object(rawopts), newerIEUA = /\bTrident\/[567]\b|\bMSIE (?:9|10)\.0\b/, webkitUA = /\bAppleWebKit\/(\d+)\b/, olderEdgeUA = /\bEdge\/12\.(\d+)\b/, edgeUA = /\bEdge\/.(\d+)\b/, inIframe = window.top !== window.self;
	        polyfill = "polyfill" in opts ? opts.polyfill : newerIEUA.test(navigator.userAgent) || (navigator.userAgent.match(olderEdgeUA) || [])[1] < 10547 || (navigator.userAgent.match(webkitUA) || [])[1] < 537 || edgeUA.test(navigator.userAgent) && inIframe;
	        // create xhr requests object
	        var requests = {}, requestAnimationFrame = window.requestAnimationFrame || setTimeout, uses = document.getElementsByTagName("use"), numberOfSvgUseElementsToBypass = 0;
	        // conditionally start the interval if the polyfill is active
	        polyfill && oninterval();
	    }
	    function getSVGAncestor(node) {
	        for (var svg = node; "svg" !== svg.nodeName.toLowerCase() && (svg = svg.parentNode); ) {}
	        return svg;
	    }
	    return svg4everybody;
	});

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(35);
	
	$('._tooltip').tooltipster({
	   theme: 'tooltipster-light',
	   animation: 'fade',
	   position: 'bottom',
	   delay: 0
	});
	
	
	var tooltip2 = {
	   collection: $('._tooltip2'),
	   options: {
	      theme: 'tooltipster-light',
	      animation: 'fade',
	      position: 'bottom',
	      delay: 0,
	      arrow: false
	   }
	};
	
	tooltip2.collection.tooltipster(tooltip2.options);
	
	module.exports = tooltip2;


/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * tooltipster http://iamceege.github.io/tooltipster/
	 * A rockin' custom tooltip jQuery plugin
	 * Developed by Caleb Jacob and Louis Ameline
	 * MIT license
	 */
	(function (root, factory) {
	  if (true) {
	    // AMD. Register as an anonymous module unless amdModuleId is set
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(7)], __WEBPACK_AMD_DEFINE_RESULT__ = function (a0) {
	      return (factory(a0));
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  } else if (typeof exports === 'object') {
	    // Node. Does not app with strict CommonJS, but
	    // only CommonJS-like environments that support module.exports,
	    // like Node.
	    module.exports = factory(require("jquery"));
	  } else {
	    factory(jQuery);
	  }
	}(this, function ($) {
	
	// This file will be UMDified by a build task.
	
	var defaults = {
			animation: 'fade',
			animationDuration: 350,
			content: null,
			contentAsHTML: false,
			contentCloning: false,
			debug: true,
			delay: 300,
			delayTouch: [300, 500],
			functionInit: null,
			functionBefore: null,
			functionReady: null,
			functionAfter: null,
			functionFormat: null,
			IEmin: 6,
			interactive: false,
			multiple: false,
			// must be 'body' for now, or an element positioned at (0, 0)
			// in the document, typically like the very top views of an app.
			parent: 'body',
			plugins: ['sideTip'],
			repositionOnScroll: false,
			restoration: 'none',
			selfDestruction: true,
			theme: [],
			timer: 0,
			trackerInterval: 500,
			trackOrigin: false,
			trackTooltip: false,
			trigger: 'hover',
			triggerClose: {
				click: false,
				mouseleave: false,
				originClick: false,
				scroll: false,
				tap: false,
				touchleave: false
			},
			triggerOpen: {
				click: false,
				mouseenter: false,
				tap: false,
				touchstart: false
			},
			updateAnimation: 'rotate',
			zIndex: 9999999
		},
		// we'll avoid using the 'window' global as a good practice but npm's
		// jquery@<2.1.0 package actually requires a 'window' global, so not sure
		// it's useful at all
		win = (typeof window != 'undefined') ? window : null,
		// env will be proxied by the core for plugins to have access its properties
		env = {
			// detect if this device can trigger touch events. Better have a false
			// positive (unused listeners, that's ok) than a false negative.
			// https://github.com/Modernizr/Modernizr/blob/master/feature-detects/touchevents.js
			// http://stackoverflow.com/questions/4817029/whats-the-best-way-to-detect-a-touch-screen-device-using-javascript
			hasTouchCapability: !!(
				win
				&&	(	'ontouchstart' in win
					||	(win.DocumentTouch && win.document instanceof win.DocumentTouch)
					||	win.navigator.maxTouchPoints
				)
			),
			hasTransitions: transitionSupport(),
			IE: false,
			// don't set manually, it will be updated by a build task after the manifest
			semVer: '4.1.4',
			window: win
		},
		core = function() {
			
			// core variables
			
			// the core emitters
			this.__$emitterPrivate = $({});
			this.__$emitterPublic = $({});
			this.__instancesLatestArr = [];
			// collects plugin constructors
			this.__plugins = {};
			// proxy env variables for plugins who might use them
			this._env = env;
		};
	
	// core methods
	core.prototype = {
		
		/**
		 * A function to proxy the public methods of an object onto another
		 *
		 * @param {object} constructor The constructor to bridge
		 * @param {object} obj The object that will get new methods (an instance or the core)
		 * @param {string} pluginName A plugin name for the console log message
		 * @return {core}
		 * @private
		 */
		__bridge: function(constructor, obj, pluginName) {
			
			// if it's not already bridged
			if (!obj[pluginName]) {
				
				var fn = function() {};
				fn.prototype = constructor;
				
				var pluginInstance = new fn();
				
				// the _init method has to exist in instance constructors but might be missing
				// in core constructors
				if (pluginInstance.__init) {
					pluginInstance.__init(obj);
				}
				
				$.each(constructor, function(methodName, fn) {
					
					// don't proxy "private" methods, only "protected" and public ones
					if (methodName.indexOf('__') != 0) {
						
						// if the method does not exist yet
						if (!obj[methodName]) {
							
							obj[methodName] = function() {
								return pluginInstance[methodName].apply(pluginInstance, Array.prototype.slice.apply(arguments));
							};
							
							// remember to which plugin this method corresponds (several plugins may
							// have methods of the same name, we need to be sure)
							obj[methodName].bridged = pluginInstance;
						}
						else if (defaults.debug) {
							
							console.log('The '+ methodName +' method of the '+ pluginName
								+' plugin conflicts with another plugin or native methods');
						}
					}
				});
				
				obj[pluginName] = pluginInstance;
			}
			
			return this;
		},
		
		/**
		 * For mockup in Node env if need be, for testing purposes
		 *
		 * @return {core}
		 * @private
		 */
		__setWindow: function(window) {
			env.window = window;
			return this;
		},
		
		/**
		 * Returns a ruler, a tool to help measure the size of a tooltip under
		 * various settings. Meant for plugins
		 * 
		 * @see Ruler
		 * @return {object} A Ruler instance
		 * @protected
		 */
		_getRuler: function($tooltip) {
			return new Ruler($tooltip);
		},
		
		/**
		 * For internal use by plugins, if needed
		 *
		 * @return {core}
		 * @protected
		 */
		_off: function() {
			this.__$emitterPrivate.off.apply(this.__$emitterPrivate, Array.prototype.slice.apply(arguments));
			return this;
		},
		
		/**
		 * For internal use by plugins, if needed
		 *
		 * @return {core}
		 * @protected
		 */
		_on: function() {
			this.__$emitterPrivate.on.apply(this.__$emitterPrivate, Array.prototype.slice.apply(arguments));
			return this;
		},
		
		/**
		 * For internal use by plugins, if needed
		 *
		 * @return {core}
		 * @protected
		 */
		_one: function() {
			this.__$emitterPrivate.one.apply(this.__$emitterPrivate, Array.prototype.slice.apply(arguments));
			return this;
		},
		
		/**
		 * Returns (getter) or adds (setter) a plugin
		 *
		 * @param {string|object} plugin Provide a string (in the full form
		 * "namespace.name") to use as as getter, an object to use as a setter
		 * @return {object|core}
		 * @protected
		 */
		_plugin: function(plugin) {
			
			var self = this;
			
			// getter
			if (typeof plugin == 'string') {
				
				var pluginName = plugin,
					p = null;
				
				// if the namespace is provided, it's easy to search
				if (pluginName.indexOf('.') > 0) {
					p = self.__plugins[pluginName];
				}
				// otherwise, return the first name that matches
				else {
					$.each(self.__plugins, function(i, plugin) {
						
						if (plugin.name.substring(plugin.name.length - pluginName.length - 1) == '.'+ pluginName) {
							p = plugin;
							return false;
						}
					});
				}
				
				return p;
			}
			// setter
			else {
				
				// force namespaces
				if (plugin.name.indexOf('.') < 0) {
					throw new Error('Plugins must be namespaced');
				}
				
				self.__plugins[plugin.name] = plugin;
				
				// if the plugin has core features
				if (plugin.core) {
					
					// bridge non-private methods onto the core to allow new core methods
					self.__bridge(plugin.core, self, plugin.name);
				}
				
				return this;
			}
		},
		
		/**
		 * Trigger events on the core emitters
		 * 
		 * @returns {core}
		 * @protected
		 */
		_trigger: function() {
			
			var args = Array.prototype.slice.apply(arguments);
			
			if (typeof args[0] == 'string') {
				args[0] = { type: args[0] };
			}
			
			// note: the order of emitters matters
			this.__$emitterPrivate.trigger.apply(this.__$emitterPrivate, args);
			this.__$emitterPublic.trigger.apply(this.__$emitterPublic, args);
			
			return this;
		},
		
		/**
		 * Returns instances of all tooltips in the page or an a given element
		 *
		 * @param {string|HTML object collection} selector optional Use this
		 * parameter to restrict the set of objects that will be inspected
		 * for the retrieval of instances. By default, all instances in the
		 * page are returned.
		 * @return {array} An array of instance objects
		 * @public
		 */
		instances: function(selector) {
			
			var instances = [],
				sel = selector || '.tooltipstered';
			
			$(sel).each(function() {
				
				var $this = $(this),
					ns = $this.data('tooltipster-ns');
				
				if (ns) {
					
					$.each(ns, function(i, namespace) {
						instances.push($this.data(namespace));
					});
				}
			});
			
			return instances;
		},
		
		/**
		 * Returns the Tooltipster objects generated by the last initializing call
		 *
		 * @return {array} An array of instance objects
		 * @public
		 */
		instancesLatest: function() {
			return this.__instancesLatestArr;
		},
		
		/**
		 * For public use only, not to be used by plugins (use ::_off() instead)
		 *
		 * @return {core}
		 * @public
		 */
		off: function() {
			this.__$emitterPublic.off.apply(this.__$emitterPublic, Array.prototype.slice.apply(arguments));
			return this;
		},
		
		/**
		 * For public use only, not to be used by plugins (use ::_on() instead)
		 *
		 * @return {core}
		 * @public
		 */
		on: function() {
			this.__$emitterPublic.on.apply(this.__$emitterPublic, Array.prototype.slice.apply(arguments));
			return this;
		},
		
		/**
		 * For public use only, not to be used by plugins (use ::_one() instead)
		 * 
		 * @return {core}
		 * @public
		 */
		one: function() {
			this.__$emitterPublic.one.apply(this.__$emitterPublic, Array.prototype.slice.apply(arguments));
			return this;
		},
		
		/**
		 * Returns all HTML elements which have one or more tooltips
		 *
		 * @param {string} selector optional Use this to restrict the results
		 * to the descendants of an element
		 * @return {array} An array of HTML elements
		 * @public
		 */
		origins: function(selector) {
			
			var sel = selector ?
				selector +' ' :
				'';
			
			return $(sel +'.tooltipstered').toArray();
		},
		
		/**
		 * Change default options for all future instances
		 *
		 * @param {object} d The options that should be made defaults
		 * @return {core}
		 * @public
		 */
		setDefaults: function(d) {
			$.extend(defaults, d);
			return this;
		},
		
		/**
		 * For users to trigger their handlers on the public emitter
		 * 
		 * @returns {core}
		 * @public
		 */
		triggerHandler: function() {
			this.__$emitterPublic.triggerHandler.apply(this.__$emitterPublic, Array.prototype.slice.apply(arguments));
			return this;
		}
	};
	
	// $.tooltipster will be used to call core methods
	$.tooltipster = new core();
	
	// the Tooltipster instance class (mind the capital T)
	$.Tooltipster = function(element, options) {
		
		// list of instance variables
		
		// stack of custom callbacks provided as parameters to API methods
		this.__callbacks = {
			close: [],
			open: []
		};
		// the schedule time of DOM removal
		this.__closingTime;
		// this will be the user content shown in the tooltip. A capital "C" is used
		// because there is also a method called content()
		this.__Content;
		// for the size tracker
		this.__contentBcr;
		// to disable the tooltip once the destruction has begun
		this.__destroyed = false;
		this.__destroying = false;
		// we can't emit directly on the instance because if a method with the same
		// name as the event exists, it will be called by jQuery. Se we use a plain
		// object as emitter. This emitter is for internal use by plugins,
		// if needed.
		this.__$emitterPrivate = $({});
		// this emitter is for the user to listen to events without risking to mess
		// with our internal listeners
		this.__$emitterPublic = $({});
		this.__enabled = true;
		// the reference to the gc interval
		this.__garbageCollector;
		// various position and size data recomputed before each repositioning
		this.__Geometry;
		// the tooltip position, saved after each repositioning by a plugin
		this.__lastPosition;
		// a unique namespace per instance
		this.__namespace = 'tooltipster-'+ Math.round(Math.random()*1000000);
		this.__options;
		// will be used to support origins in scrollable areas
		this.__$originParents;
		this.__pointerIsOverOrigin = false;
		// to remove themes if needed
		this.__previousThemes = [];
		// the state can be either: appearing, stable, disappearing, closed
		this.__state = 'closed';
		// timeout references
		this.__timeouts = {
			close: [],
			open: null
		};
		// store touch events to be able to detect emulated mouse events
		this.__touchEvents = [];
		// the reference to the tracker interval
		this.__tracker = null;
		// the element to which this tooltip is associated
		this._$origin;
		// this will be the tooltip element (jQuery wrapped HTML element).
		// It's the job of a plugin to create it and append it to the DOM
		this._$tooltip;
		
		// launch
		this.__init(element, options);
	};
	
	$.Tooltipster.prototype = {
		
		/**
		 * @param origin
		 * @param options
		 * @private
		 */
		__init: function(origin, options) {
			
			var self = this;
			
			self._$origin = $(origin);
			self.__options = $.extend(true, {}, defaults, options);
			
			// some options may need to be reformatted
			self.__optionsFormat();
			
			// don't run on old IE if asked no to
			if (	!env.IE
				||	env.IE >= self.__options.IEmin
			) {
				
				// note: the content is null (empty) by default and can stay that
				// way if the plugin remains initialized but not fed any content. The
				// tooltip will just not appear.
				
				// let's save the initial value of the title attribute for later
				// restoration if need be.
				var initialTitle = null;
				
				// it will already have been saved in case of multiple tooltips
				if (self._$origin.data('tooltipster-initialTitle') === undefined) {
					
					initialTitle = self._$origin.attr('title');
					
					// we do not want initialTitle to be "undefined" because
					// of how jQuery's .data() method works
					if (initialTitle === undefined) initialTitle = null;
					
					self._$origin.data('tooltipster-initialTitle', initialTitle);
				}
				
				// If content is provided in the options, it has precedence over the
				// title attribute.
				// Note: an empty string is considered content, only 'null' represents
				// the absence of content.
				// Also, an existing title="" attribute will result in an empty string
				// content
				if (self.__options.content !== null) {
					self.__contentSet(self.__options.content);
				}
				else {
					
					var selector = self._$origin.attr('data-tooltip-content'),
						$el;
					
					if (selector){
						$el = $(selector);
					}
					
					if ($el && $el[0]) {
						self.__contentSet($el.first());
					}
					else {
						self.__contentSet(initialTitle);
					}
				}
				
				self._$origin
					// strip the title off of the element to prevent the default tooltips
					// from popping up
					.removeAttr('title')
					// to be able to find all instances on the page later (upon window
					// events in particular)
					.addClass('tooltipstered');
				
				// set listeners on the origin
				self.__prepareOrigin();
				
				// set the garbage collector
				self.__prepareGC();
				
				// init plugins
				$.each(self.__options.plugins, function(i, pluginName) {
					self._plug(pluginName);
				});
				
				// to detect swiping
				if (env.hasTouchCapability) {
					$('body').on('touchmove.'+ self.__namespace +'-triggerOpen', function(event) {
						self._touchRecordEvent(event);
					});
				}
				
				self
					// prepare the tooltip when it gets created. This event must
					// be fired by a plugin
					._on('created', function() {
						self.__prepareTooltip();
					})
					// save position information when it's sent by a plugin
					._on('repositioned', function(e) {
						self.__lastPosition = e.position;
					});
			}
			else {
				self.__options.disabled = true;
			}
		},
		
		/**
		 * Insert the content into the appropriate HTML element of the tooltip
		 * 
		 * @returns {self}
		 * @private
		 */
		__contentInsert: function() {
			
			var self = this,
				$el = self._$tooltip.find('.tooltipster-content'),
				formattedContent = self.__Content,
				format = function(content) {
					formattedContent = content;
				};
			
			self._trigger({
				type: 'format',
				content: self.__Content,
				format: format
			});
			
			if (self.__options.functionFormat) {
				
				formattedContent = self.__options.functionFormat.call(
					self,
					self,
					{ origin: self._$origin[0] },
					self.__Content
				);
			}
			
			if (typeof formattedContent === 'string' && !self.__options.contentAsHTML) {
				$el.text(formattedContent);
			}
			else {
				$el
					.empty()
					.append(formattedContent);
			}
			
			return self;
		},
		
		/**
		 * Save the content, cloning it beforehand if need be
		 * 
		 * @param content
		 * @returns {self}
		 * @private
		 */
		__contentSet: function(content) {
			
			// clone if asked. Cloning the object makes sure that each instance has its
			// own version of the content (in case a same object were provided for several
			// instances)
			// reminder: typeof null === object
			if (content instanceof $ && this.__options.contentCloning) {
				content = content.clone(true);
			}
			
			this.__Content = content;
			
			this._trigger({
				type: 'updated',
				content: content
			});
			
			return this;
		},
		
		/**
		 * Error message about a method call made after destruction
		 * 
		 * @private
		 */
		__destroyError: function() {
			throw new Error('This tooltip has been destroyed and cannot execute your method call.');
		},
		
		/**
		 * Gather all information about dimensions and available space,
		 * called before every repositioning
		 * 
		 * @private
		 * @returns {object}
		 */
		__geometry: function() {
			
			var	self = this,
				$target = self._$origin,
				originIsArea = self._$origin.is('area');
			
			// if this._$origin is a map area, the target we'll need
			// the dimensions of is actually the image using the map,
			// not the area itself
			if (originIsArea) {
				
				var mapName = self._$origin.parent().attr('name');
				
				$target = $('img[usemap="#'+ mapName +'"]');
			}
			
			var bcr = $target[0].getBoundingClientRect(),
				$document = $(env.window.document),
				$window = $(env.window),
				$parent = $target,
				// some useful properties of important elements
				geo = {
					// available space for the tooltip, see down below
					available: {
						document: null,
						window: null
					},
					document: {
						size: {
							height: $document.height(),
							width: $document.width()
						}
					},
					window: {
						scroll: {
							// the second ones are for IE compatibility
							left: env.window.scrollX || env.window.document.documentElement.scrollLeft,
							top: env.window.scrollY || env.window.document.documentElement.scrollTop
						},
						size: {
							height: $window.height(),
							width: $window.width()
						}
					},
					origin: {
						// the origin has a fixed lineage if itself or one of its
						// ancestors has a fixed position
						fixedLineage: false,
						// relative to the document
						offset: {},
						size: {
							height: bcr.bottom - bcr.top,
							width: bcr.right - bcr.left
						},
						usemapImage: originIsArea ? $target[0] : null,
						// relative to the window
						windowOffset: {
							bottom: bcr.bottom,
							left: bcr.left,
							right: bcr.right,
							top: bcr.top
						}
					}
				},
				geoFixed = false;
			
			// if the element is a map area, some properties may need
			// to be recalculated
			if (originIsArea) {
				
				var shape = self._$origin.attr('shape'),
					coords = self._$origin.attr('coords');
				
				if (coords) {
					
					coords = coords.split(',');
					
					$.map(coords, function(val, i) {
						coords[i] = parseInt(val);
					});
				}
				
				// if the image itself is the area, nothing more to do
				if (shape != 'default') {
					
					switch(shape) {
						
						case 'circle':
							
							var circleCenterLeft = coords[0],
								circleCenterTop = coords[1],
								circleRadius = coords[2],
								areaTopOffset = circleCenterTop - circleRadius,
								areaLeftOffset = circleCenterLeft - circleRadius;
							
							geo.origin.size.height = circleRadius * 2;
							geo.origin.size.width = geo.origin.size.height;
							
							geo.origin.windowOffset.left += areaLeftOffset;
							geo.origin.windowOffset.top += areaTopOffset;
							
							break;
						
						case 'rect':
							
							var areaLeft = coords[0],
								areaTop = coords[1],
								areaRight = coords[2],
								areaBottom = coords[3];
							
							geo.origin.size.height = areaBottom - areaTop;
							geo.origin.size.width = areaRight - areaLeft;
							
							geo.origin.windowOffset.left += areaLeft;
							geo.origin.windowOffset.top += areaTop;
							
							break;
						
						case 'poly':
							
							var areaSmallestX = 0,
								areaSmallestY = 0,
								areaGreatestX = 0,
								areaGreatestY = 0,
								arrayAlternate = 'even';
							
							for (var i = 0; i < coords.length; i++) {
								
								var areaNumber = coords[i];
								
								if (arrayAlternate == 'even') {
									
									if (areaNumber > areaGreatestX) {
										
										areaGreatestX = areaNumber;
										
										if (i === 0) {
											areaSmallestX = areaGreatestX;
										}
									}
									
									if (areaNumber < areaSmallestX) {
										areaSmallestX = areaNumber;
									}
									
									arrayAlternate = 'odd';
								}
								else {
									if (areaNumber > areaGreatestY) {
										
										areaGreatestY = areaNumber;
										
										if (i == 1) {
											areaSmallestY = areaGreatestY;
										}
									}
									
									if (areaNumber < areaSmallestY) {
										areaSmallestY = areaNumber;
									}
									
									arrayAlternate = 'even';
								}
							}
							
							geo.origin.size.height = areaGreatestY - areaSmallestY;
							geo.origin.size.width = areaGreatestX - areaSmallestX;
							
							geo.origin.windowOffset.left += areaSmallestX;
							geo.origin.windowOffset.top += areaSmallestY;
							
							break;
					}
				}
			}
			
			// user callback through an event
			var edit = function(r) {
				geo.origin.size.height = r.height,
					geo.origin.windowOffset.left = r.left,
					geo.origin.windowOffset.top = r.top,
					geo.origin.size.width = r.width
			};
			
			self._trigger({
				type: 'geometry',
				edit: edit,
				geometry: {
					height: geo.origin.size.height,
					left: geo.origin.windowOffset.left,
					top: geo.origin.windowOffset.top,
					width: geo.origin.size.width
				}
			});
			
			// calculate the remaining properties with what we got
			
			geo.origin.windowOffset.right = geo.origin.windowOffset.left + geo.origin.size.width;
			geo.origin.windowOffset.bottom = geo.origin.windowOffset.top + geo.origin.size.height;
			
			geo.origin.offset.left = geo.origin.windowOffset.left + geo.window.scroll.left;
			geo.origin.offset.top = geo.origin.windowOffset.top + geo.window.scroll.top;
			geo.origin.offset.bottom = geo.origin.offset.top + geo.origin.size.height;
			geo.origin.offset.right = geo.origin.offset.left + geo.origin.size.width;
			
			// the space that is available to display the tooltip relatively to the document
			geo.available.document = {
				bottom: {
					height: geo.document.size.height - geo.origin.offset.bottom,
					width: geo.document.size.width
				},
				left: {
					height: geo.document.size.height,
					width: geo.origin.offset.left
				},
				right: {
					height: geo.document.size.height,
					width: geo.document.size.width - geo.origin.offset.right
				},
				top: {
					height: geo.origin.offset.top,
					width: geo.document.size.width
				}
			};
			
			// the space that is available to display the tooltip relatively to the viewport
			// (the resulting values may be negative if the origin overflows the viewport)
			geo.available.window = {
				bottom: {
					// the inner max is here to make sure the available height is no bigger
					// than the viewport height (when the origin is off screen at the top).
					// The outer max just makes sure that the height is not negative (when
					// the origin overflows at the bottom).
					height: Math.max(geo.window.size.height - Math.max(geo.origin.windowOffset.bottom, 0), 0),
					width: geo.window.size.width
				},
				left: {
					height: geo.window.size.height,
					width: Math.max(geo.origin.windowOffset.left, 0)
				},
				right: {
					height: geo.window.size.height,
					width: Math.max(geo.window.size.width - Math.max(geo.origin.windowOffset.right, 0), 0)
				},
				top: {
					height: Math.max(geo.origin.windowOffset.top, 0),
					width: geo.window.size.width
				}
			};
			
			while ($parent[0].tagName.toLowerCase() != 'html') {
				
				if ($parent.css('position') == 'fixed') {
					geo.origin.fixedLineage = true;
					break;
				}
				
				$parent = $parent.parent();
			}
			
			return geo;
		},
		
		/**
		 * Some options may need to be formated before being used
		 * 
		 * @returns {self}
		 * @private
		 */
		__optionsFormat: function() {
			
			if (typeof this.__options.animationDuration == 'number') {
				this.__options.animationDuration = [this.__options.animationDuration, this.__options.animationDuration];
			}
			
			if (typeof this.__options.delay == 'number') {
				this.__options.delay = [this.__options.delay, this.__options.delay];
			}
			
			if (typeof this.__options.delayTouch == 'number') {
				this.__options.delayTouch = [this.__options.delayTouch, this.__options.delayTouch];
			}
			
			if (typeof this.__options.theme == 'string') {
				this.__options.theme = [this.__options.theme];
			}
			
			// determine the future parent
			if (typeof this.__options.parent == 'string') {
				this.__options.parent = $(this.__options.parent);
			}
			
			if (this.__options.trigger == 'hover') {
				
				this.__options.triggerOpen = {
					mouseenter: true,
					touchstart: true
				};
				
				this.__options.triggerClose = {
					mouseleave: true,
					originClick: true,
					touchleave: true
				};
			}
			else if (this.__options.trigger == 'click') {
				
				this.__options.triggerOpen = {
					click: true,
					tap: true
				};
				
				this.__options.triggerClose = {
					click: true,
					tap: true
				};
			}
			
			// for the plugins
			this._trigger('options');
			
			return this;
		},
		
		/**
		 * Schedules or cancels the garbage collector task
		 *
		 * @returns {self}
		 * @private
		 */
		__prepareGC: function() {
			
			var self = this;
			
			// in case the selfDestruction option has been changed by a method call
			if (self.__options.selfDestruction) {
				
				// the GC task
				self.__garbageCollector = setInterval(function() {
					
					var now = new Date().getTime();
					
					// forget the old events
					self.__touchEvents = $.grep(self.__touchEvents, function(event, i) {
						// 1 minute
						return now - event.time > 60000;
					});
					
					// auto-destruct if the origin is gone
					if (!bodyContains(self._$origin)) {
						self.destroy();
					}
				}, 20000);
			}
			else {
				clearInterval(self.__garbageCollector);
			}
			
			return self;
		},
		
		/**
		 * Sets listeners on the origin if the open triggers require them.
		 * Unlike the listeners set at opening time, these ones
		 * remain even when the tooltip is closed. It has been made a
		 * separate method so it can be called when the triggers are
		 * changed in the options. Closing is handled in _open()
		 * because of the bindings that may be needed on the tooltip
		 * itself
		 *
		 * @returns {self}
		 * @private
		 */
		__prepareOrigin: function() {
			
			var self = this;
			
			// in case we're resetting the triggers
			self._$origin.off('.'+ self.__namespace +'-triggerOpen');
			
			// if the device is touch capable, even if only mouse triggers
			// are asked, we need to listen to touch events to know if the mouse
			// events are actually emulated (so we can ignore them)
			if (env.hasTouchCapability) {
				
				self._$origin.on(
					'touchstart.'+ self.__namespace +'-triggerOpen ' +
					'touchend.'+ self.__namespace +'-triggerOpen ' +
					'touchcancel.'+ self.__namespace +'-triggerOpen',
					function(event){
						self._touchRecordEvent(event);
					}
				);
			}
			
			// mouse click and touch tap app the same way
			if (	self.__options.triggerOpen.click
				||	(self.__options.triggerOpen.tap && env.hasTouchCapability)
			) {
				
				var eventNames = '';
				if (self.__options.triggerOpen.click) {
					eventNames += 'click.'+ self.__namespace +'-triggerOpen ';
				}
				if (self.__options.triggerOpen.tap && env.hasTouchCapability) {
					eventNames += 'touchend.'+ self.__namespace +'-triggerOpen';
				}
				
				self._$origin.on(eventNames, function(event) {
					if (self._touchIsMeaningfulEvent(event)) {
						self._open(event);
					}
				});
			}
			
			// mouseenter and touch start app the same way
			if (	self.__options.triggerOpen.mouseenter
				||	(self.__options.triggerOpen.touchstart && env.hasTouchCapability)
			) {
				
				var eventNames = '';
				if (self.__options.triggerOpen.mouseenter) {
					eventNames += 'mouseenter.'+ self.__namespace +'-triggerOpen ';
				}
				if (self.__options.triggerOpen.touchstart && env.hasTouchCapability) {
					eventNames += 'touchstart.'+ self.__namespace +'-triggerOpen';
				}
				
				self._$origin.on(eventNames, function(event) {
					if (	self._touchIsTouchEvent(event)
						||	!self._touchIsEmulatedEvent(event)
					) {
						self.__pointerIsOverOrigin = true;
						self._openShortly(event);
					}
				});
			}
			
			// info for the mouseleave/touchleave close triggers when they use a delay
			if (	self.__options.triggerClose.mouseleave
				||	(self.__options.triggerClose.touchleave && env.hasTouchCapability)
			) {
				
				var eventNames = '';
				if (self.__options.triggerClose.mouseleave) {
					eventNames += 'mouseleave.'+ self.__namespace +'-triggerOpen ';
				}
				if (self.__options.triggerClose.touchleave && env.hasTouchCapability) {
					eventNames += 'touchend.'+ self.__namespace +'-triggerOpen touchcancel.'+ self.__namespace +'-triggerOpen';
				}
				
				self._$origin.on(eventNames, function(event) {
					
					if (self._touchIsMeaningfulEvent(event)) {
						self.__pointerIsOverOrigin = false;
					}
				});
			}
			
			return self;
		},
		
		/**
		 * Do the things that need to be done only once after the tooltip
		 * HTML element it has been created. It has been made a separate
		 * method so it can be called when options are changed. Remember
		 * that the tooltip may actually exist in the DOM before it is
		 * opened, and present after it has been closed: it's the display
		 * plugin that takes care of handling it.
		 * 
		 * @returns {self}
		 * @private
		 */
		__prepareTooltip: function() {
			
			var self = this,
				p = self.__options.interactive ? 'auto' : '';
			
			// this will be useful to know quickly if the tooltip is in
			// the DOM or not 
			self._$tooltip
				.attr('id', self.__namespace)
				.css({
					// pointer events
					'pointer-events': p,
					zIndex: self.__options.zIndex
				});
			
			// themes
			// remove the old ones and add the new ones
			$.each(self.__previousThemes, function(i, theme) {
				self._$tooltip.removeClass(theme);
			});
			$.each(self.__options.theme, function(i, theme) {
				self._$tooltip.addClass(theme);
			});
			
			self.__previousThemes = $.merge([], self.__options.theme);
			
			return self;
		},
		
		/**
		 * Handles the scroll on any of the parents of the origin (when the
		 * tooltip is open)
		 *
		 * @param {object} event
		 * @returns {self}
		 * @private
		 */
		__scrollHandler: function(event) {
			
			var self = this;
			
			if (self.__options.triggerClose.scroll) {
				self._close(event);
			}
			else {
				
				// if the scroll happened on the window
				if (event.target === env.window.document) {
					
					// if the origin has a fixed lineage, window scroll will have no
					// effect on its position nor on the position of the tooltip
					if (!self.__Geometry.origin.fixedLineage) {
						
						// we don't need to do anything unless repositionOnScroll is true
						// because the tooltip will already have moved with the window
						// (and of course with the origin)
						if (self.__options.repositionOnScroll) {
							self.reposition(event);
						}
					}
				}
				// if the scroll happened on another parent of the tooltip, it means
				// that it's in a scrollable area and now needs to have its position
				// adjusted or recomputed, depending ont the repositionOnScroll
				// option. Also, if the origin is partly hidden due to a parent that
				// hides its overflow, we'll just hide (not close) the tooltip.
				else {
					
					var g = self.__geometry(),
						overflows = false;
					
					// a fixed position origin is not affected by the overflow hiding
					// of a parent
					if (self._$origin.css('position') != 'fixed') {
						
						self.__$originParents.each(function(i, el) {
							
							var $el = $(el),
								overflowX = $el.css('overflow-x'),
								overflowY = $el.css('overflow-y');
							
							if (overflowX != 'visible' || overflowY != 'visible') {
								
								var bcr = el.getBoundingClientRect();
								
								if (overflowX != 'visible') {
									
									if (	g.origin.windowOffset.left < bcr.left
										||	g.origin.windowOffset.right > bcr.right
									) {
										overflows = true;
										return false;
									}
								}
								
								if (overflowY != 'visible') {
									
									if (	g.origin.windowOffset.top < bcr.top
										||	g.origin.windowOffset.bottom > bcr.bottom
									) {
										overflows = true;
										return false;
									}
								}
							}
							
							// no need to go further if fixed, for the same reason as above
							if ($el.css('position') == 'fixed') {
								return false;
							}
						});
					}
					
					if (overflows) {
						self._$tooltip.css('visibility', 'hidden');
					}
					else {
						self._$tooltip.css('visibility', 'visible');
						
						// reposition
						if (self.__options.repositionOnScroll) {
							self.reposition(event);
						}
						// or just adjust offset
						else {
							
							// we have to use offset and not windowOffset because this way,
							// only the scroll distance of the scrollable areas are taken into
							// account (the scrolltop value of the main window must be
							// ignored since the tooltip already moves with it)
							var offsetLeft = g.origin.offset.left - self.__Geometry.origin.offset.left,
								offsetTop = g.origin.offset.top - self.__Geometry.origin.offset.top;
							
							// add the offset to the position initially computed by the display plugin
							self._$tooltip.css({
								left: self.__lastPosition.coord.left + offsetLeft,
								top: self.__lastPosition.coord.top + offsetTop
							});
						}
					}
				}
				
				self._trigger({
					type: 'scroll',
					event: event
				});
			}
			
			return self;
		},
		
		/**
		 * Changes the state of the tooltip
		 *
		 * @param {string} state
		 * @returns {self}
		 * @private
		 */
		__stateSet: function(state) {
			
			this.__state = state;
			
			this._trigger({
				type: 'state',
				state: state
			});
			
			return this;
		},
		
		/**
		 * Clear appearance timeouts
		 *
		 * @returns {self}
		 * @private
		 */
		__timeoutsClear: function() {
			
			// there is only one possible open timeout: the delayed opening
			// when the mouseenter/touchstart open triggers are used
			clearTimeout(this.__timeouts.open);
			this.__timeouts.open = null;
			
			// ... but several close timeouts: the delayed closing when the
			// mouseleave close trigger is used and the timer option
			$.each(this.__timeouts.close, function(i, timeout) {
				clearTimeout(timeout);
			});
			this.__timeouts.close = [];
			
			return this;
		},
		
		/**
		 * Start the tracker that will make checks at regular intervals
		 * 
		 * @returns {self}
		 * @private
		 */
		__trackerStart: function() {
			
			var self = this,
				$content = self._$tooltip.find('.tooltipster-content');
			
			// get the initial content size
			if (self.__options.trackTooltip) {
				self.__contentBcr = $content[0].getBoundingClientRect();
			}
			
			self.__tracker = setInterval(function() {
				
				// if the origin or tooltip elements have been removed.
				// Note: we could destroy the instance now if the origin has
				// been removed but we'll leave that task to our garbage collector
				if (!bodyContains(self._$origin) || !bodyContains(self._$tooltip)) {
					self._close();
				}
				// if everything is alright
				else {
					
					// compare the former and current positions of the origin to reposition
					// the tooltip if need be
					if (self.__options.trackOrigin) {
						
						var g = self.__geometry(),
							identical = false;
						
						// compare size first (a change requires repositioning too)
						if (areEqual(g.origin.size, self.__Geometry.origin.size)) {
							
							// for elements that have a fixed lineage (see __geometry()), we track the
							// top and left properties (relative to window)
							if (self.__Geometry.origin.fixedLineage) {
								if (areEqual(g.origin.windowOffset, self.__Geometry.origin.windowOffset)) {
									identical = true;
								}
							}
							// otherwise, track total offset (relative to document)
							else {
								if (areEqual(g.origin.offset, self.__Geometry.origin.offset)) {
									identical = true;
								}
							}
						}
						
						if (!identical) {
							
							// close the tooltip when using the mouseleave close trigger
							// (see https://github.com/iamceege/tooltipster/pull/253)
							if (self.__options.triggerClose.mouseleave) {
								self._close();
							}
							else {
								self.reposition();
							}
						}
					}
					
					if (self.__options.trackTooltip) {
						
						var currentBcr = $content[0].getBoundingClientRect();
						
						if (	currentBcr.height !== self.__contentBcr.height
							||	currentBcr.width !== self.__contentBcr.width
						) {
							self.reposition();
							self.__contentBcr = currentBcr;
						}
					}
				}
			}, self.__options.trackerInterval);
			
			return self;
		},
		
		/**
		 * Closes the tooltip (after the closing delay)
		 * 
		 * @param event
		 * @param callback
		 * @returns {self}
		 * @protected
		 */
		_close: function(event, callback) {
			
			var self = this,
				ok = true;
			
			self._trigger({
				type: 'close',
				event: event,
				stop: function() {
					ok = false;
				}
			});
			
			// a destroying tooltip may not refuse to close
			if (ok || self.__destroying) {
				
				// save the method custom callback and cancel any open method custom callbacks
				if (callback) self.__callbacks.close.push(callback);
				self.__callbacks.open = [];
				
				// clear open/close timeouts
				self.__timeoutsClear();
				
				var finishCallbacks = function() {
					
					// trigger any close method custom callbacks and reset them
					$.each(self.__callbacks.close, function(i,c) {
						c.call(self, self, {
							event: event,
							origin: self._$origin[0]
						});
					});
					
					self.__callbacks.close = [];
				};
				
				if (self.__state != 'closed') {
					
					var necessary = true,
						d = new Date(),
						now = d.getTime(),
						newClosingTime = now + self.__options.animationDuration[1];
					
					// the tooltip may already already be disappearing, but if a new
					// call to close() is made after the animationDuration was changed
					// to 0 (for example), we ought to actually close it sooner than
					// previously scheduled. In that case it should be noted that the
					// browser will not adapt the animation duration to the new
					// animationDuration that was set after the start of the closing
					// animation.
					// Note: the same thing could be considered at opening, but is not
					// really useful since the tooltip is actually opened immediately
					// upon a call to _open(). Since it would not make the opening
					// animation finish sooner, its sole impact would be to trigger the
					// state event and the open callbacks sooner than the actual end of
					// the opening animation, which is not great.
					if (self.__state == 'disappearing') {
						
						if (newClosingTime > self.__closingTime) {
							necessary = false;
						}
					}
					
					if (necessary) {
						
						self.__closingTime = newClosingTime;
						
						if (self.__state != 'disappearing') {
							self.__stateSet('disappearing');
						}
						
						var finish = function() {
							
							// stop the tracker
							clearInterval(self.__tracker);
							
							// a "beforeClose" option has been asked several times but would
							// probably useless since the content element is still accessible
							// via ::content(), and because people can always use listeners
							// inside their content to track what's going on. For the sake of
							// simplicity, this has been denied. Bur for the rare people who
							// really need the option (for old browsers or for the case where
							// detaching the content is actually destructive, for file or
							// password inputs for example), this event will do the app.
							self._trigger({
								type: 'closing',
								event: event
							});
							
							// unbind listeners which are no longer needed
							
							self._$tooltip
								.off('.'+ self.__namespace +'-triggerClose')
								.removeClass('tooltipster-dying');
							
							// orientationchange, scroll and resize listeners
							$(env.window).off('.'+ self.__namespace +'-triggerClose');
							
							// scroll listeners
							self.__$originParents.each(function(i, el) {
								$(el).off('scroll.'+ self.__namespace +'-triggerClose');
							});
							// clear the array to prevent memory leaks
							self.__$originParents = null;
							
							$('body').off('.'+ self.__namespace +'-triggerClose');
							
							self._$origin.off('.'+ self.__namespace +'-triggerClose');
							
							self._off('dismissable');
							
							// a plugin that would like to remove the tooltip from the
							// DOM when closed should bind on this
							self.__stateSet('closed');
							
							// trigger event
							self._trigger({
								type: 'after',
								event: event
							});
							
							// call our constructor custom callback function
							if (self.__options.functionAfter) {
								self.__options.functionAfter.call(self, self, {
									event: event,
									origin: self._$origin[0]
								});
							}
							
							// call our method custom callbacks functions
							finishCallbacks();
						};
						
						if (env.hasTransitions) {
							
							self._$tooltip.css({
								'-moz-animation-duration': self.__options.animationDuration[1] + 'ms',
								'-ms-animation-duration': self.__options.animationDuration[1] + 'ms',
								'-o-animation-duration': self.__options.animationDuration[1] + 'ms',
								'-webkit-animation-duration': self.__options.animationDuration[1] + 'ms',
								'animation-duration': self.__options.animationDuration[1] + 'ms',
								'transition-duration': self.__options.animationDuration[1] + 'ms'
							});
							
							self._$tooltip
								// clear both potential open and close tasks
								.clearQueue()
								.removeClass('tooltipster-show')
								// for transitions only
								.addClass('tooltipster-dying');
							
							if (self.__options.animationDuration[1] > 0) {
								self._$tooltip.delay(self.__options.animationDuration[1]);
							}
							
							self._$tooltip.queue(finish);
						}
						else {
							
							self._$tooltip
								.stop()
								.fadeOut(self.__options.animationDuration[1], finish);
						}
					}
				}
				// if the tooltip is already closed, we still need to trigger
				// the method custom callbacks
				else {
					finishCallbacks();
				}
			}
			
			return self;
		},
		
		/**
		 * For internal use by plugins, if needed
		 * 
		 * @returns {self}
		 * @protected
		 */
		_off: function() {
			this.__$emitterPrivate.off.apply(this.__$emitterPrivate, Array.prototype.slice.apply(arguments));
			return this;
		},
		
		/**
		 * For internal use by plugins, if needed
		 *
		 * @returns {self}
		 * @protected
		 */
		_on: function() {
			this.__$emitterPrivate.on.apply(this.__$emitterPrivate, Array.prototype.slice.apply(arguments));
			return this;
		},
		
		/**
		 * For internal use by plugins, if needed
		 *
		 * @returns {self}
		 * @protected
		 */
		_one: function() {
			this.__$emitterPrivate.one.apply(this.__$emitterPrivate, Array.prototype.slice.apply(arguments));
			return this;
		},
		
		/**
		 * Opens the tooltip right away
		 *
		 * @param event
		 * @param callback
		 * @returns {self}
		 * @protected
		 */
		_open: function(event, callback) {
			
			var self = this;
			
			// if the destruction process has not begun and if this was not
			// triggered by an unwanted emulated click event
			if (!self.__destroying) {
				
				// check that the origin is still in the DOM
				if (	bodyContains(self._$origin)
					// if the tooltip is enabled
					&&	self.__enabled
				) {
					
					var ok = true;
					
					// if the tooltip is not open yet, we need to call functionBefore.
					// otherwise we can jst go on
					if (self.__state == 'closed') {
						
						// trigger an event. The event.stop function allows the callback
						// to prevent the opening of the tooltip
						self._trigger({
							type: 'before',
							event: event,
							stop: function() {
								ok = false;
							}
						});
						
						if (ok && self.__options.functionBefore) {
							
							// call our custom function before continuing
							ok = self.__options.functionBefore.call(self, self, {
								event: event,
								origin: self._$origin[0]
							});
						}
					}
					
					if (ok !== false) {
						
						// if there is some content
						if (self.__Content !== null) {
							
							// save the method callback and cancel close method callbacks
							if (callback) {
								self.__callbacks.open.push(callback);
							}
							self.__callbacks.close = [];
							
							// get rid of any appearance timeouts
							self.__timeoutsClear();
							
							var extraTime,
								finish = function() {
									
									if (self.__state != 'stable') {
										self.__stateSet('stable');
									}
									
									// trigger any open method custom callbacks and reset them
									$.each(self.__callbacks.open, function(i,c) {
										c.call(self, self, {
											origin: self._$origin[0],
											tooltip: self._$tooltip[0]
										});
									});
									
									self.__callbacks.open = [];
								};
							
							// if the tooltip is already open
							if (self.__state !== 'closed') {
								
								// the timer (if any) will start (or restart) right now
								extraTime = 0;
								
								// if it was disappearing, cancel that
								if (self.__state === 'disappearing') {
									
									self.__stateSet('appearing');
									
									if (env.hasTransitions) {
										
										self._$tooltip
											.clearQueue()
											.removeClass('tooltipster-dying')
											.addClass('tooltipster-show');
										
										if (self.__options.animationDuration[0] > 0) {
											self._$tooltip.delay(self.__options.animationDuration[0]);
										}
										
										self._$tooltip.queue(finish);
									}
									else {
										// in case the tooltip was currently fading out, bring it back
										// to life
										self._$tooltip
											.stop()
											.fadeIn(finish);
									}
								}
								// if the tooltip is already open, we still need to trigger the method
								// custom callback
								else if (self.__state == 'stable') {
									finish();
								}
							}
							// if the tooltip isn't already open, open it
							else {
								
								// a plugin must bind on this and store the tooltip in this._$tooltip
								self.__stateSet('appearing');
								
								// the timer (if any) will start when the tooltip has fully appeared
								// after its transition
								extraTime = self.__options.animationDuration[0];
								
								// insert the content inside the tooltip
								self.__contentInsert();
								
								// reposition the tooltip and attach to the DOM
								self.reposition(event, true);
								
								// animate in the tooltip. If the display plugin wants no css
								// animations, it may override the animation option with a
								// dummy value that will produce no effect
								if (env.hasTransitions) {
									
									// note: there seems to be an issue with start animations which
									// are randomly not played on fast devices in both Chrome and FF,
									// couldn't find a way to solve it yet. It seems that applying
									// the classes before appending to the DOM helps a little, but
									// it messes up some CSS transitions. The issue almost never
									// happens when delay[0]==0 though
									self._$tooltip
										.addClass('tooltipster-'+ self.__options.animation)
										.addClass('tooltipster-initial')
										.css({
											'-moz-animation-duration': self.__options.animationDuration[0] + 'ms',
											'-ms-animation-duration': self.__options.animationDuration[0] + 'ms',
											'-o-animation-duration': self.__options.animationDuration[0] + 'ms',
											'-webkit-animation-duration': self.__options.animationDuration[0] + 'ms',
											'animation-duration': self.__options.animationDuration[0] + 'ms',
											'transition-duration': self.__options.animationDuration[0] + 'ms'
										});
									
									setTimeout(
										function() {
											
											// a quick hover may have already triggered a mouseleave
											if (self.__state != 'closed') {
												
												self._$tooltip
													.addClass('tooltipster-show')
													.removeClass('tooltipster-initial');
												
												if (self.__options.animationDuration[0] > 0) {
													self._$tooltip.delay(self.__options.animationDuration[0]);
												}
												
												self._$tooltip.queue(finish);
											}
										},
										0
									);
								}
								else {
									
									// old browsers will have to live with this
									self._$tooltip
										.css('display', 'none')
										.fadeIn(self.__options.animationDuration[0], finish);
								}
								
								// checks if the origin is removed while the tooltip is open
								self.__trackerStart();
								
								// NOTE: the listeners below have a '-triggerClose' namespace
								// because we'll remove them when the tooltip closes (unlike
								// the '-triggerOpen' listeners). So some of them are actually
								// not about close triggers, rather about positioning.
								
								$(env.window)
									// reposition on resize
									.on('resize.'+ self.__namespace +'-triggerClose', function(e) {
										self.reposition(e);
									})
									// same as below for parents
									.on('scroll.'+ self.__namespace +'-triggerClose', function(e) {
										self.__scrollHandler(e);
									});
								
								self.__$originParents = self._$origin.parents();
								
								// scrolling may require the tooltip to be moved or even
								// repositioned in some cases
								self.__$originParents.each(function(i, parent) {
									
									$(parent).on('scroll.'+ self.__namespace +'-triggerClose', function(e) {
										self.__scrollHandler(e);
									});
								});
								
								if (	self.__options.triggerClose.mouseleave
									||	(self.__options.triggerClose.touchleave && env.hasTouchCapability)
								) {
									
									// we use an event to allow users/plugins to control when the mouseleave/touchleave
									// close triggers will come to action. It allows to have more triggering elements
									// than just the origin and the tooltip for example, or to cancel/delay the closing,
									// or to make the tooltip interactive even if it wasn't when it was open, etc.
									self._on('dismissable', function(event) {
										
										if (event.dismissable) {
											
											if (event.delay) {
												
												timeout = setTimeout(function() {
													// event.event may be undefined
													self._close(event.event);
												}, event.delay);
												
												self.__timeouts.close.push(timeout);
											}
											else {
												self._close(event);
											}
										}
										else {
											clearTimeout(timeout);
										}
									});
									
									// now set the listeners that will trigger 'dismissable' events
									var $elements = self._$origin,
										eventNamesIn = '',
										eventNamesOut = '',
										timeout = null;
									
									// if we have to allow interaction, bind on the tooltip too
									if (self.__options.interactive) {
										$elements = $elements.add(self._$tooltip);
									}
									
									if (self.__options.triggerClose.mouseleave) {
										eventNamesIn += 'mouseenter.'+ self.__namespace +'-triggerClose ';
										eventNamesOut += 'mouseleave.'+ self.__namespace +'-triggerClose ';
									}
									if (self.__options.triggerClose.touchleave && env.hasTouchCapability) {
										eventNamesIn += 'touchstart.'+ self.__namespace +'-triggerClose';
										eventNamesOut += 'touchend.'+ self.__namespace +'-triggerClose touchcancel.'+ self.__namespace +'-triggerClose';
									}
									
									$elements
										// close after some time spent outside of the elements
										.on(eventNamesOut, function(event) {
											
											// it's ok if the touch gesture ended up to be a swipe,
											// it's still a "touch leave" situation
											if (	self._touchIsTouchEvent(event)
												||	!self._touchIsEmulatedEvent(event)
											) {
												
												var delay = (event.type == 'mouseleave') ?
													self.__options.delay :
													self.__options.delayTouch;
												
												self._trigger({
													delay: delay[1],
													dismissable: true,
													event: event,
													type: 'dismissable'
												});
											}
										})
										// suspend the mouseleave timeout when the pointer comes back
										// over the elements
										.on(eventNamesIn, function(event) {
											
											// it's also ok if the touch event is a swipe gesture
											if (	self._touchIsTouchEvent(event)
												||	!self._touchIsEmulatedEvent(event)
											) {
												self._trigger({
													dismissable: false,
													event: event,
													type: 'dismissable'
												});
											}
										});
								}
								
								// close the tooltip when the origin gets a mouse click (common behavior of
								// native tooltips)
								if (self.__options.triggerClose.originClick) {
									
									self._$origin.on('click.'+ self.__namespace + '-triggerClose', function(event) {
										
										// we could actually let a tap trigger this but this feature just
										// does not make sense on touch devices
										if (	!self._touchIsTouchEvent(event)
											&&	!self._touchIsEmulatedEvent(event)
										) {
											self._close(event);
										}
									});
								}
								
								// set the same bindings for click and touch on the body to close the tooltip
								if (	self.__options.triggerClose.click
									||	(self.__options.triggerClose.tap && env.hasTouchCapability)
								) {
									
									// don't set right away since the click/tap event which triggered this method
									// (if it was a click/tap) is going to bubble up to the body, we don't want it
									// to close the tooltip immediately after it opened
									setTimeout(function() {
										
										if (self.__state != 'closed') {
											
											var eventNames = '';
											if (self.__options.triggerClose.click) {
												eventNames += 'click.'+ self.__namespace +'-triggerClose ';
											}
											if (self.__options.triggerClose.tap && env.hasTouchCapability) {
												eventNames += 'touchend.'+ self.__namespace +'-triggerClose';
											}
											
											$('body').on(eventNames, function(event) {
												
												if (self._touchIsMeaningfulEvent(event)) {
													
													self._touchRecordEvent(event);
													
													if (!self.__options.interactive || !$.contains(self._$tooltip[0], event.target)) {
														self._close(event);
													}
												}
											});
											
											// needed to detect and ignore swiping
											if (self.__options.triggerClose.tap && env.hasTouchCapability) {
												
												$('body').on('touchstart.'+ self.__namespace +'-triggerClose', function(event) {
													self._touchRecordEvent(event);
												});
											}
										}
									}, 0);
								}
								
								self._trigger('ready');
								
								// call our custom callback
								if (self.__options.functionReady) {
									self.__options.functionReady.call(self, self, {
										origin: self._$origin[0],
										tooltip: self._$tooltip[0]
									});
								}
							}
							
							// if we have a timer set, let the countdown begin
							if (self.__options.timer > 0) {
								
								var timeout = setTimeout(function() {
									self._close();
								}, self.__options.timer + extraTime);
								
								self.__timeouts.close.push(timeout);
							}
						}
					}
				}
			}
			
			return self;
		},
		
		/**
		 * When using the mouseenter/touchstart open triggers, this function will
		 * schedule the opening of the tooltip after the delay, if there is one
		 *
		 * @param event
		 * @returns {self}
		 * @protected
	 	 */
		_openShortly: function(event) {
			
			var self = this,
				ok = true;
			
			if (self.__state != 'stable' && self.__state != 'appearing') {
				
				// if a timeout is not already running
				if (!self.__timeouts.open) {
					
					self._trigger({
						type: 'start',
						event: event,
						stop: function() {
							ok = false;
						}
					});
					
					if (ok) {
						
						var delay = (event.type.indexOf('touch') == 0) ?
							self.__options.delayTouch :
							self.__options.delay;
						
						if (delay[0]) {
							
							self.__timeouts.open = setTimeout(function() {
								
								self.__timeouts.open = null;
								
								// open only if the pointer (mouse or touch) is still over the origin.
								// The check on the "meaningful event" can only be made here, after some
								// time has passed (to know if the touch was a swipe or not)
								if (self.__pointerIsOverOrigin && self._touchIsMeaningfulEvent(event)) {
									
									// signal that we go on
									self._trigger('startend');
									
									self._open(event);
								}
								else {
									// signal that we cancel
									self._trigger('startcancel');
								}
							}, delay[0]);
						}
						else {
							// signal that we go on
							self._trigger('startend');
							
							self._open(event);
						}
					}
				}
			}
			
			return self;
		},
		
		/**
		 * Meant for plugins to get their options
		 * 
		 * @param {string} pluginName The name of the plugin that asks for its options
		 * @param {object} defaultOptions The default options of the plugin
		 * @returns {object} The options
		 * @protected
		 */
		_optionsExtract: function(pluginName, defaultOptions) {
			
			var self = this,
				options = $.extend(true, {}, defaultOptions);
			
			// if the plugin options were isolated in a property named after the
			// plugin, use them (prevents conflicts with other plugins)
			var pluginOptions = self.__options[pluginName];
			
			// if not, try to get them as regular options
			if (!pluginOptions){
				
				pluginOptions = {};
				
				$.each(defaultOptions, function(optionName, value) {
					
					var o = self.__options[optionName];
					
					if (o !== undefined) {
						pluginOptions[optionName] = o;
					}
				});
			}
			
			// let's merge the default options and the ones that were provided. We'd want
			// to do a deep copy but not let jQuery merge arrays, so we'll do a shallow
			// extend on two levels, that will be enough if options are not more than 1
			// level deep
			$.each(options, function(optionName, value) {
				
				if (pluginOptions[optionName] !== undefined) {
					
					if ((		typeof value == 'object'
							&&	!(value instanceof Array)
							&&	value != null
						)
						&&
						(		typeof pluginOptions[optionName] == 'object'
							&&	!(pluginOptions[optionName] instanceof Array)
							&&	pluginOptions[optionName] != null
						)
					) {
						$.extend(options[optionName], pluginOptions[optionName]);
					}
					else {
						options[optionName] = pluginOptions[optionName];
					}
				}
			});
			
			return options;
		},
		
		/**
		 * Used at instantiation of the plugin, or afterwards by plugins that activate themselves
		 * on existing instances
		 * 
		 * @param {object} pluginName
		 * @returns {self}
		 * @protected
		 */
		_plug: function(pluginName) {
			
			var plugin = $.tooltipster._plugin(pluginName);
			
			if (plugin) {
				
				// if there is a constructor for instances
				if (plugin.instance) {
					
					// proxy non-private methods on the instance to allow new instance methods
					$.tooltipster.__bridge(plugin.instance, this, plugin.name);
				}
			}
			else {
				throw new Error('The "'+ pluginName +'" plugin is not defined');
			}
			
			return this;
		},
		
		/**
		 * This will return true if the event is a mouse event which was
		 * emulated by the browser after a touch event. This allows us to
		 * really dissociate mouse and touch triggers.
		 * 
		 * There is a margin of error if a real mouse event is fired right
		 * after (within the delay shown below) a touch event on the same
		 * element, but hopefully it should not happen often.
		 * 
		 * @returns {boolean}
		 * @protected
		 */
		_touchIsEmulatedEvent: function(event) {
			
			var isEmulated = false,
				now = new Date().getTime();
			
			for (var i = this.__touchEvents.length - 1; i >= 0; i--) {
				
				var e = this.__touchEvents[i];
				
				// delay, in milliseconds. It's supposed to be 300ms in
				// most browsers (350ms on iOS) to allow a double tap but
				// can be less (check out FastClick for more info)
				if (now - e.time < 500) {
					
					if (e.target === event.target) {
						isEmulated = true;
					}
				}
				else {
					break;
				}
			}
			
			return isEmulated;
		},
		
		/**
		 * Returns false if the event was an emulated mouse event or
		 * a touch event involved in a swipe gesture.
		 * 
		 * @param {object} event
		 * @returns {boolean}
		 * @protected
		 */
		_touchIsMeaningfulEvent: function(event) {
			return (
					(this._touchIsTouchEvent(event) && !this._touchSwiped(event.target))
				||	(!this._touchIsTouchEvent(event) && !this._touchIsEmulatedEvent(event))
			);
		},
		
		/**
		 * Checks if an event is a touch event
		 * 
		 * @param {object} event
		 * @returns {boolean}
		 * @protected
		 */
		_touchIsTouchEvent: function(event){
			return event.type.indexOf('touch') == 0;
		},
		
		/**
		 * Store touch events for a while to detect swiping and emulated mouse events
		 * 
		 * @param {object} event
		 * @returns {self}
		 * @protected
		 */
		_touchRecordEvent: function(event) {
			
			if (this._touchIsTouchEvent(event)) {
				event.time = new Date().getTime();
				this.__touchEvents.push(event);
			}
			
			return this;
		},
		
		/**
		 * Returns true if a swipe happened after the last touchstart event fired on
		 * event.target.
		 * 
		 * We need to differentiate a swipe from a tap before we let the event open
		 * or close the tooltip. A swipe is when a touchmove (scroll) event happens
		 * on the body between the touchstart and the touchend events of an element.
		 * 
		 * @param {object} target The HTML element that may have triggered the swipe
		 * @returns {boolean}
		 * @protected
		 */
		_touchSwiped: function(target) {
			
			var swiped = false;
			
			for (var i = this.__touchEvents.length - 1; i >= 0; i--) {
				
				var e = this.__touchEvents[i];
				
				if (e.type == 'touchmove') {
					swiped = true;
					break;
				}
				else if (
					e.type == 'touchstart'
					&&	target === e.target
				) {
					break;
				}
			}
			
			return swiped;
		},
		
		/**
		 * Triggers an event on the instance emitters
		 * 
		 * @returns {self}
		 * @protected
		 */
		_trigger: function() {
			
			var args = Array.prototype.slice.apply(arguments);
			
			if (typeof args[0] == 'string') {
				args[0] = { type: args[0] };
			}
			
			// add properties to the event
			args[0].instance = this;
			args[0].origin = this._$origin ? this._$origin[0] : null;
			args[0].tooltip = this._$tooltip ? this._$tooltip[0] : null;
			
			// note: the order of emitters matters
			this.__$emitterPrivate.trigger.apply(this.__$emitterPrivate, args);
			$.tooltipster._trigger.apply($.tooltipster, args);
			this.__$emitterPublic.trigger.apply(this.__$emitterPublic, args);
			
			return this;
		},
		
		/**
		 * Deactivate a plugin on this instance
		 * 
		 * @returns {self}
		 * @protected
		 */
		_unplug: function(pluginName) {
			
			var self = this;
			
			// if the plugin has been activated on this instance
			if (self[pluginName]) {
				
				var plugin = $.tooltipster._plugin(pluginName);
				
				// if there is a constructor for instances
				if (plugin.instance) {
					
					// unbridge
					$.each(plugin.instance, function(methodName, fn) {
						
						// if the method exists (privates methods do not) and comes indeed from
						// this plugin (may be missing or come from a conflicting plugin).
						if (	self[methodName]
							&&	self[methodName].bridged === self[pluginName]
						) {
							delete self[methodName];
						}
					});
				}
				
				// destroy the plugin
				if (self[pluginName].__destroy) {
					self[pluginName].__destroy();
				}
				
				// remove the reference to the plugin instance
				delete self[pluginName];
			}
			
			return self;
		},
		
		/**
		 * @see self::_close
		 * @returns {self}
		 * @public
		 */
		close: function(callback) {
			
			if (!this.__destroyed) {
				this._close(null, callback);
			}
			else {
				this.__destroyError();
			}
			
			return this;
		},
		
		/**
		 * Sets or gets the content of the tooltip
		 * 
		 * @returns {mixed|self}
		 * @public
		 */
		content: function(content) {
			
			var self = this;
			
			// getter method
			if (content === undefined) {
				return self.__Content;
			}
			// setter method
			else {
				
				if (!self.__destroyed) {
					
					// change the content
					self.__contentSet(content);
					
					if (self.__Content !== null) {
						
						// update the tooltip if it is open
						if (self.__state !== 'closed') {
							
							// reset the content in the tooltip
							self.__contentInsert();
							
							// reposition and resize the tooltip
							self.reposition();
							
							// if we want to play a little animation showing the content changed
							if (self.__options.updateAnimation) {
								
								if (env.hasTransitions) {
									
									// keep the reference in the local scope
									var animation = self.__options.updateAnimation;
									
									self._$tooltip.addClass('tooltipster-update-'+ animation);
									
									// remove the class after a while. The actual duration of the
									// update animation may be shorter, it's set in the CSS rules
									setTimeout(function() {
										
										if (self.__state != 'closed') {
											
											self._$tooltip.removeClass('tooltipster-update-'+ animation);
										}
									}, 1000);
								}
								else {
									self._$tooltip.fadeTo(200, 0.5, function() {
										if (self.__state != 'closed') {
											self._$tooltip.fadeTo(200, 1);
										}
									});
								}
							}
						}
					}
					else {
						self._close();
					}
				}
				else {
					self.__destroyError();
				}
				
				return self;
			}
		},
		
		/**
		 * Destroys the tooltip
		 * 
		 * @returns {self}
		 * @public
		 */
		destroy: function() {
			
			var self = this;
			
			if (!self.__destroyed) {
				
				if (!self.__destroying) {
					
					self.__destroying = true;
					
					self._close(null, function() {
						
						self._trigger('destroy');
						
						self.__destroying = false;
						self.__destroyed = true;
						
						self._$origin
							.removeData(self.__namespace)
							// remove the open trigger listeners
							.off('.'+ self.__namespace +'-triggerOpen');
						
						// remove the touch listener
						$('body').off('.' + self.__namespace +'-triggerOpen');
						
						var ns = self._$origin.data('tooltipster-ns');
						
						// if the origin has been removed from DOM, its data may
						// well have been destroyed in the process and there would
						// be nothing to clean up or restore
						if (ns) {
							
							// if there are no more tooltips on this element
							if (ns.length === 1) {
								
								// optional restoration of a title attribute
								var title = null;
								if (self.__options.restoration == 'previous') {
									title = self._$origin.data('tooltipster-initialTitle');
								}
								else if (self.__options.restoration == 'current') {
									
									// old school technique to stringify when outerHTML is not supported
									title = (typeof self.__Content == 'string') ?
										self.__Content :
										$('<div></div>').append(self.__Content).html();
								}
								
								if (title) {
									self._$origin.attr('title', title);
								}
								
								// final cleaning
								
								self._$origin.removeClass('tooltipstered');
								
								self._$origin
									.removeData('tooltipster-ns')
									.removeData('tooltipster-initialTitle');
							}
							else {
								// remove the instance namespace from the list of namespaces of
								// tooltips present on the element
								ns = $.grep(ns, function(el, i) {
									return el !== self.__namespace;
								});
								self._$origin.data('tooltipster-ns', ns);
							}
						}
						
						// last event
						self._trigger('destroyed');
						
						// unbind private and public event listeners
						self._off();
						self.off();
						
						// remove external references, just in case
						self.__Content = null;
						self.__$emitterPrivate = null;
						self.__$emitterPublic = null;
						self.__options.parent = null;
						self._$origin = null;
						self._$tooltip = null;
						
						// make sure the object is no longer referenced in there to prevent
						// memory leaks
						$.tooltipster.__instancesLatestArr = $.grep($.tooltipster.__instancesLatestArr, function(el, i) {
							return self !== el;
						});
						
						clearInterval(self.__garbageCollector);
					});
				}
			}
			else {
				self.__destroyError();
			}
			
			// we return the scope rather than true so that the call to
			// .tooltipster('destroy') actually returns the matched elements
			// and applies to all of them
			return self;
		},
		
		/**
		 * Disables the tooltip
		 * 
		 * @returns {self}
		 * @public
		 */
		disable: function() {
			
			if (!this.__destroyed) {
				
				// close first, in case the tooltip would not disappear on
				// its own (no close trigger)
				this._close();
				this.__enabled = false;
				
				return this;
			}
			else {
				this.__destroyError();
			}
			
			return this;
		},
		
		/**
		 * Returns the HTML element of the origin
		 *
		 * @returns {self}
		 * @public
		 */
		elementOrigin: function() {
			
			if (!this.__destroyed) {
				return this._$origin[0];
			}
			else {
				this.__destroyError();
			}
		},
		
		/**
		 * Returns the HTML element of the tooltip
		 *
		 * @returns {self}
		 * @public
		 */
		elementTooltip: function() {
			return this._$tooltip ? this._$tooltip[0] : null;
		},
		
		/**
		 * Enables the tooltip
		 * 
		 * @returns {self}
		 * @public
		 */
		enable: function() {
			this.__enabled = true;
			return this;
		},
		
		/**
		 * Alias, deprecated in 4.0.0
		 * 
		 * @param {function} callback
		 * @returns {self}
		 * @public
		 */
		hide: function(callback) {
			return this.close(callback);
		},
		
		/**
		 * Returns the instance
		 * 
		 * @returns {self}
		 * @public
		 */
		instance: function() {
			return this;
		},
		
		/**
		 * For public use only, not to be used by plugins (use ::_off() instead)
		 * 
		 * @returns {self}
		 * @public
		 */
		off: function() {
			
			if (!this.__destroyed) {
				this.__$emitterPublic.off.apply(this.__$emitterPublic, Array.prototype.slice.apply(arguments));
			}
			
			return this;
		},
		
		/**
		 * For public use only, not to be used by plugins (use ::_on() instead)
		 *
		 * @returns {self}
		 * @public
		 */
		on: function() {
			
			if (!this.__destroyed) {
				this.__$emitterPublic.on.apply(this.__$emitterPublic, Array.prototype.slice.apply(arguments));
			}
			else {
				this.__destroyError();
			}
			
			return this;
		},
		
		/**
		 * For public use only, not to be used by plugins
		 *
		 * @returns {self}
		 * @public
		 */
		one: function() {
			
			if (!this.__destroyed) {
				this.__$emitterPublic.one.apply(this.__$emitterPublic, Array.prototype.slice.apply(arguments));
			}
			else {
				this.__destroyError();
			}
			
			return this;
		},
		
		/**
		 * @see self::_open
		 * @returns {self}
		 * @public
		 */
		open: function(callback) {
			
			if (!this.__destroyed && !this.__destroying) {
				this._open(null, callback);
			}
			else {
				this.__destroyError();
			}
			
			return this;
		},
		
		/**
		 * Get or set options. For internal use and advanced users only.
		 * 
		 * @param {string} o Option name
		 * @param {mixed} val optional A new value for the option
		 * @return {mixed|self} If val is omitted, the value of the option
		 * is returned, otherwise the instance itself is returned
		 * @public
		 */ 
		option: function(o, val) {
			
			// getter
			if (val === undefined) {
				return this.__options[o];
			}
			// setter
			else {
				
				if (!this.__destroyed) {
					
					// change value
					this.__options[o] = val;
					
					// format
					this.__optionsFormat();
					
					// re-prepare the triggers if needed
					if ($.inArray(o, ['trigger', 'triggerClose', 'triggerOpen']) >= 0) {
						this.__prepareOrigin();
					}
					
					if (o === 'selfDestruction') {
						this.__prepareGC();
					}
				}
				else {
					this.__destroyError();
				}
				
				return this;
			}
		},
		
		/**
		 * This method is in charge of setting the position and size properties of the tooltip.
		 * All the hard app is delegated to the display plugin.
		 * Note: The tooltip may be detached from the DOM at the moment the method is called 
		 * but must be attached by the end of the method call.
		 * 
		 * @param {object} event For internal use only. Defined if an event such as
		 * window resizing triggered the repositioning
		 * @param {boolean} tooltipIsDetached For internal use only. Set this to true if you
		 * know that the tooltip not being in the DOM is not an issue (typically when the
		 * tooltip element has just been created but has not been added to the DOM yet).
		 * @returns {self}
		 * @public
		 */
		reposition: function(event, tooltipIsDetached) {
			
			var self = this;
			
			if (!self.__destroyed) {
				
				// if the tooltip has not been removed from DOM manually (or if it
				// has been detached on purpose)
				if (bodyContains(self._$tooltip) || tooltipIsDetached) {
					
					if (!tooltipIsDetached) {
						// detach in case the tooltip overflows the window and adds
						// scrollbars to it, so __geometry can be accurate
						self._$tooltip.detach();
					}
					
					// refresh the geometry object before passing it as a helper
					self.__Geometry = self.__geometry();
					
					// let a plugin fo the rest
					self._trigger({
						type: 'reposition',
						event: event,
						helper: {
							geo: self.__Geometry
						}
					});
				}
			}
			else {
				self.__destroyError();
			}
			
			return self;
		},
		
		/**
		 * Alias, deprecated in 4.0.0
		 *
		 * @param callback
		 * @returns {self}
		 * @public
		 */
		show: function(callback) {
			return this.open(callback);
		},
		
		/**
		 * Returns some properties about the instance
		 * 
		 * @returns {object}
		 * @public
		 */
		status: function() {
			
			return {
				destroyed: this.__destroyed,
				destroying: this.__destroying,
				enabled: this.__enabled,
				open: this.__state !== 'closed',
				state: this.__state
			};
		},
		
		/**
		 * For public use only, not to be used by plugins
		 *
		 * @returns {self}
		 * @public
		 */
		triggerHandler: function() {
			
			if (!this.__destroyed) {
				this.__$emitterPublic.triggerHandler.apply(this.__$emitterPublic, Array.prototype.slice.apply(arguments));
			}
			else {
				this.__destroyError();
			}
			
			return this;
		}
	};
	
	$.fn.tooltipster = function() {
		
		// for using in closures
		var args = Array.prototype.slice.apply(arguments),
			// common mistake: an HTML element can't be in several tooltips at the same time
			contentCloningWarning = 'You are using a single HTML element as content for several tooltips. You probably want to set the contentCloning option to TRUE.';
		
		// this happens with $(sel).tooltipster(...) when $(sel) does not match anything
		if (this.length === 0) {
			
			// still chainable
			return this;
		}
		// this happens when calling $(sel).tooltipster('methodName or options')
		// where $(sel) matches one or more elements
		else {
			
			// method calls
			if (typeof args[0] === 'string') {
				
				var v = '#*$~&';
				
				this.each(function() {
					
					// retrieve the namepaces of the tooltip(s) that exist on that element.
					// We will interact with the first tooltip only.
					var ns = $(this).data('tooltipster-ns'),
						// self represents the instance of the first tooltipster plugin
						// associated to the current HTML object of the loop
						self = ns ? $(this).data(ns[0]) : null;
					
					// if the current element holds a tooltipster instance
					if (self) {
						
						if (typeof self[args[0]] === 'function') {
							
							if (	this.length > 1
								&&	args[0] == 'content'
								&&	(	args[1] instanceof $
									|| (typeof args[1] == 'object' && args[1] != null && args[1].tagName)
								)
								&&	!self.__options.contentCloning
								&&	self.__options.debug
							) {
								console.log(contentCloningWarning);
							}
							
							// note : args[1] and args[2] may not be defined
							var resp = self[args[0]](args[1], args[2]);
						}
						else {
							throw new Error('Unknown method "'+ args[0] +'"');
						}
						
						// if the function returned anything other than the instance
						// itself (which implies chaining, except for the `instance` method)
						if (resp !== self || args[0] === 'instance') {
							
							v = resp;
							
							// return false to stop .each iteration on the first element
							// matched by the selector
							return false;
						}
					}
					else {
						throw new Error('You called Tooltipster\'s "'+ args[0] +'" method on an uninitialized element');
					}
				});
				
				return (v !== '#*$~&') ? v : this;
			}
			// first argument is undefined or an object: the tooltip is initializing
			else {
				
				// reset the array of last initialized objects
				$.tooltipster.__instancesLatestArr = [];
				
				// is there a defined value for the multiple option in the options object ?
				var	multipleIsSet = args[0] && args[0].multiple !== undefined,
					// if the multiple option is set to true, or if it's not defined but
					// set to true in the defaults
					multiple = (multipleIsSet && args[0].multiple) || (!multipleIsSet && defaults.multiple),
					// same for content
					contentIsSet = args[0] && args[0].content !== undefined,
					content = (contentIsSet && args[0].content) || (!contentIsSet && defaults.content),
					// same for contentCloning
					contentCloningIsSet = args[0] && args[0].contentCloning !== undefined,
					contentCloning =
							(contentCloningIsSet && args[0].contentCloning)
						||	(!contentCloningIsSet && defaults.contentCloning),
					// same for debug
					debugIsSet = args[0] && args[0].debug !== undefined,
					debug = (debugIsSet && args[0].debug) || (!debugIsSet && defaults.debug);
				
				if (	this.length > 1
					&&	(	content instanceof $
						|| (typeof content == 'object' && content != null && content.tagName)
					)
					&&	!contentCloning
					&&	debug
				) {
					console.log(contentCloningWarning);
				}
				
				// create a tooltipster instance for each element if it doesn't
				// already have one or if the multiple option is set, and attach the
				// object to it
				this.each(function() {
					
					var go = false,
						$this = $(this),
						ns = $this.data('tooltipster-ns'),
						obj = null;
					
					if (!ns) {
						go = true;
					}
					else if (multiple) {
						go = true;
					}
					else if (debug) {
						console.log('Tooltipster: one or more tooltips are already attached to the element below. Ignoring.');
						console.log(this);
					}
					
					if (go) {
						obj = new $.Tooltipster(this, args[0]);
						
						// save the reference of the new instance
						if (!ns) ns = [];
						ns.push(obj.__namespace);
						$this.data('tooltipster-ns', ns);
						
						// save the instance itself
						$this.data(obj.__namespace, obj);
						
						// call our constructor custom function.
						// we do this here and not in ::init() because we wanted
						// the object to be saved in $this.data before triggering
						// it
						if (obj.__options.functionInit) {
							obj.__options.functionInit.call(obj, obj, {
								origin: this
							});
						}
						
						// and now the event, for the plugins and core emitter
						obj._trigger('init');
					}
					
					$.tooltipster.__instancesLatestArr.push(obj);
				});
				
				return this;
			}
		}
	};
	
	// Utilities
	
	/**
	 * A class to check if a tooltip can fit in given dimensions
	 * 
	 * @param {object} $tooltip The jQuery wrapped tooltip element, or a clone of it
	 */
	function Ruler($tooltip) {
		
		// list of instance variables
		
		this.$container;
		this.constraints = null;
		this.__$tooltip;
		
		this.__init($tooltip);
	}
	
	Ruler.prototype = {
		
		/**
		 * Move the tooltip into an invisible div that does not allow overflow to make
		 * size tests. Note: the tooltip may or may not be attached to the DOM at the
		 * moment this method is called, it does not matter.
		 * 
		 * @param {object} $tooltip The object to test. May be just a clone of the
		 * actual tooltip.
		 * @private
		 */
		__init: function($tooltip) {
			
			this.__$tooltip = $tooltip;
			
			this.__$tooltip
				.css({
					// for some reason we have to specify top and left 0
					left: 0,
					// any overflow will be ignored while measuring
					overflow: 'hidden',
					// positions at (0,0) without the div using 100% of the available width
					position: 'absolute',
					top: 0
				})
				// overflow must be auto during the test. We re-set this in case
				// it were modified by the user
				.find('.tooltipster-content')
					.css('overflow', 'auto');
			
			this.$container = $('<div class="tooltipster-ruler"></div>')
				.append(this.__$tooltip)
				.appendTo('body');
		},
		
		/**
		 * Force the browser to redraw (re-render) the tooltip immediately. This is required
		 * when you changed some CSS properties and need to make something with it
		 * immediately, without waiting for the browser to redraw at the end of instructions.
		 *
		 * @see http://stackoverflow.com/questions/3485365/how-can-i-force-webkit-to-redraw-repaint-to-propagate-style-changes
		 * @private
		 */
		__forceRedraw: function() {
			
			// note: this would app but for Webkit only
			//this.__$tooltip.close();
			//this.__$tooltip[0].offsetHeight;
			//this.__$tooltip.open();
			
			// works in FF too
			var $p = this.__$tooltip.parent();
			this.__$tooltip.detach();
			this.__$tooltip.appendTo($p);
		},
		
		/**
		 * Set maximum dimensions for the tooltip. A call to ::measure afterwards
		 * will tell us if the content overflows or if it's ok
		 *
		 * @param {int} width
		 * @param {int} height
		 * @return {Ruler}
		 * @public
		 */
		constrain: function(width, height) {
			
			this.constraints = {
				width: width,
				height: height
			};
			
			this.__$tooltip.css({
				// we disable display:flex, otherwise the content would overflow without
				// creating horizontal scrolling (which we need to detect).
				display: 'block',
				// reset any previous height
				height: '',
				// we'll check if horizontal scrolling occurs
				overflow: 'auto',
				// we'll set the width and see what height is generated and if there
				// is horizontal overflow
				width: width
			});
			
			return this;
		},
		
		/**
		 * Reset the tooltip content overflow and remove the test container
		 * 
		 * @returns {Ruler}
		 * @public
		 */
		destroy: function() {
			
			// in case the element was not a clone
			this.__$tooltip
				.detach()
				.find('.tooltipster-content')
					.css({
						// reset to CSS value
						display: '',
						overflow: ''
					});
			
			this.$container.remove();
		},
		
		/**
		 * Removes any constraints
		 * 
		 * @returns {Ruler}
		 * @public
		 */
		free: function() {
			
			this.constraints = null;
			
			// reset to natural size
			this.__$tooltip.css({
				display: '',
				height: '',
				overflow: 'visible',
				width: ''
			});
			
			return this;
		},
		
		/**
		 * Returns the size of the tooltip. When constraints are applied, also returns
		 * whether the tooltip fits in the provided dimensions.
		 * The idea is to see if the new height is small enough and if the content does
		 * not overflow horizontally.
		 *
		 * @param {int} width
		 * @param {int} height
		 * @returns {object} An object with a bool `fits` property and a `size` property
		 * @public
		 */
		measure: function() {
			
			this.__forceRedraw();
			
			var tooltipBcr = this.__$tooltip[0].getBoundingClientRect(),
				result = { size: {
					// bcr.width/height are not defined in IE8- but in this
					// case, bcr.right/bottom will have the same value
					// except in iOS 8+ where tooltipBcr.bottom/right are wrong
					// after scrolling for reasons yet to be determined
					height: tooltipBcr.height || tooltipBcr.bottom,
					width: tooltipBcr.width || tooltipBcr.right
				}};
			
			if (this.constraints) {
				
				// note: we used to use offsetWidth instead of boundingRectClient but
				// it returned rounded values, causing issues with sub-pixel layouts.
				
				// note2: noticed that the bcrWidth of text content of a div was once
				// greater than the bcrWidth of its container by 1px, causing the final
				// tooltip box to be too small for its content. However, evaluating
				// their widths one against the other (below) surprisingly returned
				// equality. Happened only once in Chrome 48, was not able to reproduce
				// => just having fun with float position values...
				
				var $content = this.__$tooltip.find('.tooltipster-content'),
					height = this.__$tooltip.outerHeight(),
					contentBcr = $content[0].getBoundingClientRect(),
					fits = {
						height: height <= this.constraints.height,
						width: (
							// this condition accounts for min-width property that
							// may apply
							tooltipBcr.width <= this.constraints.width
								// the -1 is here because scrollWidth actually returns
								// a rounded value, and may be greater than bcr.width if
								// it was rounded up. This may cause an issue for contents
								// which actually really overflow  by 1px or so, but that
								// should be rare. Not sure how to solve this efficiently.
								// See http://blogs.msdn.com/b/ie/archive/2012/02/17/sub-pixel-rendering-and-the-css-object-model.aspx
							&&	contentBcr.width >= $content[0].scrollWidth - 1
						)
					};
				
				result.fits = fits.height && fits.width;
			}
			
			// old versions of IE get the width wrong for some reason
			if (env.IE && env.IE <= 11) {
				result.size.width = Math.ceil(result.size.width) + 1;
			}
			
			return result;
		}
	};
	
	// quick & dirty compare function, not bijective nor multidimensional
	function areEqual(a,b) {
		var same = true;
		$.each(a, function(i, _) {
			if (b[i] === undefined || a[i] !== b[i]) {
				same = false;
				return false;
			}
		});
		return same;
	}
	
	/**
	 * A fast function to check if an element is still in the DOM. It
	 * tries to use an id as ids are indexed by the browser, or falls
	 * back to jQuery's `contains` method. May fail if two elements
	 * have the same id, but so be it
	 *
	 * @param {object} $obj A jQuery-wrapped HTML element
	 * @return {boolean}
	 */
	function bodyContains($obj) {
		var id = $obj.attr('id'),
			el = id ? env.window.document.getElementById(id) : null;
		// must also check that the element with the id is the one we want
		return el ? el === $obj[0] : $.contains(env.window.document.body, $obj[0]);
	}
	
	// detect IE versions for dirty fixes
	var uA = navigator.userAgent.toLowerCase();
	if (uA.indexOf('msie') != -1) env.IE = parseInt(uA.split('msie')[1]);
	else if (uA.toLowerCase().indexOf('trident') !== -1 && uA.indexOf(' rv:11') !== -1) env.IE = 11;
	else if (uA.toLowerCase().indexOf('edge/') != -1) env.IE = parseInt(uA.toLowerCase().split('edge/')[1]);
	
	// detecting support for CSS transitions
	function transitionSupport() {
		
		// env.window is not defined yet when this is called
		if (!win) return false;
		
		var b = win.document.body || win.document.documentElement,
			s = b.style,
			p = 'transition',
			v = ['Moz', 'Webkit', 'Khtml', 'O', 'ms'];
		
		if (typeof s[p] == 'string') { return true; }
		
		p = p.charAt(0).toUpperCase() + p.substr(1);
		for (var i=0; i<v.length; i++) {
			if (typeof s[v[i] + p] == 'string') { return true; }
		}
		return false;
	}
	
	// we'll return jQuery for plugins not to have to declare it as a dependency,
	// but it's done by a build task since it should be included only once at the
	// end when we concatenate the core file with a plugin
	// sideTip is Tooltipster's default plugin.
	// This file will be UMDified by a build task.
	
	var pluginName = 'tooltipster.sideTip';
	
	$.tooltipster._plugin({
		name: pluginName,
		instance: {
			/**
			 * Defaults are provided as a function for an easy override by inheritance
			 *
			 * @return {object} An object with the defaults options
			 * @private
			 */
			__defaults: function() {
				
				return {
					// if the tooltip should display an arrow that points to the origin
					arrow: true,
					// the distance in pixels between the tooltip and the origin
					distance: 6,
					// allows to easily change the position of the tooltip
					functionPosition: null,
					maxWidth: null,
					// used to accomodate the arrow of tooltip if there is one.
					// First to make sure that the arrow target is not too close
					// to the edge of the tooltip, so the arrow does not overflow
					// the tooltip. Secondly when we reposition the tooltip to
					// make sure that it's positioned in such a way that the arrow is
					// still pointing at the target (and not a few pixels beyond it).
					// It should be equal to or greater than half the width of
					// the arrow (by width we mean the size of the side which touches
					// the side of the tooltip).
					minIntersection: 16,
					minWidth: 0,
					// deprecated in 4.0.0. Listed for _optionsExtract to pick it up
					position: null,
					side: 'top',
					// set to false to position the tooltip relatively to the document rather
					// than the window when we open it
					viewportAware: true
				};
			},
			
			/**
			 * Run once: at instantiation of the plugin
			 *
			 * @param {object} instance The tooltipster object that instantiated this plugin
			 * @private
			 */
			__init: function(instance) {
				
				var self = this;
				
				// list of instance variables
				
				self.__instance = instance;
				self.__namespace = 'tooltipster-sideTip-'+ Math.round(Math.random()*1000000);
				self.__previousState = 'closed';
				self.__options;
				
				// initial formatting
				self.__optionsFormat();
				
				self.__instance._on('state.'+ self.__namespace, function(event) {
					
					if (event.state == 'closed') {
						self.__close();
					}
					else if (event.state == 'appearing' && self.__previousState == 'closed') {
						self.__create();
					}
					
					self.__previousState = event.state;
				});
				
				// reformat every time the options are changed
				self.__instance._on('options.'+ self.__namespace, function() {
					self.__optionsFormat();
				});
				
				self.__instance._on('reposition.'+ self.__namespace, function(e) {
					self.__reposition(e.event, e.helper);
				});
			},
			
			/**
			 * Called when the tooltip has closed
			 * 
			 * @private
			 */
			__close: function() {
				
				// detach our content object first, so the next jQuery's remove()
				// call does not unbind its event handlers
				if (this.__instance.content() instanceof $) {
					this.__instance.content().detach();
				}
				
				// remove the tooltip from the DOM
				this.__instance._$tooltip.remove();
				this.__instance._$tooltip = null;
			},
			
			/**
			 * Creates the HTML element of the tooltip.
			 * 
			 * @private
			 */
			__create: function() {
				
				// note: we wrap with a .tooltipster-box div to be able to set a margin on it
				// (.tooltipster-base must not have one)
				var $html = $(
					'<div class="tooltipster-base tooltipster-sidetip">' +
						'<div class="tooltipster-box">' +
							'<div class="tooltipster-content"></div>' +
						'</div>' +
						'<div class="tooltipster-arrow">' +
							'<div class="tooltipster-arrow-uncropped">' +
								'<div class="tooltipster-arrow-border"></div>' +
								'<div class="tooltipster-arrow-background"></div>' +
							'</div>' +
						'</div>' +
					'</div>'
				);
				
				// hide arrow if asked
				if (!this.__options.arrow) {
					$html
						.find('.tooltipster-box')
							.css('margin', 0)
							.end()
						.find('.tooltipster-arrow')
							.hide();
				}
				
				// apply min/max width if asked
				if (this.__options.minWidth) {
					$html.css('min-width', this.__options.minWidth + 'px');
				}
				if (this.__options.maxWidth) {
					$html.css('max-width', this.__options.maxWidth + 'px');
				}
				
				this.__instance._$tooltip = $html;
				
				// tell the instance that the tooltip element has been created
				this.__instance._trigger('created');
			},
			
			/**
			 * Used when the plugin is to be unplugged
			 *
			 * @private
			 */
			__destroy: function() {
				this.__instance._off('.'+ self.__namespace);
			},
			
			/**
			 * (Re)compute this.__options from the options declared to the instance
			 *
			 * @private
			 */
			__optionsFormat: function() {
				
				var self = this;
				
				// get the options
				self.__options = self.__instance._optionsExtract(pluginName, self.__defaults());
				
				// for backward compatibility, deprecated in v4.0.0
				if (self.__options.position) {
					self.__options.side = self.__options.position;
				}
				
				// options formatting
				
				// format distance as a four-cell array if it ain't one yet and then make
				// it an object with top/bottom/left/right properties
				if (typeof self.__options.distance != 'object') {
					self.__options.distance = [self.__options.distance];
				}
				if (self.__options.distance.length < 4) {
					
					if (self.__options.distance[1] === undefined) self.__options.distance[1] = self.__options.distance[0];
					if (self.__options.distance[2] === undefined) self.__options.distance[2] = self.__options.distance[0];
					if (self.__options.distance[3] === undefined) self.__options.distance[3] = self.__options.distance[1];
					
					self.__options.distance = {
						top: self.__options.distance[0],
						right: self.__options.distance[1],
						bottom: self.__options.distance[2],
						left: self.__options.distance[3]
					};
				}
				
				// let's transform:
				// 'top' into ['top', 'bottom', 'right', 'left']
				// 'right' into ['right', 'left', 'top', 'bottom']
				// 'bottom' into ['bottom', 'top', 'right', 'left']
				// 'left' into ['left', 'right', 'top', 'bottom']
				if (typeof self.__options.side == 'string') {
					
					var opposites = {
						'top': 'bottom',
						'right': 'left',
						'bottom': 'top',
						'left': 'right'
					};
					
					self.__options.side = [self.__options.side, opposites[self.__options.side]];
					
					if (self.__options.side[0] == 'left' || self.__options.side[0] == 'right') {
						self.__options.side.push('top', 'bottom');
					}
					else {
						self.__options.side.push('right', 'left');
					}
				}
				
				// misc
				// disable the arrow in IE6 unless the arrow option was explicitly set to true
				if (	$.tooltipster._env.IE === 6
					&&	self.__options.arrow !== true
				) {
					self.__options.arrow = false;
				}
			},
			
			/**
			 * This method must compute and set the positioning properties of the
			 * tooltip (left, top, width, height, etc.). It must also make sure the
			 * tooltip is eventually appended to its parent (since the element may be
			 * detached from the DOM at the moment the method is called).
			 *
			 * We'll evaluate positioning scenarios to find which side can contain the
			 * tooltip in the best way. We'll consider things relatively to the window
			 * (unless the user asks not to), then to the document (if need be, or if the
			 * user explicitly requires the tests to run on the document). For each
			 * scenario, measures are taken, allowing us to know how well the tooltip
			 * is going to fit. After that, a sorting function will let us know what
			 * the best scenario is (we also allow the user to choose his favorite
			 * scenario by using an event).
			 * 
			 * @param {object} helper An object that contains variables that plugin
			 * creators may find useful (see below)
			 * @param {object} helper.geo An object with many layout properties
			 * about objects of interest (window, document, origin). This should help
			 * plugin users compute the optimal position of the tooltip
			 * @private
			 */
			__reposition: function(event, helper) {
				
				var self = this,
					finalResult,
					// to know where to put the tooltip, we need to know on which point
					// of the x or y axis we should center it. That coordinate is the target
					targets = self.__targetFind(helper),
					testResults = [];
				
				// make sure the tooltip is detached while we make tests on a clone
				self.__instance._$tooltip.detach();
				
				// we could actually provide the original element to the Ruler and
				// not a clone, but it just feels right to keep it out of the
				// machinery.
				var $clone = self.__instance._$tooltip.clone(),
					// start position tests session
					ruler = $.tooltipster._getRuler($clone),
					satisfied = false;
				
				// start evaluating scenarios
				$.each(['window', 'document'], function(i, container) {
					
					var takeTest = null;
					
					// let the user decide to keep on testing or not
					self.__instance._trigger({
						container: container,
						helper: helper,
						satisfied: satisfied,
						takeTest: function(bool) {
							takeTest = bool;
						},
						results: testResults,
						type: 'positionTest'
					});
					
					if (	takeTest == true
						||	(	takeTest != false
							&&	satisfied == false
								// skip the window scenarios if asked. If they are reintegrated by
								// the callback of the positionTest event, they will have to be
								// excluded using the callback of positionTested
							&&	(container != 'window' || self.__options.viewportAware)
						)
					) {
						
						// for each allowed side
						for (var i=0; i < self.__options.side.length; i++) {
							
							var distance = {
									horizontal: 0,
									vertical: 0
								},
								side = self.__options.side[i];
							
							if (side == 'top' || side == 'bottom') {
								distance.vertical = self.__options.distance[side];
							}
							else {
								distance.horizontal = self.__options.distance[side];
							}
							
							// this may have an effect on the size of the tooltip if there are css
							// rules for the arrow or something else
							self.__sideChange($clone, side);
							
							$.each(['natural', 'constrained'], function(i, mode) {
								
								takeTest = null;
								
								// emit an event on the instance
								self.__instance._trigger({
									container: container,
									event: event,
									helper: helper,
									mode: mode,
									results: testResults,
									satisfied: satisfied,
									side: side,
									takeTest: function(bool) {
										takeTest = bool;
									},
									type: 'positionTest'
								});
								
								if (	takeTest == true
									||	(	takeTest != false
										&&	satisfied == false
									)
								) {
									
									var testResult = {
										container: container,
										// we let the distance as an object here, it can make things a little easier
										// during the user's calculations at positionTest/positionTested
										distance: distance,
										// whether the tooltip can fit in the size of the viewport (does not mean
										// that we'll be able to make it initially entirely visible, see 'whole')
										fits: null,
										mode: mode,
										outerSize: null,
										side: side,
										size: null,
										target: targets[side],
										// check if the origin has enough surface on screen for the tooltip to
										// aim at it without overflowing the viewport (this is due to the thickness
										// of the arrow represented by the minIntersection length).
										// If not, the tooltip will have to be partly or entirely off screen in
										// order to stay docked to the origin. This value will stay null when the
										// container is the document, as it is not relevant
										whole: null
									};
									
									// get the size of the tooltip with or without size constraints
									var rulerConfigured = (mode == 'natural') ?
											ruler.free() :
											ruler.constrain(
												helper.geo.available[container][side].width - distance.horizontal,
												helper.geo.available[container][side].height - distance.vertical
											),
										rulerResults = rulerConfigured.measure();
									
									testResult.size = rulerResults.size;
									testResult.outerSize = {
										height: rulerResults.size.height + distance.vertical,
										width: rulerResults.size.width + distance.horizontal
									};
									
									if (mode == 'natural') {
										
										if(		helper.geo.available[container][side].width >= testResult.outerSize.width
											&&	helper.geo.available[container][side].height >= testResult.outerSize.height
										) {
											testResult.fits = true;
										}
										else {
											testResult.fits = false;
										}
									}
									else {
										testResult.fits = rulerResults.fits;
									}
									
									if (container == 'window') {
										
										if (!testResult.fits) {
											testResult.whole = false;
										}
										else {
											if (side == 'top' || side == 'bottom') {
												
												testResult.whole = (
														helper.geo.origin.windowOffset.right >= self.__options.minIntersection
													&&	helper.geo.window.size.width - helper.geo.origin.windowOffset.left >= self.__options.minIntersection
												);
											}
											else {
												testResult.whole = (
														helper.geo.origin.windowOffset.bottom >= self.__options.minIntersection
													&&	helper.geo.window.size.height - helper.geo.origin.windowOffset.top >= self.__options.minIntersection
												);
											}
										}
									}
									
									testResults.push(testResult);
									
									// we don't need to compute more positions if we have one fully on screen
									if (testResult.whole) {
										satisfied = true;
									}
									else {
										// don't run the constrained test unless the natural width was greater
										// than the available width, otherwise it's pointless as we know it
										// wouldn't fit either
										if (	testResult.mode == 'natural'
											&&	(	testResult.fits
												||	testResult.size.width <= helper.geo.available[container][side].width
											)
										) {
											return false;
										}
									}
								}
							});
						}
					}
				});
				
				// the user may eliminate the unwanted scenarios from testResults, but he's
				// not supposed to alter them at this point. functionPosition and the
				// position event serve that purpose.
				self.__instance._trigger({
					edit: function(r) {
						testResults = r;
					},
					event: event,
					helper: helper,
					results: testResults,
					type: 'positionTested'
				});
				
				/**
				 * Sort the scenarios to find the favorite one.
				 * 
				 * The favorite scenario is when we can fully display the tooltip on screen,
				 * even if it means that the middle of the tooltip is no longer centered on
				 * the middle of the origin (when the origin is near the edge of the screen
				 * or even partly off screen). We want the tooltip on the preferred side,
				 * even if it means that we have to use a constrained size rather than a
				 * natural one (as long as it fits). When the origin is off screen at the top
				 * the tooltip will be positioned at the bottom (if allowed), if the origin
				 * is off screen on the right, it will be positioned on the left, etc.
				 * If there are no scenarios where the tooltip can fit on screen, or if the
				 * user does not want the tooltip to fit on screen (viewportAware == false),
				 * we fall back to the scenarios relative to the document.
				 * 
				 * When the tooltip is bigger than the viewport in either dimension, we stop
				 * looking at the window scenarios and consider the document scenarios only,
				 * with the same logic to find on which side it would fit best.
				 * 
				 * If the tooltip cannot fit the document on any side, we force it at the
				 * bottom, so at least the user can scroll to see it.
	 			 */
				testResults.sort(function(a, b) {
					
					// best if it's whole (the tooltip fits and adapts to the viewport)
					if (a.whole && !b.whole) {
						return -1;
					}
					else if (!a.whole && b.whole) {
						return 1;
					}
					else if (a.whole && b.whole) {
						
						var ai = self.__options.side.indexOf(a.side),
							bi = self.__options.side.indexOf(b.side);
						
						// use the user's sides fallback array
						if (ai < bi) {
							return -1;
						}
						else if (ai > bi) {
							return 1;
						}
						else {
							// will be used if the user forced the tests to continue
							return a.mode == 'natural' ? -1 : 1;
						}
					}
					else {
						
						// better if it fits
						if (a.fits && !b.fits) {
							return -1;
						}
						else if (!a.fits && b.fits) {
							return 1;
						}
						else if (a.fits && b.fits) {
							
							var ai = self.__options.side.indexOf(a.side),
								bi = self.__options.side.indexOf(b.side);
							
							// use the user's sides fallback array
							if (ai < bi) {
								return -1;
							}
							else if (ai > bi) {
								return 1;
							}
							else {
								// will be used if the user forced the tests to continue
								return a.mode == 'natural' ? -1 : 1;
							}
						}
						else {
							
							// if everything failed, this will give a preference to the case where
							// the tooltip overflows the document at the bottom
							if (	a.container == 'document'
								&&	a.side == 'bottom'
								&&	a.mode == 'natural'
							) {
								return -1;
							}
							else {
								return 1;
							}
						}
					}
				});
				
				finalResult = testResults[0];
				
				
				// now let's find the coordinates of the tooltip relatively to the window
				finalResult.coord = {};
				
				switch (finalResult.side) {
					
					case 'left':
					case 'right':
						finalResult.coord.top = Math.floor(finalResult.target - finalResult.size.height / 2);
						break;
					
					case 'bottom':
					case 'top':
						finalResult.coord.left = Math.floor(finalResult.target - finalResult.size.width / 2);
						break;
				}
				
				switch (finalResult.side) {
					
					case 'left':
						finalResult.coord.left = helper.geo.origin.windowOffset.left - finalResult.outerSize.width;
						break;
					
					case 'right':
						finalResult.coord.left = helper.geo.origin.windowOffset.right + finalResult.distance.horizontal;
						break;
					
					case 'top':
						finalResult.coord.top = helper.geo.origin.windowOffset.top - finalResult.outerSize.height;
						break;
					
					case 'bottom':
						finalResult.coord.top = helper.geo.origin.windowOffset.bottom + finalResult.distance.vertical;
						break;
				}
				
				// if the tooltip can potentially be contained within the viewport dimensions
				// and that we are asked to make it fit on screen
				if (finalResult.container == 'window') {
					
					// if the tooltip overflows the viewport, we'll move it accordingly (then it will
					// not be centered on the middle of the origin anymore). We only move horizontally
					// for top and bottom tooltips and vice versa.
					if (finalResult.side == 'top' || finalResult.side == 'bottom') {
						
						// if there is an overflow on the left
						if (finalResult.coord.left < 0) {
							
							// prevent the overflow unless the origin itself gets off screen (minus the
							// margin needed to keep the arrow pointing at the target)
							if (helper.geo.origin.windowOffset.right - this.__options.minIntersection >= 0) {
								finalResult.coord.left = 0;
							}
							else {
								finalResult.coord.left = helper.geo.origin.windowOffset.right - this.__options.minIntersection - 1;
							}
						}
						// or an overflow on the right
						else if (finalResult.coord.left > helper.geo.window.size.width - finalResult.size.width) {
							
							if (helper.geo.origin.windowOffset.left + this.__options.minIntersection <= helper.geo.window.size.width) {
								finalResult.coord.left = helper.geo.window.size.width - finalResult.size.width;
							}
							else {
								finalResult.coord.left = helper.geo.origin.windowOffset.left + this.__options.minIntersection + 1 - finalResult.size.width;
							}
						}
					}
					else {
						
						// overflow at the top
						if (finalResult.coord.top < 0) {
							
							if (helper.geo.origin.windowOffset.bottom - this.__options.minIntersection >= 0) {
								finalResult.coord.top = 0;
							}
							else {
								finalResult.coord.top = helper.geo.origin.windowOffset.bottom - this.__options.minIntersection - 1;
							}
						}
						// or at the bottom
						else if (finalResult.coord.top > helper.geo.window.size.height - finalResult.size.height) {
							
							if (helper.geo.origin.windowOffset.top + this.__options.minIntersection <= helper.geo.window.size.height) {
								finalResult.coord.top = helper.geo.window.size.height - finalResult.size.height;
							}
							else {
								finalResult.coord.top = helper.geo.origin.windowOffset.top + this.__options.minIntersection + 1 - finalResult.size.height;
							}
						}
					}
				}
				else {
					
					// there might be overflow here too but it's easier to handle. If there has
					// to be an overflow, we'll make sure it's on the right side of the screen
					// (because the browser will extend the document size if there is an overflow
					// on the right, but not on the left). The sort function above has already
					// made sure that a bottom document overflow is preferred to a top overflow,
					// so we don't have to care about it.
					
					// if there is an overflow on the right
					if (finalResult.coord.left > helper.geo.window.size.width - finalResult.size.width) {
						
						// this may actually create on overflow on the left but we'll fix it in a sec
						finalResult.coord.left = helper.geo.window.size.width - finalResult.size.width;
					}
					
					// if there is an overflow on the left
					if (finalResult.coord.left < 0) {
						
						// don't care if it overflows the right after that, we made our best
						finalResult.coord.left = 0;
					}
				}
				
				
				// submit the positioning proposal to the user function which may choose to change
				// the side, size and/or the coordinates
				
				// first, set the rules that corresponds to the proposed side: it may change
				// the size of the tooltip, and the custom functionPosition may want to detect the
				// size of something before making a decision. So let's make things easier for the
				// implementor
				self.__sideChange($clone, finalResult.side);
				
				// add some variables to the helper
				helper.tooltipClone = $clone[0];
				helper.tooltipParent = self.__instance.option('parent').parent[0];
				// move informative values to the helper
				helper.mode = finalResult.mode;
				helper.whole = finalResult.whole;
				// add some variables to the helper for the functionPosition callback (these
				// will also be added to the event fired by self.__instance._trigger but that's
				// ok, we're just being consistent)
				helper.origin = self.__instance._$origin[0];
				helper.tooltip = self.__instance._$tooltip[0];
				
				// leave only the actionable values in there for functionPosition
				delete finalResult.container;
				delete finalResult.fits;
				delete finalResult.mode;
				delete finalResult.outerSize;
				delete finalResult.whole;
				
				// keep only the distance on the relevant side, for clarity
				finalResult.distance = finalResult.distance.horizontal || finalResult.distance.vertical;
				
				// beginners may not be comfortable with the concept of editing the object
				//  passed by reference, so we provide an edit function and pass a clone
				var finalResultClone = $.extend(true, {}, finalResult);
				
				// emit an event on the instance
				self.__instance._trigger({
					edit: function(result) {
						finalResult = result;
					},
					event: event,
					helper: helper,
					position: finalResultClone,
					type: 'position'
				});
				
				if (self.__options.functionPosition) {
					
					
					var result = self.__options.functionPosition.call(self, self.__instance, helper, finalResultClone);
					
					if (result) finalResult = result;
				}
				
				// end the positioning tests session (the user might have had a
				// use for it during the position event, now it's over)
				ruler.destroy();
				
				
				// compute the position of the target relatively to the tooltip root
				// element so we can place the arrow and make the needed adjustments
				var arrowCoord,
					maxVal;
				
				if (finalResult.side == 'top' || finalResult.side == 'bottom') {
					
					arrowCoord = {
						prop: 'left',
						val: finalResult.target - finalResult.coord.left
					};
					maxVal = finalResult.size.width - this.__options.minIntersection;
				}
				else {
					
					arrowCoord = {
						prop: 'top',
						val: finalResult.target - finalResult.coord.top
					};
					maxVal = finalResult.size.height - this.__options.minIntersection;
				}
				
				// cannot lie beyond the boundaries of the tooltip, minus the
				// arrow margin
				if (arrowCoord.val < this.__options.minIntersection) {
					arrowCoord.val = this.__options.minIntersection;
				}
				else if (arrowCoord.val > maxVal) {
					arrowCoord.val = maxVal;
				}
				
				var originParentOffset;
				
				// let's convert the window-relative coordinates into coordinates relative to the
				// future positioned parent that the tooltip will be appended to
				if (helper.geo.origin.fixedLineage) {
					
					// same as windowOffset when the position is fixed
					originParentOffset = helper.geo.origin.windowOffset;
				}
				else {
					
					// this assumes that the parent of the tooltip is located at
					// (0, 0) in the document, typically like when the parent is
					// <body>.
					// If we ever allow other types of parent, .tooltipster-ruler
					// will have to be appended to the parent to inherit css style
					// values that affect the display of the text and such.
					originParentOffset = {
						left: helper.geo.origin.windowOffset.left + helper.geo.window.scroll.left,
						top: helper.geo.origin.windowOffset.top + helper.geo.window.scroll.top
					};
				}
				
				finalResult.coord = {
					left: originParentOffset.left + (finalResult.coord.left - helper.geo.origin.windowOffset.left),
					top: originParentOffset.top + (finalResult.coord.top - helper.geo.origin.windowOffset.top)
				};
				
				// set position values on the original tooltip element
				
				self.__sideChange(self.__instance._$tooltip, finalResult.side);
				
				if (helper.geo.origin.fixedLineage) {
					self.__instance._$tooltip
						.css('position', 'fixed');
				}
				else {
					// CSS default
					self.__instance._$tooltip
						.css('position', '');
				}
				
				self.__instance._$tooltip
					.css({
						left: finalResult.coord.left,
						top: finalResult.coord.top,
						// we need to set a size even if the tooltip is in its natural size
						// because when the tooltip is positioned beyond the width of the body
						// (which is by default the width of the window; it will happen when
						// you scroll the window horizontally to get to the origin), its text
						// content will otherwise break lines at each word to keep up with the
						// body overflow strategy.
						height: finalResult.size.height,
						width: finalResult.size.width
					})
					.find('.tooltipster-arrow')
						.css({
							'left': '',
							'top': ''
						})
						.css(arrowCoord.prop, arrowCoord.val);
				
				// append the tooltip HTML element to its parent
				self.__instance._$tooltip.appendTo(self.__instance.option('parent'));
				
				self.__instance._trigger({
					type: 'repositioned',
					event: event,
					position: finalResult
				});
			},
			
			/**
			 * Make whatever modifications are needed when the side is changed. This has
			 * been made an independant method for easy inheritance in custom plugins based
			 * on this default plugin.
			 *
			 * @param {object} $obj
			 * @param {string} side
			 * @private
			 */
			__sideChange: function($obj, side) {
				
				$obj
					.removeClass('tooltipster-bottom')
					.removeClass('tooltipster-left')
					.removeClass('tooltipster-right')
					.removeClass('tooltipster-top')
					.addClass('tooltipster-'+ side);
			},
			
			/**
			 * Returns the target that the tooltip should aim at for a given side.
			 * The calculated value is a distance from the edge of the window
			 * (left edge for top/bottom sides, top edge for left/right side). The
			 * tooltip will be centered on that position and the arrow will be
			 * positioned there (as much as possible).
			 *
			 * @param {object} helper
			 * @return {integer}
			 * @private
			 */
			__targetFind: function(helper) {
				
				var target = {},
					rects = this.__instance._$origin[0].getClientRects();
				
				// these lines fix a Chrome bug (issue #491)
				if (rects.length > 1) {
					var opacity = this.__instance._$origin.css('opacity');
					if(opacity == 1) {
						this.__instance._$origin.css('opacity', 0.99);
						rects = this.__instance._$origin[0].getClientRects();
						this.__instance._$origin.css('opacity', 1);
					}
				}
				
				// by default, the target will be the middle of the origin
				if (rects.length < 2) {
					
					target.top = Math.floor(helper.geo.origin.windowOffset.left + (helper.geo.origin.size.width / 2));
					target.bottom = target.top;
					
					target.left = Math.floor(helper.geo.origin.windowOffset.top + (helper.geo.origin.size.height / 2));
					target.right = target.left;
				}
				// if multiple client rects exist, the element may be text split
				// up into multiple lines and the middle of the origin may not be
				// best option anymore. We need to choose the best target client rect
				else {
					
					// top: the first
					var targetRect = rects[0];
					target.top = Math.floor(targetRect.left + (targetRect.right - targetRect.left) / 2);
			
					// right: the middle line, rounded down in case there is an even
					// number of lines (looks more centered => check out the
					// demo with 4 split lines)
					if (rects.length > 2) {
						targetRect = rects[Math.ceil(rects.length / 2) - 1];
					}
					else {
						targetRect = rects[0];
					}
					target.right = Math.floor(targetRect.top + (targetRect.bottom - targetRect.top) / 2);
			
					// bottom: the last
					targetRect = rects[rects.length - 1];
					target.bottom = Math.floor(targetRect.left + (targetRect.right - targetRect.left) / 2);
			
					// left: the middle line, rounded up
					if (rects.length > 2) {
						targetRect = rects[Math.ceil((rects.length + 1) / 2) - 1];
					}
					else {
						targetRect = rects[rects.length - 1];
					}
					
					target.left = Math.floor(targetRect.top + (targetRect.bottom - targetRect.top) / 2);
				}
				
				return target;
			}
		}
	});
	
	/* a build task will add "return $;" here */
	return $;
	
	}));


/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

	var map = {
		"./accordion.js": 37,
		"./add-tooltip-to-row.js": 38,
		"./attestation.js": 39,
		"./body-click.js": 41,
		"./check-not-all-checkboxes.js": 42,
		"./class-hour.js": 43,
		"./clickable.js": 44,
		"./close-lk-block.js": 45,
		"./custom-modal.js": 46,
		"./display-scroll-up.js": 47,
		"./favorite.js": 48,
		"./feedback.js": 49,
		"./file-upload-button.js": 50,
		"./form-data-add.js": 51,
		"./guide-material-counter.js": 52,
		"./hover.js": 53,
		"./lesson-sidebar.js": 54,
		"./lesson-video.js": 55,
		"./lesson.js": 57,
		"./lessons.js": 58,
		"./lk-blocks-open.js": 59,
		"./lk-checkbox-list.js": 60,
		"./lk-homework.js": 61,
		"./lk.js": 62,
		"./lk__timetable.js": 63,
		"./main-page-circle.js": 64,
		"./menu-add.js": 65,
		"./modal-search-close.js": 66,
		"./modal.js": 67,
		"./msgs-handling.js": 68,
		"./news.js": 69,
		"./note-close.js": 70,
		"./page-up.js": 71,
		"./quiz.js": 72,
		"./registration-form.js": 73,
		"./search.js": 74,
		"./select-one.js": 75,
		"./special-course.js": 76,
		"./summer-education.js": 77,
		"./switch-group-action.js": 78,
		"./tabs.js": 79,
		"./tabs2.js": 80,
		"./tabs3.js": 81,
		"./teachers.js": 82,
		"./temporary.js": 83,
		"./tests.js": 84,
		"./timetable-course.js": 85,
		"./timetable-link-hover.js": 86,
		"./tinyMCE-init.js": 87,
		"./tos-handle.js": 88,
		"./tv-lessons.js": 89,
		"./warning-bottom-window.js": 91
	};
	function webpackContext(req) {
		return __webpack_require__(webpackContextResolve(req));
	};
	function webpackContextResolve(req) {
		return map[req] || (function() { throw new Error("Cannot find module '" + req + "'.") }());
	};
	webpackContext.keys = function webpackContextKeys() {
		return Object.keys(map);
	};
	webpackContext.resolve = webpackContextResolve;
	module.exports = webpackContext;
	webpackContext.id = 36;


/***/ }),
/* 37 */
/***/ (function(module, exports) {

	$(document).ready(function(){
	
	    var accordionOpen = $('.accordion-open'),
	        accordionOpenHeight = accordionOpen.find('.accordion-content').outerHeight(true),
	        accordionButton = $('.accordion-box li span');
	
	    accordionOpen.height( accordionOpenHeight );
	
	    accordionButton.click(function(){
	        var t = $(this),
	            container = t.next('.accordion-container'),
	            buttons = t.parent().siblings('li').children('span'),
	            otherConteiners = t.parent().siblings().find('.accordion-container'),
	            outerConteiner = t.closest('.accordion-container'),
	            outerContent = outerConteiner.children('.accordion-content'),
	            openedConteinerHeight = t.closest('.accordion-box').find('.accordion-open').outerHeight(true);
	
	        buttons.removeClass('accordion-arr-flip');
	
	        if (container.hasClass('accordion-open')) {
	            container.height(0).removeClass('accordion-open');
	            t.removeClass('accordion-arr-flip');
	            outerConteiner.height( outerContent.outerHeight(true) - container.children('.accordion-content').outerHeight(true) );
	        } else {
	            otherConteiners.removeClass('accordion-open').height(0);
	            container.prev().addClass('accordion-arr-flip');
	            container.height( container.children('.accordion-content').outerHeight(true) ).addClass('accordion-open');
	
	            outerConteiner.height( outerContent.outerHeight(true) - openedConteinerHeight + container.children('.accordion-content').outerHeight(true) );
	
	        }
	    });
	});

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

	var tooltip2 = __webpack_require__(34);
	
	$('#fos_user_registration_form_schoolClass').closest('.menu-slide__form-row')
	   .addClass('_tooltip2')
	   .attr('title', 'Обращаем внимание, что для просмотра доступны интерактивные уроки только по учебным предметам 5 класса');
	
	
	$('.menu-slide__row').on('mouseenter', '._tooltip2:not(.tooltipstered)', function () {
	   $(this)
	      .tooltipster(tooltip2.options)
	      .tooltipster('open');
	});

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

	const Swal = __webpack_require__(40);
	const ajaxButtonPost = __webpack_require__(4);
	const reshMultiSelect = __webpack_require__(30);
	
	$('.attestation-item-more').on('click', itemMoreClick);
	
	function itemMoreClick(e) {
	    e.stopPropagation();
	    let attestationId = $(this).attr('data-id');
	
	    if ($('[data-block-id='+attestationId+']').css('display')=='none') {
	
	        $.get(Routing.generate('private_office_teacher_attestation_more', {
	            'attestationId': attestationId ? attestationId : null,
	        }), function (data) {
	            $('[data-block-id=' + attestationId + ']').slideDown(400);
	            $('[data-block-id=' + attestationId + '] td').html(data);
	        });
	    } else {
	        $('[data-block-id=' + attestationId + ']').slideUp(400);
	        $('[data-block-id=' + attestationId + '] td').empty();
	
	    }
	
	}
	
	$('.attestation-control-start').on('click', controlStartClick);
	
	function controlStartClick(e) {
	    e.stopPropagation();
	    let $this = $(this)
	    let title = $(this).data('title')
	    let duration = $(this).data('duration')
	    let period = $(this).data('period')
	
	    Swal.fire({
	        //reverseButtons: true,
	        confirmButtonColor: '#32d7c0',
	        focusCancel: true,
	        showCancelButton: true,
	        html: '<small>Аттестационная работа: '+title+'<br>' +
	            'Работа доступна: '+period+'<br>' +
	            'Время выполнения: '+duration+'</small><br><br><br>' +
	            'Аттестационная работа "'+title+'" рассчитана по времени на '+duration+'.<br><br>' +
	            'Внимательно ознакомьтесь с текстом задания, прежде чем дать ответ.<br>' +
	            'Вы всегда можете вернуться к выполненному заданию и изменить свой ответ.<br>' +
	            'Обращаем внимание, что работа ограничена по времени.<br>' +
	            'Если вы не успеете завершить работу в отведенное время, то работа завершится<br>' +
	            'автоматически и будет отправлена на проверку.<br>' +
	            'Если вы случайно закроете рабочее окно с выполняемой работой до окончания<br>' +
	            'отведенного времени, не нажав на кнопку «Завершить и отправить на проверку», то<br>' +
	            'вы сможете вернуться к работе и продолжить ее выполнение, при этом таймер <strong>не будет</strong> остановлен.<br><br>' +
	            ' Желаем удачи!',
	        confirmButtonText: 'Начать',
	        cancelButtonText: 'Отмена'
	    }).then((result) => {
	        if (result.value === true) {
	            location.href = $this.attr('href')
	        }
	    });
	
	    return false;
	}
	
	function controlWorkMoreClick(e) {
	    e.stopPropagation();
	    let $this = $(this)
	    let sess_id = $(this).data('session-id')
	
	    $.ajax({
	        url: Routing.generate('private_office_pupil_attestation_control_more_popup', {'attestationSession': sess_id}),
	        type: 'GET',
	        success: function (data) {
	            Swal.fire({
	                title: 'Информация о работе',
	                html: data
	            })
	        }
	    });
	
	    return false;
	}
	
	
	$('.pupil-work-more-popup').on('click', controlWorkMoreClick);
	
	
	function attestationFormChange () {
	    $(this).find('button[type=submit]').attr('disabled', false)
	}
	
	$('.add-attestation-form').on('change', attestationFormChange)
	
	function classSelectChange() {
	    var $this = $(this)
	    var $row = $this.closest('.row-wrap')
	    var $nextSelect = $row.find('.js-subject')
	    var $genderSelectRow = $row.next();
	
	    if (+$this.val() === 1) {
	        $nextSelect.attr("disabled", true).trigger("chosen:updated")
	    } else {
	        $nextSelect.removeAttr('disabled').trigger("chosen:updated")
	    }
	
	    if (+$this.val() === 7 || +$this.val() === 8) {
	        $genderSelectRow.removeClass('hidden');
	    } else {
	        $genderSelectRow.addClass('hidden');
	    }
	}
	
	function addModuleBtnClick() {
	
	    const list = $($(this).attr('data-list-selector'));
	    let counter = list.data('widget-counter') || list.children().length;
	    let newWidget = list.attr('data-prototype');
	
	    newWidget = newWidget.replace(/__name__/g, counter);
	    counter++;
	
	    list.data('widget-counter', counter);
	    const newElem = $(newWidget);
	    newElem.appendTo(list);
	
	    $('.chosen-select').chosen({
	        disable_search_threshold: 10,
	        no_results_text: "Ничего не найдено"
	    });
	    $('.lk-select-scenes .opt').on( 'mouseenter', '.active-result-more-link', chosenResultsMouseEnterMore)
	
	    reshMultiSelect.load('select-sumo-select');
	    reshMultiSelect.run();
	}
	
	function addAttestationFormClick() {
	    $(this).closest('li').remove()
	    const list = $($('.js-add-attestation-btn').attr('data-list-selector'));
	    let counter = list.data('widget-counter') || list.children().length;
	    counter--;
	    list.data('widget-counter', counter);
	    clearErrors()
	}
	
	function customModalSubjectChange() {
	    const $this = $(this)
	    const $row = $this.closest('.row-wrap')
	    const $subject = $row.find('.js-attestation-subject')
	    const $class = $row.find('.js-attestation-class')
	    const selectedSubject = $subject.chosen().val();
	    let $newWidgetElement = $('#attestation-modules-list');
	    let $newWidget = $('#attestation-modules-list').attr('data-prototype');
	    let $newWidgetClassSplit = $newWidget.split('js-attestation-class');
	    let $newWidgetClassSplitClear = $newWidgetClassSplit[1].substring($newWidgetClassSplit[1].indexOf('</select>'));
	    $class.val('').trigger('chosen:updated')
	    let $resultPrototype = '';
	
	    $.get(Routing.generate('private_office_pupil_attestation_classes_query', {
	        'subject_id': selectedSubject ? selectedSubject : null,
	    }), function (data) {
	
	        $class.html(data)
	        $class.trigger('chosen:updated')
	
	        $row.find('.js-attestation-lessons').html(data);
	        $resultPrototype = $newWidgetClassSplit[0] + ' js-attestation-class form-control">' + data + $newWidgetClassSplitClear;
	
	        let $newWidgetLessonSplit = $resultPrototype.split('js-attestation-lessons');
	        let $newWidgetLessonSplitClear = $newWidgetLessonSplit[1].substring($newWidgetLessonSplit[1].indexOf('</select>'));
	        $resultPrototype = $newWidgetLessonSplit[0] + ' js-attestation-lessons form-control"><optopn value="">Урок</optopn>' + $newWidgetLessonSplitClear;
	
	        $($newWidgetElement).attr('data-prototype', $resultPrototype);
	    });
	
	}
	
	function customModalShowingDropdown() {
	    const $this = $(this);
	    if ($this.children('option').length === 0) {
	        loadModuleLessons($this);
	    }
	}
	
	function customModalKeyupChange(e, currentId = '') {
	
	    let $this = $(this)
	    let id = $this.attr('id');
	    let $row = ''
	    let $exercise = ''
	    let lessonId = ''
	    let sceneSelect = ''
	
	    if (id===undefined && currentId) {
	        id = currentId
	        $row = $('#'+currentId).parent().closest('.row-wrap')
	        $exercise = $row.find('.js-attestation-exercise');
	        lessonId = $row.find('.js-attestation-lessons').chosen().val();
	        sceneSelect = $row.find('.js-attestation-scenes')
	    } else {
	        $row = $this.parent().closest('.row-wrap')
	        $exercise = $row.find('.js-attestation-exercise');
	        lessonId = $row.find('.js-attestation-lessons').chosen().val();
	        sceneSelect = $row.find('.js-attestation-scenes')
	    }
	
	    let clearid = id.replace('attestation_modules_', '');
	    clearid = clearid.replace('_scenes', '');
	
	    let exerciseType = '';
	    $exercise.each(function(index, value) {
	        if ($(value).is(':checked')) {
	            exerciseType = $(value).val();
	        }
	    });
	
	    $('.multiselect__dropdown__result__option').each(function(i,el) {
	        let train_id = $(el).find('input').val();
	        let train_id_url = $(el).find('input').val();
	        if ($(el).data('train')) train_id_url = $(el).data('train')
	
	        $(el).find('label a').remove()
	
	        $(el).find('label').append('<a class="active-result-more-link" data-scene-selector="'+sceneSelect.attr('id')+'" data-exercise-type="'+exerciseType+'" data-lesson-id="'+lessonId+'" data-id="'+train_id+'" href="/subject/lesson/'+$('.js-attestation-lessons').val()+'/train/'+train_id_url+'/" target="_blank"><i class="icon icon_glasses"></i></a>');
	    });
	
	    $('.multiselect__dropdown__result__option').on( 'mouseenter', '.active-result-more-link', chosenResultsMouseEnterMore);
	}
	
	function editKeyupChange(el) {
	    let id = $(el).attr('id');
	    let $row = $(el).closest('.row-wrap');
	    $exercise = $row.find('.js-attestation-exercise');
	    lessonId = $row.find('.js-attestation-lessons').chosen().val();
	    sceneSelect = $row.find('.js-attestation-scenes');
	
	    let clearid = id.replace('attestation_modules_', '');
	    clearid = clearid.replace('_scenes', '');
	
	    let exerciseType = '';
	    $exercise.each(function(index, value) {
	        if ($(value).is(':checked')) {
	            exerciseType = $(value).val();
	        }
	    });
	
	    $('.multiselect__dropdown__result__option').each(function(i,el) {
	        let train_id = $(el).find('input').val();
	        let train_id_url = $(el).find('input').val();
	        if ($(el).data('train')) train_id_url = $(el).data('train')
	
	        $(el).find('label a').remove()
	
	        $(el).find('label').append('<a class="active-result-more-link" data-scene-selector="'+sceneSelect.attr('id')+'" data-exercise-type="'+exerciseType+'" data-lesson-id="'+lessonId+'" data-id="'+train_id+'" href="/subject/lesson/'+$('.js-attestation-lessons').val()+'/train/'+train_id_url+'/" target="_blank"><i class="icon icon_glasses"></i></a>');
	    });
	
	    $('.multiselect__dropdown__result__option').on( 'mouseenter', '.active-result-more-link', chosenResultsMouseEnterMore);
	
	}
	
	function chosenResultsMouseEnterMore() {
	    let target = $(this);
	    let popup = $('#active-result-more-popup');
	
	    $.get(Routing.generate('private_office_teacher_attestation_single_scene', {
	        'scene_id': target.data('id'),
	        'exercise_type': target.data('exercise-type'),
	        'lesson_id': target.data('lesson-id'),
	        'scene_selector': target.data('scene-selector'),
	    }), function (data) {
	        popup.show();
	        popup.html(data);
	        $('#js-close-preview').on('click', attestationPreviewClose);
	        $('.active-result').on( 'click', attestationPreviewClose);
	        $('.js-choose-from-preview').on('click', jsChooseFromPreviewClick);
	    });
	}
	
	
	function attestationPreviewClose(e) {
	    e.stopPropagation();
	    let popup = $('#active-result-more-popup');
	    popup.hide();
	    popup.empty();
	}
	
	function chosenResultsLiMouseEnter(e) {
	    let target = $(e.currentTarget);
	    if ( target.data('option-array-index') >= 0 ) {
	        target.addClass('highlighted').next('.active-result-more').addClass('highlighted')
	    } else {
	        target.addClass('highlighted').prev().addClass('highlighted')
	    }
	}
	
	function lkSelectScenesMouseleave() {
	    $('.lk-select-scenes .chosen-results').children('li').removeClass('highlighted')
	}
	
	function customModalLessonsChange(e) {
	    const upBlock = e.target.closest('.js-module');
	    const $this = $(this)
	    const $row = $this.closest('.row-wrap')
	    const $subject = $('.js-attestation-subject')
	    const $class = $('.js-attestation-class')
	    const $scene = $row.find('.js-attestation-scenes')
	    const $exercise = $row.find('.js-attestation-exercise')
	    const sceneSelect = $row.find('.js-attestation-scenes')
	    const lessonId = $row.find('.js-attestation-lessons').chosen().val();
	
	    let current_exercise = '';
	
	    $exercise.each(function(index, value) {
	        if ($(value).is(':checked')) {
	            current_exercise = $(value).val();
	        }
	    });
	
	    const selectedLesson = $this.chosen().val();
	    $.get(Routing.generate('private_office_pupil_attestation_scenes_query', {
	        'lesson_id': selectedLesson ? selectedLesson : null,
	        'exercise_type': current_exercise ? current_exercise : null,
	    }), function (data) {
	        $scene.empty().html(data);
	        reshMultiSelect.remove('select-sumo-select', upBlock.querySelector('.js-attestation-scenes'));
	        reshMultiSelect.load('select-sumo-select', upBlock.querySelector('.js-attestation-scenes'));
	        reshMultiSelect.run();
	        customModalKeyupChange(e, $scene.attr('id'));
	    });
	}
	
	function customModalExerciseChange(e) {
	    const upBlock = e.target.closest('.js-module');
	    const $this = $(this)
	    const $row = $this.closest('.row-wrap')
	    const $subject = $row.find('.js-attestation-subject')
	    const $lesson = $row.find('.js-attestation-lessons')
	    const $class = $row.find('.js-attestation-class')
	    const $scene = $row.find('.js-attestation-scenes')
	    const $exercise = $row.find('.js-attestation-exercise')
	    let current_exercise = '';
	
	    $exercise.each(function(index, value) {
	        if ($(value).is(':checked')) {
	            current_exercise = $(value).val();
	        }
	    });
	
	    const selectedLesson = $lesson.chosen().val();
	    if (selectedLesson) {
	        $.get(Routing.generate('private_office_pupil_attestation_scenes_query', {
	            'lesson_id': selectedLesson ? selectedLesson : null,
	            'exercise_type': current_exercise ? current_exercise : null,
	        }), function (data) {
	            $scene.empty().html(data);
	            reshMultiSelect.remove('select-sumo-select', upBlock.querySelector('.js-attestation-scenes'));
	            reshMultiSelect.load('select-sumo-select', upBlock.querySelector('.js-attestation-scenes'));
	            reshMultiSelect.run();
	            // $scene[0].sumo.reload();
	            customModalKeyupChange(e, $scene.attr('id'));
	
	            //$scene.trigger('chosen:updated')
	
	        });
	    }
	}
	
	$('.custom-modal').on('change', '.js-attestation-exercise', customModalExerciseChange);
	
	function customModalClassChange() {
	    const $this = $(this)
	    loadModuleLessons($this);
	}
	
	function loadModuleLessons(element) {
	    const $row = element.closest('.row-wrap');
	    const $class = $row.find('.js-attestation-class');
	    const $subject = $row.find('.js-attestation-subject');
	    const $topic = $('.js-attestation-lessons');
	    let $newWidgetElement = $('#attestation-modules-list');
	    let $newWidget = $('#attestation-modules-list').attr('data-prototype');
	    let $newWidgetLessonSplit = $newWidget.split('js-attestation-lessons');
	    let $newWidgetLessonSplitClear = $newWidgetLessonSplit[1].substring($newWidgetLessonSplit[1].indexOf('</select>'));
	    let $resultPrototype = '';
	    let exercise = $row.find('.js-attestation-exercise');
	
	    const selectedClass = $class.chosen().val();
	    const selectedClassText = $class.chosen().find('option:selected').text();
	    const selectedSubject = $subject.chosen().val();
	    const selectedSubjectText = $subject.chosen().find('option:selected').text();
	
	    if (selectedClass==1) {
	        $(exercise).each(function(index, value){
	            if (index==0) {
	                $(value).prop("checked", true);
	            } else {
	                $(value).prop("disabled", true);
	            }
	        })
	    } else {
	        $(exercise).each(function(index, value){
	            $(value).prop("disabled", false);
	        })
	    }
	
	    $.get(Routing.generate('private_office_pupil_attestation_lessons_query', {
	        'subject_id': selectedSubject ? selectedSubject : null,
	        'class_id': selectedClass ? selectedClass : null
	    }), function (data) {
	
	        $row.find('.js-attestation-lessons').empty().html(data);
	        $resultPrototype = $newWidgetLessonSplit[0] + ' js-attestation-lessons form-control" data-placeholder="Все уроки">' + data + $newWidgetLessonSplitClear;
	
	        let $SubjectSplit = $resultPrototype.split('js-attestation-subject');
	        let $SubjectSplitCut = $SubjectSplit[1].substring($SubjectSplit[1].indexOf('</select>')).replace('</select>','');
	        let $subjectsList = $SubjectSplit[1].split('</select>');
	        let $subjectsListClear = $subjectsList[0].replace('form-control">','').replace('selected="selected"','');
	        let $newSubjectSplit = $subjectsListClear.split('>'+selectedSubjectText+'<');
	        $subjectsListClear = $newSubjectSplit[0] + ' selected="selected">' + selectedSubjectText + '<' + $newSubjectSplit[1].replace('>'+selectedSubjectText+'<', '');
	        $resultPrototype = $SubjectSplit[0] + ' js-attestation-subject form-control">' + $subjectsListClear + '</select>' + $SubjectSplitCut;
	
	        let $ClassSplit = $resultPrototype.split('js-attestation-class');
	        let $ClassSplitCut = $ClassSplit[1].substring($ClassSplit[1].indexOf('</select>')).replace('</select>','');
	        let $classesList = $ClassSplit[1].split('</select>');
	        let $classesListClear = $classesList[0].replace('form-control">','').replace('selected="selected"','');
	        let $newClassSplit = $classesListClear.split('>'+selectedClassText+'<');
	        $classesListClear = $newClassSplit[0] + ' selected="selected">' + selectedClassText + '<' + $newClassSplit[1].replace('>'+selectedClassText+'<', '');
	        $resultPrototype = $ClassSplit[0] + ' js-attestation-class form-control">' + $classesListClear + '</select>' + $ClassSplitCut;
	
	        $($newWidgetElement).attr('data-prototype', $resultPrototype);
	
	        //$topic.trigger('chosen:updated');
	        $row.find('.js-attestation-lessons').trigger('chosen:updated');
	        $row.find('.js-attestation-scenes').empty();
	        $row.find('.js-attestation-scenes').trigger('chosen:updated');
	    });
	
	}
	
	function handleModule(module) {
	
	    const subjectSelect = module.find('.js-attestation-subject');
	    const classSelect = module.find('.js-attestation-class');
	    const lessonsSelect = module.find(('.select2entity'));
	    const url = lessonsSelect.data('ajax--url');
	
	    module.find('.js-attestation-subject, .js-attestation-class').on('change', function () {
	        const subjectId = subjectSelect.find('option:selected').val();
	        const classId = classSelect.find('option:selected').val();
	        if (subjectId !== "" && classId !== "") {
	            lessonsSelect.data('ajax--url', `${url}&subject_id=${subjectId}&class_id=${classId}`);
	            lessonsSelect.select2({
	                ajax: {
	                    url: lessonsSelect.data('ajax--url')
	                }
	            });
	        }
	    });
	    module.find('.select2entity').select2();
	}
	
	function jsChooseFromPreviewClick(e) {
	
	    let sceneSelector = $(this).data('scene-selector')
	    let sceneId = $(this).data('scene-id')
	    let vals = $('#'+sceneSelector).val()
	
	    if (vals)
	        vals.push(sceneId)
	    else
	        vals = sceneId
	
	     $('#'+sceneSelector).val(vals);
	
	    let index_flag = -1;
	    $('#'+sceneSelector+' option').each(function(index, value){
	        $(vals).each(function(ind_val, value_val) {
	            if ($(value).val()==value_val) {
	                // $(value).attr('selected', 'selected');
	                index_flag = index;
	            }
	        });
	
	        // $('#'+sceneSelector).parent().find('li.opt').each(function(ind_opt, value_opt){
	        $('#'+sceneSelector).parent().find('.multiselect__dropdown__result__option input').each(function(ind_opt, value_opt){
	            if (index_flag==ind_opt) {
	                // if (!$(value_opt).hasClass('selected')) $(value_opt).addClass('selected');
	                value_opt.checked = true;
	            }
	        });
	        index_flag = -1;
	
	    })
	}
	
	function startDateSelect(currentTime,$input) {
	    const endDate = $('#attestation_workEndTime');
	
	    if (endDate.val()) {
	        if (currentTime >= endDate.datetimepicker('getValue')) {
	            endDate.datetimepicker('reset');
	            $('.attestation_workEndTime_err').css('display', 'block');
	        } else {
	            $('.attestation_workEndTime_err').css('display', 'none');
	        }
	    }
	};
	
	function endDateSelect(currentTime,$input) {
	    const startDate = $('#attestation_workStartTime');
	
	    if (startDate.val()) {
	        if (currentTime <= startDate.datetimepicker('getValue')) {
	            $input.datetimepicker('reset');
	            $('.attestation_workEndTime_err').css('display', 'block');
	        } else {
	            $('.attestation_workEndTime_err').css('display', 'none');
	        }
	    }
	}
	
	
	function jsAttestationEditClick(e) {
	    e.preventDefault();
	    e.stopPropagation();
	    const button = $(this);
	    const id = button.data('id');
	    const hasPupils = button.data('has-pupils');
	
	    $.ajax({
	        url: Routing.generate('private_office_teacher_attestation_edit', {'attestation': id}),
	        type: 'GET',
	        success: function (data) {
	            $('#add-attestation-modal').empty().html(data)
	            $('#add-attestation-modal').customModal();
	            $('#add-attestation-modal').customModal('popup');
	            $('.chosen-select').chosen();
	            reshMultiSelect.load('select-sumo-select');
	            reshMultiSelect.run();
	
	            $('.select-sumo-select').each(function(i, el) {
	                editKeyupChange(el);
	            });
	            
	            $('.js-add-attestation-btn').on('click', addModuleBtnClick);
	            $('#add-attestation-modal .js-close-modal').on('click', closeModalClick);
	            $('#add-attestation-modal .js-close-modal-quit').on('click', closeModalQuitClick);
	            $('#add-attestation-modal').on('hide:after', addAttestationModalHide);
	            $('.add-attestation-form').on('click', '.js-delete-module-row', addAttestationFormClick)
	            $('.custom-modal').on('change', '.js-attestation-subject', customModalSubjectChange);
	            $('.custom-modal').on('chosen:showing_dropdown', '.js-attestation-lessons', customModalShowingDropdown);
	            $('.lk-select-scenes .opt').on( 'mouseenter', '.active-result-more-link', chosenResultsMouseEnterMore)
	            $('.lk-select-scenes .chosen-results').on( 'mouseenter', 'li', chosenResultsLiMouseEnter)
	            $('.lk-select-scenes .chosen-results').on( 'mouseleave', 'li', lkSelectScenesMouseleave);
	
	            $('.lk-select-scenes .chosen-results').on( 'input', 'li', function() {
	                $('select.SlectBox')[0].sumo.reload();
	            })
	
	            $('#attestation_workStartTime').datetimepicker({ todayButton: false, step: 5, format: 'd.m.Y, H:i', onSelectTime: startDateSelect });
	            $('#attestation_workEndTime').datetimepicker({ todayButton: false, step: 5, format: 'd.m.Y, H:i', onSelectTime: endDateSelect });
	            $.datetimepicker.setLocale('ru');
	
	            $('.custom-modal').on('change', '.js-attestation-lessons', customModalLessonsChange);
	            $('.custom-modal').on('change', '.js-attestation-class', customModalClassChange)
	            $('#new_individual_test_users').on('focus', newIndividualTestUsers);
	            $('#new_individual_test_groups').on('focus', newIndividualTestGroups);
	            $('.add-attestation-form__lower-btn-row > .lk-form-submit:submit').click(jsAttestationFormSubmit);
	
	            $('.SumoSelect>.optWrapper.multiple>.options li.opt').on( 'mouseenter', '.opt', function() {  debugger })
	            $('.SumoSelect>.optWrapper.multiple>.options li.opt').on( 'mouseenter', '.opt', chosenResultsLiMouseEnter)
	            $('.SumoSelect>.optWrapper.multiple>.options li.opt').on( 'mouseleave', '.opt', lkSelectScenesMouseleave)
	
	            $('.add-attestation-form__wrap').ready(attestationWrap);
	        }
	    })
	}
	$('.js-attestation-edit').click(jsAttestationEditClick);
	
	function attestationWrap() {
	    $('.edit-disable').css('width', (parseInt($('.add-attestation-form__wrap').width())+60)+'px');
	    $('.edit-disable').css('height', (parseInt($('.add-attestation-form__wrap').height())-10)+'px');
	}
	
	
	function jsAttestationAddClick(e) {
	    e.preventDefault();
	    e.stopPropagation();
	
	    $.ajax({
	        url: Routing.generate('private_office_teacher_attestation_add', {'control': $(this).data('control')}),
	        type: 'GET',
	        success: function (data) {
	            $('#add-attestation-modal').empty().html(data)
	            $('.chosen-select').chosen();
	            reshMultiSelect.load('select-sumo-select');
	            reshMultiSelect.run();
	            
	            $('.js-add-attestation-btn').on('click', addModuleBtnClick);
	            $('#add-attestation-modal .js-close-modal').on('click', closeModalClick);
	            $('#add-attestation-modal .js-close-modal-quit').on('click', closeModalQuitClick);
	            $('#add-attestation-modal').on('hide:after', addAttestationModalHide);
	            $('.js-class-select').chosen().change(classSelectChange)
	            $('.add-attestation-form').on('click', '.js-delete-module-row', addAttestationFormClick)
	            $('.custom-modal').on('change', '.js-attestation-subject', customModalSubjectChange);
	            $('.custom-modal').on('chosen:showing_dropdown', '.js-attestation-lessons', customModalShowingDropdown);
	            $('.custom-modal__content-center').on('chosen:showing_dropdown keyup change', '.js-attestation-scenes', customModalKeyupChange);
	            $('.lk-select-scenes .opt').on( 'mouseenter', '.active-result-more-link', chosenResultsMouseEnterMore)
	            $('.lk-select-scenes .chosen-results').on( 'mouseenter', 'li', chosenResultsLiMouseEnter)
	            $('.lk-select-scenes .chosen-results').on( 'mouseleave', 'li', lkSelectScenesMouseleave)
	
	            $('.lk-select-scenes .chosen-results').on( 'input', 'li', function() {
	                $('select.SlectBox')[0].sumo.reload();
	            })
	            
	            $('#attestation_workStartTime').datetimepicker({ todayButton: false, step: 5, format: 'd.m.Y, H:i', onSelectTime: startDateSelect });
	            $('#attestation_workEndTime').datetimepicker({ todayButton: false, step: 5, format: 'd.m.Y, H:i', onSelectTime: endDateSelect });
	            $.datetimepicker.setLocale('ru');
	
	            $('.custom-modal').on('change', '.js-attestation-lessons', customModalLessonsChange);
	            $('.custom-modal').on('change', '.js-attestation-class', customModalClassChange)
	            $('#new_individual_test_users').on('focus', newIndividualTestUsers);
	            $('#new_individual_test_groups').on('focus', newIndividualTestGroups);
	            $('.add-attestation-form__lower-btn-row > .lk-form-submit:submit').click(jsAttestationFormSubmit);
	
	            $('.SumoSelect>.optWrapper.multiple>.options li.opt').on( 'mouseenter', '.opt', chosenResultsMouseEnterMore)
	            $('.SumoSelect>.optWrapper.multiple>.options li.opt').on( 'mouseenter', '.opt', chosenResultsLiMouseEnter)
	            $('.SumoSelect>.optWrapper.multiple>.options li.opt').on( 'mouseleave', '.opt', lkSelectScenesMouseleave)
	        }
	    })
	}
	$('#add-attestation-button').click(jsAttestationAddClick);
	
	function jsAttestationFormSubmit(e) {
	    let valid = false
	    let errors = 0
	    let errorBlock = $('.add-attestation-form__errors-block'),
	        titleBlock = $('#attestation_title'),
	        timeInput = $('#attestation_workTime'),
	        requiredTimeInp = timeInput.attr( 'required' ),
	        workStartTimeInput = $('#attestation_workStartTime'),
	        requiredworkStartTimeInp = workStartTimeInput.attr( 'required' ),
	        workEndTimeInput = $('#attestation_workEndTime'),
	        requiredworkEndTimeInp = workEndTimeInput.attr( 'required' );
	
	    if (!titleBlock.val()) {
	        titleBlock.addClass( 'add-attestation-error-class');
	        errors++;
	    } else {
	        titleBlock.removeClass( 'add-attestation-error-class')
	    }
	
	    titleBlock.on('change', function() {
	        if (!titleBlock.val()) {
	            errors++;
	            titleBlock.addClass( 'add-attestation-error-class');
	        } else {
	            titleBlock.removeClass( 'add-attestation-error-class');
	        }
	    })
	
	    if (requiredTimeInp) {
	        if( !timeInput.val() || timeInput.val() == '0') {
	            errors++;
	            timeInput.addClass( 'add-attestation-error-class');
	        } else {
	            timeInput.removeClass( 'add-attestation-error-class')
	        }
	    } else {
	        timeInput.removeClass( 'add-attestation-error-class')
	    }
	    timeInput.on('change', function() {
	        if (!timeInput.val()) {
	            errors++;
	            timeInput.addClass( 'add-attestation-error-class');
	        } else {
	            timeInput.removeClass( 'add-attestation-error-class');
	        }
	    })
	
	
	
	    if (requiredworkStartTimeInp) {
	        if( !workStartTimeInput.val() || workStartTimeInput.val() == '0') {
	            errors++;
	            workStartTimeInput.addClass( 'add-attestation-error-class');
	        } else {
	            workStartTimeInput.removeClass( 'add-attestation-error-class')
	        }
	    } else {
	        workStartTimeInput.removeClass( 'add-attestation-error-class')
	    }
	    workStartTimeInput.on('change', function() {
	        if (!workStartTimeInput.val()) {
	            errors++;
	            workStartTimeInput.addClass( 'add-attestation-error-class');
	        } else {
	            workStartTimeInput.removeClass( 'add-attestation-error-class');
	        }
	    })
	
	    if (requiredworkEndTimeInp) {
	        if( !workEndTimeInput.val() || workEndTimeInput.val() == '0') {
	            errors++;
	            workEndTimeInput.addClass( 'add-attestation-error-class');
	        } else {
	            workEndTimeInput.removeClass( 'add-attestation-error-class')
	        }
	    } else {
	        workEndTimeInput.removeClass( 'add-attestation-error-class')
	    }
	    workEndTimeInput.on('change', function() {
	        if (!workEndTimeInput.val()) {
	            errors++;
	            workEndTimeInput.addClass( 'add-attestation-error-class');
	        } else {
	            workEndTimeInput.removeClass( 'add-attestation-error-class');
	        }
	    })
	
	    if (workStartTimeInput.val() && workEndTimeInput.val()) {
	        if (workStartTimeInput.val() > workEndTimeInput.val()) {
	            errors++;
	            workEndTimeInput.addClass( 'add-attestation-error-class');
	            $('.attestation_workEndTime_err').css('display', 'block');
	        } else {
	            workEndTimeInput.removeClass( 'add-attestation-error-class');
	            $('.attestation_workEndTime_err').css('display', 'none');
	        }
	    }
	
	    let all_scenes = []
	
	    $('.row-wrap').each(function(index,item) {
	
	        let subject = $(item).find('.js-attestation-subject')
	        let school_class = $(item).find('.js-attestation-class')
	        let lesson = $(item).find('.js-attestation-lessons')
	        let scene = $(item).find('.js-attestation-scenes')
	        let exercise = $(item).find('.js-attestation-exercise:checked')
	        let selected_scenes = $(item).find('.opt.selected')
	
	            let sub = getValidField(subject),
	                sch = getValidField(school_class),
	                les = getValidField(lesson),
	                sc = getValidField(scene);
	
	            if ( sub || sch || les || sc ) {
	                errors++;
	            }
	        if (scene.val()) {
	            $(scene.val()).each(function(i,sel_item) {
	                all_scenes.push(subject.val()+'_'+school_class.val()+'_'+lesson.val()+'_'+exercise.val()+'_'+sel_item)
	            })
	
	        }
	    })
	
	    $('#scenes_all').val(all_scenes.join())
	
	    if (errors > 0) {
	        errorBlock.html('Заполнены не все обязательные поля');
	    } else {
	        valid = true
	    }
	
	    if (valid == false)
	        return false;
	}
	
	function getValidField( field ) {
	    let error = 0;
	    if (!field.val()) {
	        error++
	        field.parents('.lk-select').addClass( 'add-attestation-error-class');
	    } else { field.parents('.lk-select').removeClass( 'add-attestation-error-class'); error = 0 }
	
	    field.on('change', function() {
	        if (!field.val()) {
	            error++;
	            field.parents('.lk-select').addClass( 'add-attestation-error-class');
	        } else { field.parents('.lk-select').removeClass( 'add-attestation-error-class'); error = 0; $('.add-attestation-form__errors-block').html(''); }
	    })
	
	    return error
	}
	
	function jsAttestationDeleteClick(e) {
	    e.preventDefault();
	    e.stopPropagation();
	    const button = $(this);
	    const id = button.data('id');
	    const hasPupils = button.data('has-pupils');
	
	    let warningText = '';
	    if (hasPupils === 1) {
	        warningText = getMessageText('delete_teacher_with_pupils');
	
	        Swal.fire({
	            cancelButtonColor: '#3085d6',
	            confirmButtonColor: '#fb5e3a',
	            reverseButtons: true,
	            focusCancel: true,
	            showCancelButton: true,
	            html: warningText,
	            confirmButtonText: 'Удалить',
	            cancelButtonText: 'Отмена',
	            footer: '<button type="button" class="swal2-cancel swal2-styled swal2-cancel-custom" aria-label="" style="display: inline-block; border-left-color: rgb(48, 133, 214); border-right-color: rgb(48, 133, 214);">Отмена</button>'
	        }).then((result) => {
	            if (result.value === true) {
	                $.ajax({
	                    url: Routing.generate('private_office_teacher_attestation_delete', {'attestation': id}),
	                    type: 'POST',
	                    success: function (result) {
	                        window.location.reload();
	                    }
	                })
	            }
	        });
	        $('.swal2-cancel-custom').click(function () {
	            Swal.close();
	        })
	    } else {
	        warningText = getMessageText('delete');
	
	        Swal.fire({
	            showCancelButton: true,
	            html: warningText,
	            confirmButtonText: 'Да',
	            cancelButtonText: 'Нет',
	        }).then((result) => {
	            if (result.value === true) {
	                $.ajax({
	                    url: Routing.generate('private_office_teacher_attestation_delete', {'attestation': id}),
	                    type: 'POST',
	                    success: function (result) {
	                        window.location.reload();
	                    }
	                })
	            }
	        });
	    }
	}
	
	$('.js-attestation-delete').click(jsAttestationDeleteClick);
	
	function jsAttestationDeleteStartedClick(e) {
	    e.preventDefault();
	    e.stopPropagation();
	
	    Swal.fire({
	        title: 'Удаление работы',
	        text: 'Наступило время выполнения работы. Удаление невозможно.'
	    });
	
	}
	
	$('.js-attestation-delete-started').click(jsAttestationDeleteStartedClick);
	
	function newIndividualTestUsers(e) {
	    $("#attestation_userType_0").prop("checked", true);
	}
	
	function newIndividualTestGroups(e) {
	    $("#attestation_userType_1").prop("checked", true);
	}
	
	function clearErrors() {
	    $('.add-attestation-form__errors-block, .module-row__errors-block, .add-attestation-form__errors-row').html('');
	}
	
	function resultsDeleteBtnClick() {
	    const btn = $(this);
	    const groupData = [];
	    const pupilData = [];
	    const checkboxes = $('.timetable-results__table').find('.js-timetable-results-table-checkbox:checked');
	    checkboxes.each((index, checkbox) => {
	        const $checkbox = $(checkbox)
	        if ($checkbox.data('type') === 'group') {
	            groupData.push($checkbox.data('id'));
	        } else if ($checkbox.data('type') === 'pupil') {
	            pupilData.push($checkbox.data('id'));
	        }
	    });
	    ajaxButtonPost(
	        Routing.generate('private_office_pupil_timetable_remove_pupils', {'userCourse': btn.data('user-course')}),
	        {'groups': groupData, 'pupils': pupilData},
	        btn,
	        (result) => {
	            if (result.result === 'success') {
	                Swal.fire({
	                    title: result.title,
	                    text: result.message
	                }).then(() => {
	                    window.location.reload();
	                })
	            } else if (result.result === 'error') {
	                Swal.fire({
	                    title: 'Удаление из траектории',
	                    text: `Не удалось отзязать учетные записи.`
	                }).then(() => {
	                    window.location.reload();
	                })
	            }
	        }
	    );
	}
	
	$('.js-attestation-results-delete-btn').click(resultsDeleteBtnClick);
	
	function attestationCommentBtnClick() {
	    let attestation_assessment = $('#attestation_assessment').val()
	    let attestation_comment = $('#attestation_comment').val()
	    let attestationId = $('#attestationId').val()
	    let current_assessment = $('#current_assessment').val()
	    let assessment_recommended = $('#assessment_recommended').val()
	    let userWork = $('#userWork').val()
	    let postdata = 'attestation_assessment='+attestation_assessment+'&attestation_comment='+attestation_comment+'&attestationId='+attestationId+'&userWork='+userWork;
	
	    $.ajax({
	        url: Routing.generate('private_office_teacher_attestation_pupil_work_edit'),
	        data: postdata,
	        type: 'POST',
	        success: function (data) {
	                Swal.fire({
	                    title: 'Сохранение',
	                    text: `Данные успешно сохранены.`
	                }).then((result) => {
	                    location.href = '/office/user/attestation/detail_by_pupil/'+attestationId+'/'
	                });
	        }
	    })
	}
	$('#attestation_comment_submit').click(attestationCommentBtnClick);
	
	function closeModalClick() {
	    let $target = $('#add-attestation-modal');
	
	    Swal.fire({
	        title: '<strong>Внимание!</strong>',
	        html: 'При закрытии окна все введенные вами данные будут утеряны! Вы действительно хотите выйти?',
	        showCloseButton: true,
	        showCancelButton: true,
	        focusConfirm: false,
	        confirmButtonText: 'Да',
	        confirmButtonAriaLabel: 'Да',
	        cancelButtonText: 'Отмена',
	        cancelButtonAriaLabel: 'Отмена'
	    }).then((result) => {
	        if (result.value===true || result===true) {
	            if ($target.length) {
	                $target.addClass('js-hide')
	                setTimeout(function () {
	                    $target.removeClass('js-shown js-modal-animation js-hide')
	                    $('body').css({overflowY: '', paddingRight: ''})
	                    if (typeof callback === "function") {
	                        callback()
	                    }
	                    $target.trigger('hide:after')
	                    $('#add-attestation-modal').empty()
	                }, 500)
	            }
	            if (typeof callback === "function") {
	                callback()
	            }
	        }
	    });
	}
	
	
	function changeAttestationSort() {
	    let href = $(this).data('href');
	    let control = $(this).data('control');
	    if (control==1)
	        location.href = href+'?control=1&order='+$(this).val();
	    else
	        location.href = href+'?order='+$(this).val();
	}
	$('#attestation_sort').on('change', changeAttestationSort);
	
	
	function closeModalQuitClick() {
	    let $target = $('#add-attestation-modal');
	
	    if ($target.length) {
	        $target.addClass('js-hide')
	        setTimeout(function () {
	            $target.removeClass('js-shown js-modal-animation js-hide')
	            $('body').css({overflowY: '', paddingRight: ''})
	            if (typeof callback === "function") {
	                callback()
	            }
	            $target.trigger('hide:after')
	            $('#add-attestation-modal').empty()
	        }, 500)
	    }
	}
	
	function addAttestationModalClick() {
	
	    var $target = $(this);
	
	    Swal.fire({
	        title: '<strong>Внимание!</strong>',
	        html: 'При закрытии окна, все введенные вами данные будут утеряны! Вы действительно хотите выйти?',
	        showCloseButton: true,
	        showCancelButton: true,
	        focusConfirm: false,
	        confirmButtonText: 'Да, закрыть',
	        confirmButtonAriaLabel: 'Да, закрыть',
	        cancelButtonText: 'Отмена',
	        cancelButtonAriaLabel: 'Отмена'
	    }).then((result) => {
	        if (result.value===true || result===true) {
	            if ($target.length) {
	                $target.addClass('js-hide')
	                setTimeout(function () {
	                    $target.removeClass('js-shown js-modal-animation js-hide')
	                    $('body').css({overflowY: '', paddingRight: ''})
	                    if (typeof callback === "function") {
	                        callback()
	                    }
	                    $target.trigger('hide:after')
	                }, 500)
	            }
	            if (typeof callback === "function") {
	                callback()
	            }
	        }
	    });
	}
	
	function addAttestationModalHide() {
	    $('.js-form-type-switch[value="default"]').trigger('click').trigger('change');
	    $('.chosen-select option:selected').removeAttr('selected');
	    $('.chosen-select').trigger('chosen:updated');
	    $('.js-module:not(:first-of-type)').remove();
	    $('#attestation-modules-list').data('widget-counter', 1);
	}
	
	function subjectSelectChange() {
	    const value = $(this).val()
	    const $subjects = $('.js-attestation-subject');
	    if (value === 'all') {
	        $subjects.show();
	        return;
	    }
	    const $current = $('.js-attestation-subject[data-subject-id=' + value + ']');
	    if ($current.length > 0) {
	        $subjects.hide();
	        $current.show();
	    }
	}
	
	$('.js-attestation-subject-select').on('change', subjectSelectChange);
	
	function getMessageText(key, courseName) {
	    const messages = {
	        'delete': `Вы точно хотите удалить задание?`,
	        'delete_teacher_with_pupils': `Вы точно хотите удалить траекторию? Она назначена для изучения ученикам. 
	        Полное её удаление приведет к потере связей. 
	        Для их сохранения можно перевести траекторию в категорию «Завершенные», при этом у всех учеников её категория также изменится`,
	        'finish_control': 'Вы уверены, что хотите завершить выполнение работы? Вы не сможете пройти ее повторно.'
	    }
	
	    return messages[key];
	}

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

	/*!
	* sweetalert2 v8.19.0
	* Released under the MIT License.
	*/
	(function (global, factory) {
		 true ? module.exports = factory() :
		typeof define === 'function' && define.amd ? define(factory) :
		(global.Sweetalert2 = factory());
	}(this, (function () { 'use strict';
	
	function _typeof(obj) {
	  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
	    _typeof = function (obj) {
	      return typeof obj;
	    };
	  } else {
	    _typeof = function (obj) {
	      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
	    };
	  }
	
	  return _typeof(obj);
	}
	
	function _classCallCheck(instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	}
	
	function _defineProperties(target, props) {
	  for (var i = 0; i < props.length; i++) {
	    var descriptor = props[i];
	    descriptor.enumerable = descriptor.enumerable || false;
	    descriptor.configurable = true;
	    if ("value" in descriptor) descriptor.writable = true;
	    Object.defineProperty(target, descriptor.key, descriptor);
	  }
	}
	
	function _createClass(Constructor, protoProps, staticProps) {
	  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
	  if (staticProps) _defineProperties(Constructor, staticProps);
	  return Constructor;
	}
	
	function _extends() {
	  _extends = Object.assign || function (target) {
	    for (var i = 1; i < arguments.length; i++) {
	      var source = arguments[i];
	
	      for (var key in source) {
	        if (Object.prototype.hasOwnProperty.call(source, key)) {
	          target[key] = source[key];
	        }
	      }
	    }
	
	    return target;
	  };
	
	  return _extends.apply(this, arguments);
	}
	
	function _inherits(subClass, superClass) {
	  if (typeof superClass !== "function" && superClass !== null) {
	    throw new TypeError("Super expression must either be null or a function");
	  }
	
	  subClass.prototype = Object.create(superClass && superClass.prototype, {
	    constructor: {
	      value: subClass,
	      writable: true,
	      configurable: true
	    }
	  });
	  if (superClass) _setPrototypeOf(subClass, superClass);
	}
	
	function _getPrototypeOf(o) {
	  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
	    return o.__proto__ || Object.getPrototypeOf(o);
	  };
	  return _getPrototypeOf(o);
	}
	
	function _setPrototypeOf(o, p) {
	  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
	    o.__proto__ = p;
	    return o;
	  };
	
	  return _setPrototypeOf(o, p);
	}
	
	function isNativeReflectConstruct() {
	  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
	  if (Reflect.construct.sham) return false;
	  if (typeof Proxy === "function") return true;
	
	  try {
	    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
	    return true;
	  } catch (e) {
	    return false;
	  }
	}
	
	function _construct(Parent, args, Class) {
	  if (isNativeReflectConstruct()) {
	    _construct = Reflect.construct;
	  } else {
	    _construct = function _construct(Parent, args, Class) {
	      var a = [null];
	      a.push.apply(a, args);
	      var Constructor = Function.bind.apply(Parent, a);
	      var instance = new Constructor();
	      if (Class) _setPrototypeOf(instance, Class.prototype);
	      return instance;
	    };
	  }
	
	  return _construct.apply(null, arguments);
	}
	
	function _assertThisInitialized(self) {
	  if (self === void 0) {
	    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	  }
	
	  return self;
	}
	
	function _possibleConstructorReturn(self, call) {
	  if (call && (typeof call === "object" || typeof call === "function")) {
	    return call;
	  }
	
	  return _assertThisInitialized(self);
	}
	
	function _superPropBase(object, property) {
	  while (!Object.prototype.hasOwnProperty.call(object, property)) {
	    object = _getPrototypeOf(object);
	    if (object === null) break;
	  }
	
	  return object;
	}
	
	function _get(target, property, receiver) {
	  if (typeof Reflect !== "undefined" && Reflect.get) {
	    _get = Reflect.get;
	  } else {
	    _get = function _get(target, property, receiver) {
	      var base = _superPropBase(target, property);
	
	      if (!base) return;
	      var desc = Object.getOwnPropertyDescriptor(base, property);
	
	      if (desc.get) {
	        return desc.get.call(receiver);
	      }
	
	      return desc.value;
	    };
	  }
	
	  return _get(target, property, receiver || target);
	}
	
	var consolePrefix = 'SweetAlert2:';
	/**
	 * Filter the unique values into a new array
	 * @param arr
	 */
	
	var uniqueArray = function uniqueArray(arr) {
	  var result = [];
	
	  for (var i = 0; i < arr.length; i++) {
	    if (result.indexOf(arr[i]) === -1) {
	      result.push(arr[i]);
	    }
	  }
	
	  return result;
	};
	/**
	 * Returns the array ob object values (Object.values isn't supported in IE11)
	 * @param obj
	 */
	
	var objectValues = function objectValues(obj) {
	  return Object.keys(obj).map(function (key) {
	    return obj[key];
	  });
	};
	/**
	 * Convert NodeList to Array
	 * @param nodeList
	 */
	
	var toArray = function toArray(nodeList) {
	  return Array.prototype.slice.call(nodeList);
	};
	/**
	 * Standardise console warnings
	 * @param message
	 */
	
	var warn = function warn(message) {
	  console.warn("".concat(consolePrefix, " ").concat(message));
	};
	/**
	 * Standardise console errors
	 * @param message
	 */
	
	var error = function error(message) {
	  console.error("".concat(consolePrefix, " ").concat(message));
	};
	/**
	 * Private global state for `warnOnce`
	 * @type {Array}
	 * @private
	 */
	
	var previousWarnOnceMessages = [];
	/**
	 * Show a console warning, but only if it hasn't already been shown
	 * @param message
	 */
	
	var warnOnce = function warnOnce(message) {
	  if (!(previousWarnOnceMessages.indexOf(message) !== -1)) {
	    previousWarnOnceMessages.push(message);
	    warn(message);
	  }
	};
	/**
	 * Show a one-time console warning about deprecated params/methods
	 */
	
	var warnAboutDepreation = function warnAboutDepreation(deprecatedParam, useInstead) {
	  warnOnce("\"".concat(deprecatedParam, "\" is deprecated and will be removed in the next major release. Please use \"").concat(useInstead, "\" instead."));
	};
	/**
	 * If `arg` is a function, call it (with no arguments or context) and return the result.
	 * Otherwise, just pass the value through
	 * @param arg
	 */
	
	var callIfFunction = function callIfFunction(arg) {
	  return typeof arg === 'function' ? arg() : arg;
	};
	var isPromise = function isPromise(arg) {
	  return arg && Promise.resolve(arg) === arg;
	};
	
	var DismissReason = Object.freeze({
	  cancel: 'cancel',
	  backdrop: 'backdrop',
	  close: 'close',
	  esc: 'esc',
	  timer: 'timer'
	});
	
	var argsToParams = function argsToParams(args) {
	  var params = {};
	
	  switch (_typeof(args[0])) {
	    case 'object':
	      _extends(params, args[0]);
	
	      break;
	
	    default:
	      ['title', 'html', 'type'].forEach(function (name, index) {
	        switch (_typeof(args[index])) {
	          case 'string':
	            params[name] = args[index];
	            break;
	
	          case 'undefined':
	            break;
	
	          default:
	            error("Unexpected type of ".concat(name, "! Expected \"string\", got ").concat(_typeof(args[index])));
	        }
	      });
	  }
	
	  return params;
	};
	
	var swalPrefix = 'swal2-';
	var prefix = function prefix(items) {
	  var result = {};
	
	  for (var i in items) {
	    result[items[i]] = swalPrefix + items[i];
	  }
	
	  return result;
	};
	var swalClasses = prefix(['container', 'shown', 'height-auto', 'iosfix', 'popup', 'modal', 'no-backdrop', 'toast', 'toast-shown', 'toast-column', 'show', 'hide', 'noanimation', 'close', 'title', 'header', 'content', 'actions', 'confirm', 'cancel', 'footer', 'icon', 'image', 'input', 'file', 'range', 'select', 'radio', 'checkbox', 'label', 'textarea', 'inputerror', 'validation-message', 'progress-steps', 'active-progress-step', 'progress-step', 'progress-step-line', 'loading', 'styled', 'top', 'top-start', 'top-end', 'top-left', 'top-right', 'center', 'center-start', 'center-end', 'center-left', 'center-right', 'bottom', 'bottom-start', 'bottom-end', 'bottom-left', 'bottom-right', 'grow-row', 'grow-column', 'grow-fullscreen', 'rtl']);
	var iconTypes = prefix(['success', 'warning', 'info', 'question', 'error']);
	
	var states = {
	  previousBodyPadding: null
	};
	var hasClass = function hasClass(elem, className) {
	  return elem.classList.contains(className);
	};
	
	var removeCustomClasses = function removeCustomClasses(elem) {
	  toArray(elem.classList).forEach(function (className) {
	    if (!(objectValues(swalClasses).indexOf(className) !== -1) && !(objectValues(iconTypes).indexOf(className) !== -1)) {
	      elem.classList.remove(className);
	    }
	  });
	};
	
	var applyCustomClass = function applyCustomClass(elem, customClass, className) {
	  removeCustomClasses(elem);
	
	  if (customClass && customClass[className]) {
	    if (typeof customClass[className] !== 'string' && !customClass[className].forEach) {
	      return warn("Invalid type of customClass.".concat(className, "! Expected string or iterable object, got \"").concat(_typeof(customClass[className]), "\""));
	    }
	
	    addClass(elem, customClass[className]);
	  }
	};
	function getInput(content, inputType) {
	  if (!inputType) {
	    return null;
	  }
	
	  switch (inputType) {
	    case 'select':
	    case 'textarea':
	    case 'file':
	      return getChildByClass(content, swalClasses[inputType]);
	
	    case 'checkbox':
	      return content.querySelector(".".concat(swalClasses.checkbox, " input"));
	
	    case 'radio':
	      return content.querySelector(".".concat(swalClasses.radio, " input:checked")) || content.querySelector(".".concat(swalClasses.radio, " input:first-child"));
	
	    case 'range':
	      return content.querySelector(".".concat(swalClasses.range, " input"));
	
	    default:
	      return getChildByClass(content, swalClasses.input);
	  }
	}
	var focusInput = function focusInput(input) {
	  input.focus(); // place cursor at end of text in text input
	
	  if (input.type !== 'file') {
	    // http://stackoverflow.com/a/2345915
	    var val = input.value;
	    input.value = '';
	    input.value = val;
	  }
	};
	var toggleClass = function toggleClass(target, classList, condition) {
	  if (!target || !classList) {
	    return;
	  }
	
	  if (typeof classList === 'string') {
	    classList = classList.split(/\s+/).filter(Boolean);
	  }
	
	  classList.forEach(function (className) {
	    if (target.forEach) {
	      target.forEach(function (elem) {
	        condition ? elem.classList.add(className) : elem.classList.remove(className);
	      });
	    } else {
	      condition ? target.classList.add(className) : target.classList.remove(className);
	    }
	  });
	};
	var addClass = function addClass(target, classList) {
	  toggleClass(target, classList, true);
	};
	var removeClass = function removeClass(target, classList) {
	  toggleClass(target, classList, false);
	};
	var getChildByClass = function getChildByClass(elem, className) {
	  for (var i = 0; i < elem.childNodes.length; i++) {
	    if (hasClass(elem.childNodes[i], className)) {
	      return elem.childNodes[i];
	    }
	  }
	};
	var applyNumericalStyle = function applyNumericalStyle(elem, property, value) {
	  if (value || parseInt(value) === 0) {
	    elem.style[property] = typeof value === 'number' ? value + 'px' : value;
	  } else {
	    elem.style.removeProperty(property);
	  }
	};
	var show = function show(elem) {
	  var display = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'flex';
	  elem.style.opacity = '';
	  elem.style.display = display;
	};
	var hide = function hide(elem) {
	  elem.style.opacity = '';
	  elem.style.display = 'none';
	};
	var toggle = function toggle(elem, condition, display) {
	  condition ? show(elem, display) : hide(elem);
	}; // borrowed from jquery $(elem).is(':visible') implementation
	
	var isVisible = function isVisible(elem) {
	  return !!(elem && (elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length));
	};
	var isScrollable = function isScrollable(elem) {
	  return !!(elem.scrollHeight > elem.clientHeight);
	}; // borrowed from https://stackoverflow.com/a/46352119
	
	var hasCssAnimation = function hasCssAnimation(elem) {
	  var style = window.getComputedStyle(elem);
	  var animDuration = parseFloat(style.getPropertyValue('animation-duration') || '0');
	  var transDuration = parseFloat(style.getPropertyValue('transition-duration') || '0');
	  return animDuration > 0 || transDuration > 0;
	};
	var contains = function contains(haystack, needle) {
	  if (typeof haystack.contains === 'function') {
	    return haystack.contains(needle);
	  }
	};
	
	var getContainer = function getContainer() {
	  return document.body.querySelector('.' + swalClasses.container);
	};
	var elementBySelector = function elementBySelector(selectorString) {
	  var container = getContainer();
	  return container ? container.querySelector(selectorString) : null;
	};
	
	var elementByClass = function elementByClass(className) {
	  return elementBySelector('.' + className);
	};
	
	var getPopup = function getPopup() {
	  return elementByClass(swalClasses.popup);
	};
	var getIcons = function getIcons() {
	  var popup = getPopup();
	  return toArray(popup.querySelectorAll('.' + swalClasses.icon));
	};
	var getIcon = function getIcon() {
	  var visibleIcon = getIcons().filter(function (icon) {
	    return isVisible(icon);
	  });
	  return visibleIcon.length ? visibleIcon[0] : null;
	};
	var getTitle = function getTitle() {
	  return elementByClass(swalClasses.title);
	};
	var getContent = function getContent() {
	  return elementByClass(swalClasses.content);
	};
	var getImage = function getImage() {
	  return elementByClass(swalClasses.image);
	};
	var getProgressSteps = function getProgressSteps() {
	  return elementByClass(swalClasses['progress-steps']);
	};
	var getValidationMessage = function getValidationMessage() {
	  return elementByClass(swalClasses['validation-message']);
	};
	var getConfirmButton = function getConfirmButton() {
	  return elementBySelector('.' + swalClasses.actions + ' .' + swalClasses.confirm);
	};
	var getCancelButton = function getCancelButton() {
	  return elementBySelector('.' + swalClasses.actions + ' .' + swalClasses.cancel);
	};
	var getActions = function getActions() {
	  return elementByClass(swalClasses.actions);
	};
	var getHeader = function getHeader() {
	  return elementByClass(swalClasses.header);
	};
	var getFooter = function getFooter() {
	  return elementByClass(swalClasses.footer);
	};
	var getCloseButton = function getCloseButton() {
	  return elementByClass(swalClasses.close);
	}; // https://github.com/jkup/focusable/blob/master/index.js
	
	var focusable = "\n  a[href],\n  area[href],\n  input:not([disabled]),\n  select:not([disabled]),\n  textarea:not([disabled]),\n  button:not([disabled]),\n  iframe,\n  object,\n  embed,\n  [tabindex=\"0\"],\n  [contenteditable],\n  audio[controls],\n  video[controls],\n  summary\n";
	var getFocusableElements = function getFocusableElements() {
	  var focusableElementsWithTabindex = toArray(getPopup().querySelectorAll('[tabindex]:not([tabindex="-1"]):not([tabindex="0"])')) // sort according to tabindex
	  .sort(function (a, b) {
	    a = parseInt(a.getAttribute('tabindex'));
	    b = parseInt(b.getAttribute('tabindex'));
	
	    if (a > b) {
	      return 1;
	    } else if (a < b) {
	      return -1;
	    }
	
	    return 0;
	  });
	  var otherFocusableElements = toArray(getPopup().querySelectorAll(focusable)).filter(function (el) {
	    return el.getAttribute('tabindex') !== '-1';
	  });
	  return uniqueArray(focusableElementsWithTabindex.concat(otherFocusableElements)).filter(function (el) {
	    return isVisible(el);
	  });
	};
	var isModal = function isModal() {
	  return !isToast() && !document.body.classList.contains(swalClasses['no-backdrop']);
	};
	var isToast = function isToast() {
	  return document.body.classList.contains(swalClasses['toast-shown']);
	};
	var isLoading = function isLoading() {
	  return getPopup().hasAttribute('data-loading');
	};
	
	// Detect Node env
	var isNodeEnv = function isNodeEnv() {
	  return typeof window === 'undefined' || typeof document === 'undefined';
	};
	
	var sweetHTML = "\n <div aria-labelledby=\"".concat(swalClasses.title, "\" aria-describedby=\"").concat(swalClasses.content, "\" class=\"").concat(swalClasses.popup, "\" tabindex=\"-1\">\n   <div class=\"").concat(swalClasses.header, "\">\n     <ul class=\"").concat(swalClasses['progress-steps'], "\"></ul>\n     <div class=\"").concat(swalClasses.icon, " ").concat(iconTypes.error, "\">\n       <span class=\"swal2-x-mark\"><span class=\"swal2-x-mark-line-left\"></span><span class=\"swal2-x-mark-line-right\"></span></span>\n     </div>\n     <div class=\"").concat(swalClasses.icon, " ").concat(iconTypes.question, "\"></div>\n     <div class=\"").concat(swalClasses.icon, " ").concat(iconTypes.warning, "\"></div>\n     <div class=\"").concat(swalClasses.icon, " ").concat(iconTypes.info, "\"></div>\n     <div class=\"").concat(swalClasses.icon, " ").concat(iconTypes.success, "\">\n       <div class=\"swal2-success-circular-line-left\"></div>\n       <span class=\"swal2-success-line-tip\"></span> <span class=\"swal2-success-line-long\"></span>\n       <div class=\"swal2-success-ring\"></div> <div class=\"swal2-success-fix\"></div>\n       <div class=\"swal2-success-circular-line-right\"></div>\n     </div>\n     <img class=\"").concat(swalClasses.image, "\" />\n     <h2 class=\"").concat(swalClasses.title, "\" id=\"").concat(swalClasses.title, "\"></h2>\n     <button type=\"button\" class=\"").concat(swalClasses.close, "\"></button>\n   </div>\n   <div class=\"").concat(swalClasses.content, "\">\n     <div id=\"").concat(swalClasses.content, "\"></div>\n     <input class=\"").concat(swalClasses.input, "\" />\n     <input type=\"file\" class=\"").concat(swalClasses.file, "\" />\n     <div class=\"").concat(swalClasses.range, "\">\n       <input type=\"range\" />\n       <output></output>\n     </div>\n     <select class=\"").concat(swalClasses.select, "\"></select>\n     <div class=\"").concat(swalClasses.radio, "\"></div>\n     <label for=\"").concat(swalClasses.checkbox, "\" class=\"").concat(swalClasses.checkbox, "\">\n       <input type=\"checkbox\" />\n       <span class=\"").concat(swalClasses.label, "\"></span>\n     </label>\n     <textarea class=\"").concat(swalClasses.textarea, "\"></textarea>\n     <div class=\"").concat(swalClasses['validation-message'], "\" id=\"").concat(swalClasses['validation-message'], "\"></div>\n   </div>\n   <div class=\"").concat(swalClasses.actions, "\">\n     <button type=\"button\" class=\"").concat(swalClasses.confirm, "\">OK</button>\n     <button type=\"button\" class=\"").concat(swalClasses.cancel, "\">Cancel</button>\n   </div>\n   <div class=\"").concat(swalClasses.footer, "\">\n   </div>\n </div>\n").replace(/(^|\n)\s*/g, '');
	
	var resetOldContainer = function resetOldContainer() {
	  var oldContainer = getContainer();
	
	  if (!oldContainer) {
	    return;
	  }
	
	  oldContainer.parentNode.removeChild(oldContainer);
	  removeClass([document.documentElement, document.body], [swalClasses['no-backdrop'], swalClasses['toast-shown'], swalClasses['has-column']]);
	};
	
	var oldInputVal; // IE11 workaround, see #1109 for details
	
	var resetValidationMessage = function resetValidationMessage(e) {
	  if (Swal.isVisible() && oldInputVal !== e.target.value) {
	    Swal.resetValidationMessage();
	  }
	
	  oldInputVal = e.target.value;
	};
	
	var addInputChangeListeners = function addInputChangeListeners() {
	  var content = getContent();
	  var input = getChildByClass(content, swalClasses.input);
	  var file = getChildByClass(content, swalClasses.file);
	  var range = content.querySelector(".".concat(swalClasses.range, " input"));
	  var rangeOutput = content.querySelector(".".concat(swalClasses.range, " output"));
	  var select = getChildByClass(content, swalClasses.select);
	  var checkbox = content.querySelector(".".concat(swalClasses.checkbox, " input"));
	  var textarea = getChildByClass(content, swalClasses.textarea);
	  input.oninput = resetValidationMessage;
	  file.onchange = resetValidationMessage;
	  select.onchange = resetValidationMessage;
	  checkbox.onchange = resetValidationMessage;
	  textarea.oninput = resetValidationMessage;
	
	  range.oninput = function (e) {
	    resetValidationMessage(e);
	    rangeOutput.value = range.value;
	  };
	
	  range.onchange = function (e) {
	    resetValidationMessage(e);
	    range.nextSibling.value = range.value;
	  };
	};
	
	var getTarget = function getTarget(target) {
	  return typeof target === 'string' ? document.querySelector(target) : target;
	};
	
	var setupAccessibility = function setupAccessibility(params) {
	  var popup = getPopup();
	  popup.setAttribute('role', params.toast ? 'alert' : 'dialog');
	  popup.setAttribute('aria-live', params.toast ? 'polite' : 'assertive');
	
	  if (!params.toast) {
	    popup.setAttribute('aria-modal', 'true');
	  }
	};
	
	var setupRTL = function setupRTL(targetElement) {
	  if (window.getComputedStyle(targetElement).direction === 'rtl') {
	    addClass(getContainer(), swalClasses.rtl);
	  }
	};
	/*
	 * Add modal + backdrop to DOM
	 */
	
	
	var init = function init(params) {
	  // Clean up the old popup container if it exists
	  resetOldContainer();
	  /* istanbul ignore if */
	
	  if (isNodeEnv()) {
	    error('SweetAlert2 requires document to initialize');
	    return;
	  }
	
	  var container = document.createElement('div');
	  container.className = swalClasses.container;
	  container.innerHTML = sweetHTML;
	  var targetElement = getTarget(params.target);
	  targetElement.appendChild(container);
	  setupAccessibility(params);
	  setupRTL(targetElement);
	  addInputChangeListeners();
	};
	
	var parseHtmlToContainer = function parseHtmlToContainer(param, target) {
	  // DOM element
	  if (param instanceof HTMLElement) {
	    target.appendChild(param); // JQuery element(s)
	  } else if (_typeof(param) === 'object') {
	    handleJqueryElem(target, param); // Plain string
	  } else if (param) {
	    target.innerHTML = param;
	  }
	};
	
	var handleJqueryElem = function handleJqueryElem(target, elem) {
	  target.innerHTML = '';
	
	  if (0 in elem) {
	    for (var i = 0; i in elem; i++) {
	      target.appendChild(elem[i].cloneNode(true));
	    }
	  } else {
	    target.appendChild(elem.cloneNode(true));
	  }
	};
	
	var animationEndEvent = function () {
	  // Prevent run in Node env
	
	  /* istanbul ignore if */
	  if (isNodeEnv()) {
	    return false;
	  }
	
	  var testEl = document.createElement('div');
	  var transEndEventNames = {
	    WebkitAnimation: 'webkitAnimationEnd',
	    OAnimation: 'oAnimationEnd oanimationend',
	    animation: 'animationend'
	  };
	
	  for (var i in transEndEventNames) {
	    if (Object.prototype.hasOwnProperty.call(transEndEventNames, i) && typeof testEl.style[i] !== 'undefined') {
	      return transEndEventNames[i];
	    }
	  }
	
	  return false;
	}();
	
	// Measure width of scrollbar
	// https://github.com/twbs/bootstrap/blob/master/js/modal.js#L279-L286
	var measureScrollbar = function measureScrollbar() {
	  var supportsTouch = 'ontouchstart' in window || navigator.msMaxTouchPoints;
	
	  if (supportsTouch) {
	    return 0;
	  }
	
	  var scrollDiv = document.createElement('div');
	  scrollDiv.style.width = '50px';
	  scrollDiv.style.height = '50px';
	  scrollDiv.style.overflow = 'scroll';
	  document.body.appendChild(scrollDiv);
	  var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;
	  document.body.removeChild(scrollDiv);
	  return scrollbarWidth;
	};
	
	var renderActions = function renderActions(instance, params) {
	  var actions = getActions();
	  var confirmButton = getConfirmButton();
	  var cancelButton = getCancelButton(); // Actions (buttons) wrapper
	
	  if (!params.showConfirmButton && !params.showCancelButton) {
	    hide(actions);
	  } // Custom class
	
	
	  applyCustomClass(actions, params.customClass, 'actions'); // Render confirm button
	
	  renderButton(confirmButton, 'confirm', params); // render Cancel Button
	
	  renderButton(cancelButton, 'cancel', params);
	
	  if (params.buttonsStyling) {
	    handleButtonsStyling(confirmButton, cancelButton, params);
	  } else {
	    removeClass([confirmButton, cancelButton], swalClasses.styled);
	    confirmButton.style.backgroundColor = confirmButton.style.borderLeftColor = confirmButton.style.borderRightColor = '';
	    cancelButton.style.backgroundColor = cancelButton.style.borderLeftColor = cancelButton.style.borderRightColor = '';
	  }
	
	  if (params.reverseButtons) {
	    confirmButton.parentNode.insertBefore(cancelButton, confirmButton);
	  }
	};
	
	function handleButtonsStyling(confirmButton, cancelButton, params) {
	  addClass([confirmButton, cancelButton], swalClasses.styled); // Buttons background colors
	
	  if (params.confirmButtonColor) {
	    confirmButton.style.backgroundColor = params.confirmButtonColor;
	  }
	
	  if (params.cancelButtonColor) {
	    cancelButton.style.backgroundColor = params.cancelButtonColor;
	  } // Loading state
	
	
	  var confirmButtonBackgroundColor = window.getComputedStyle(confirmButton).getPropertyValue('background-color');
	  confirmButton.style.borderLeftColor = confirmButtonBackgroundColor;
	  confirmButton.style.borderRightColor = confirmButtonBackgroundColor;
	}
	
	function renderButton(button, buttonType, params) {
	  toggle(button, params['showC' + buttonType.substring(1) + 'Button'], 'inline-block');
	  button.innerHTML = params[buttonType + 'ButtonText']; // Set caption text
	
	  button.setAttribute('aria-label', params[buttonType + 'ButtonAriaLabel']); // ARIA label
	  // Add buttons custom classes
	
	  button.className = swalClasses[buttonType];
	  applyCustomClass(button, params.customClass, buttonType + 'Button');
	  addClass(button, params[buttonType + 'ButtonClass']);
	}
	
	function handleBackdropParam(container, backdrop) {
	  if (typeof backdrop === 'string') {
	    container.style.background = backdrop;
	  } else if (!backdrop) {
	    addClass([document.documentElement, document.body], swalClasses['no-backdrop']);
	  }
	}
	
	function handlePositionParam(container, position) {
	  if (position in swalClasses) {
	    addClass(container, swalClasses[position]);
	  } else {
	    warn('The "position" parameter is not valid, defaulting to "center"');
	    addClass(container, swalClasses.center);
	  }
	}
	
	function handleGrowParam(container, grow) {
	  if (grow && typeof grow === 'string') {
	    var growClass = 'grow-' + grow;
	
	    if (growClass in swalClasses) {
	      addClass(container, swalClasses[growClass]);
	    }
	  }
	}
	
	var renderContainer = function renderContainer(instance, params) {
	  var container = getContainer();
	
	  if (!container) {
	    return;
	  }
	
	  handleBackdropParam(container, params.backdrop);
	
	  if (!params.backdrop && params.allowOutsideClick) {
	    warn('"allowOutsideClick" parameter requires `backdrop` parameter to be set to `true`');
	  }
	
	  handlePositionParam(container, params.position);
	  handleGrowParam(container, params.grow); // Custom class
	
	  applyCustomClass(container, params.customClass, 'container');
	
	  if (params.customContainerClass) {
	    // @deprecated
	    addClass(container, params.customContainerClass);
	  }
	};
	
	/**
	 * This module containts `WeakMap`s for each effectively-"private  property" that a `Swal` has.
	 * For example, to set the private property "foo" of `this` to "bar", you can `privateProps.foo.set(this, 'bar')`
	 * This is the approach that Babel will probably take to implement private methods/fields
	 *   https://github.com/tc39/proposal-private-methods
	 *   https://github.com/babel/babel/pull/7555
	 * Once we have the changes from that PR in Babel, and our core class fits reasonable in *one module*
	 *   then we can use that language feature.
	 */
	var privateProps = {
	  promise: new WeakMap(),
	  innerParams: new WeakMap(),
	  domCache: new WeakMap()
	};
	
	var inputTypes = ['input', 'file', 'range', 'select', 'radio', 'checkbox', 'textarea'];
	var renderInput = function renderInput(instance, params) {
	  var content = getContent();
	  var innerParams = privateProps.innerParams.get(instance);
	  var rerender = !innerParams || params.input !== innerParams.input;
	  inputTypes.forEach(function (inputType) {
	    var inputClass = swalClasses[inputType];
	    var inputContainer = getChildByClass(content, inputClass); // set attributes
	
	    setAttributes(inputType, params.inputAttributes); // set class
	
	    inputContainer.className = inputClass;
	
	    if (rerender) {
	      hide(inputContainer);
	    }
	  });
	
	  if (params.input) {
	    if (rerender) {
	      showInput(params);
	    } // set custom class
	
	
	    setCustomClass(params);
	  }
	};
	
	var showInput = function showInput(params) {
	  if (!renderInputType[params.input]) {
	    return error("Unexpected type of input! Expected \"text\", \"email\", \"password\", \"number\", \"tel\", \"select\", \"radio\", \"checkbox\", \"textarea\", \"file\" or \"url\", got \"".concat(params.input, "\""));
	  }
	
	  var inputContainer = getInputContainer(params.input);
	  var input = renderInputType[params.input](inputContainer, params);
	  show(input); // input autofocus
	
	  setTimeout(function () {
	    focusInput(input);
	  });
	};
	
	var removeAttributes = function removeAttributes(input) {
	  for (var i = 0; i < input.attributes.length; i++) {
	    var attrName = input.attributes[i].name;
	
	    if (!(['type', 'value', 'style'].indexOf(attrName) !== -1)) {
	      input.removeAttribute(attrName);
	    }
	  }
	};
	
	var setAttributes = function setAttributes(inputType, inputAttributes) {
	  var input = getInput(getContent(), inputType);
	
	  if (!input) {
	    return;
	  }
	
	  removeAttributes(input);
	
	  for (var attr in inputAttributes) {
	    // Do not set a placeholder for <input type="range">
	    // it'll crash Edge, #1298
	    if (inputType === 'range' && attr === 'placeholder') {
	      continue;
	    }
	
	    input.setAttribute(attr, inputAttributes[attr]);
	  }
	};
	
	var setCustomClass = function setCustomClass(params) {
	  var inputContainer = getInputContainer(params.input);
	
	  if (params.inputClass) {
	    addClass(inputContainer, params.inputClass);
	  }
	
	  if (params.customClass) {
	    addClass(inputContainer, params.customClass.input);
	  }
	};
	
	var setInputPlaceholder = function setInputPlaceholder(input, params) {
	  if (!input.placeholder || params.inputPlaceholder) {
	    input.placeholder = params.inputPlaceholder;
	  }
	};
	
	var getInputContainer = function getInputContainer(inputType) {
	  var inputClass = swalClasses[inputType] ? swalClasses[inputType] : swalClasses.input;
	  return getChildByClass(getContent(), inputClass);
	};
	
	var renderInputType = {};
	
	renderInputType.text = renderInputType.email = renderInputType.password = renderInputType.number = renderInputType.tel = renderInputType.url = function (input, params) {
	  if (typeof params.inputValue === 'string' || typeof params.inputValue === 'number') {
	    input.value = params.inputValue;
	  } else if (!isPromise(params.inputValue)) {
	    warn("Unexpected type of inputValue! Expected \"string\", \"number\" or \"Promise\", got \"".concat(_typeof(params.inputValue), "\""));
	  }
	
	  setInputPlaceholder(input, params);
	  input.type = params.input;
	  return input;
	};
	
	renderInputType.file = function (input, params) {
	  setInputPlaceholder(input, params);
	  return input;
	};
	
	renderInputType.range = function (range, params) {
	  var rangeInput = range.querySelector('input');
	  var rangeOutput = range.querySelector('output');
	  rangeInput.value = params.inputValue;
	  rangeInput.type = params.input;
	  rangeOutput.value = params.inputValue;
	  return range;
	};
	
	renderInputType.select = function (select, params) {
	  select.innerHTML = '';
	
	  if (params.inputPlaceholder) {
	    var placeholder = document.createElement('option');
	    placeholder.innerHTML = params.inputPlaceholder;
	    placeholder.value = '';
	    placeholder.disabled = true;
	    placeholder.selected = true;
	    select.appendChild(placeholder);
	  }
	
	  return select;
	};
	
	renderInputType.radio = function (radio) {
	  radio.innerHTML = '';
	  return radio;
	};
	
	renderInputType.checkbox = function (checkboxContainer, params) {
	  var checkbox = getInput(getContent(), 'checkbox');
	  checkbox.value = 1;
	  checkbox.id = swalClasses.checkbox;
	  checkbox.checked = Boolean(params.inputValue);
	  var label = checkboxContainer.querySelector('span');
	  label.innerHTML = params.inputPlaceholder;
	  return checkboxContainer;
	};
	
	renderInputType.textarea = function (textarea, params) {
	  textarea.value = params.inputValue;
	  setInputPlaceholder(textarea, params);
	
	  if ('MutationObserver' in window) {
	    // #1699
	    var initialPopupWidth = parseInt(window.getComputedStyle(getPopup()).width);
	    var popupPadding = parseInt(window.getComputedStyle(getPopup()).paddingLeft) + parseInt(window.getComputedStyle(getPopup()).paddingRight);
	
	    var outputsize = function outputsize() {
	      var contentWidth = textarea.offsetWidth + popupPadding;
	
	      if (contentWidth > initialPopupWidth) {
	        getPopup().style.width = contentWidth + 'px';
	      } else {
	        getPopup().style.width = null;
	      }
	    };
	
	    new MutationObserver(outputsize).observe(textarea, {
	      attributes: true,
	      attributeFilter: ['style']
	    });
	  }
	
	  return textarea;
	};
	
	var renderContent = function renderContent(instance, params) {
	  var content = getContent().querySelector('#' + swalClasses.content); // Content as HTML
	
	  if (params.html) {
	    parseHtmlToContainer(params.html, content);
	    show(content, 'block'); // Content as plain text
	  } else if (params.text) {
	    content.textContent = params.text;
	    show(content, 'block'); // No content
	  } else {
	    hide(content);
	  }
	
	  renderInput(instance, params); // Custom class
	
	  applyCustomClass(getContent(), params.customClass, 'content');
	};
	
	var renderFooter = function renderFooter(instance, params) {
	  var footer = getFooter();
	  toggle(footer, params.footer);
	
	  if (params.footer) {
	    parseHtmlToContainer(params.footer, footer);
	  } // Custom class
	
	
	  applyCustomClass(footer, params.customClass, 'footer');
	};
	
	var renderCloseButton = function renderCloseButton(instance, params) {
	  var closeButton = getCloseButton();
	  closeButton.innerHTML = params.closeButtonHtml; // Custom class
	
	  applyCustomClass(closeButton, params.customClass, 'closeButton');
	  toggle(closeButton, params.showCloseButton);
	  closeButton.setAttribute('aria-label', params.closeButtonAriaLabel);
	};
	
	var renderIcon = function renderIcon(instance, params) {
	  var innerParams = privateProps.innerParams.get(instance); // if the icon with the given type already rendered,
	  // apply the custom class without re-rendering the icon
	
	  if (innerParams && params.type === innerParams.type && getIcon()) {
	    applyCustomClass(getIcon(), params.customClass, 'icon');
	    return;
	  }
	
	  hideAllIcons();
	
	  if (!params.type) {
	    return;
	  }
	
	  adjustSuccessIconBackgoundColor();
	
	  if (Object.keys(iconTypes).indexOf(params.type) !== -1) {
	    var icon = elementBySelector(".".concat(swalClasses.icon, ".").concat(iconTypes[params.type]));
	    show(icon); // Custom class
	
	    applyCustomClass(icon, params.customClass, 'icon'); // Animate icon
	
	    toggleClass(icon, "swal2-animate-".concat(params.type, "-icon"), params.animation);
	  } else {
	    error("Unknown type! Expected \"success\", \"error\", \"warning\", \"info\" or \"question\", got \"".concat(params.type, "\""));
	  }
	};
	
	var hideAllIcons = function hideAllIcons() {
	  var icons = getIcons();
	
	  for (var i = 0; i < icons.length; i++) {
	    hide(icons[i]);
	  }
	}; // Adjust success icon background color to match the popup background color
	
	
	var adjustSuccessIconBackgoundColor = function adjustSuccessIconBackgoundColor() {
	  var popup = getPopup();
	  var popupBackgroundColor = window.getComputedStyle(popup).getPropertyValue('background-color');
	  var successIconParts = popup.querySelectorAll('[class^=swal2-success-circular-line], .swal2-success-fix');
	
	  for (var i = 0; i < successIconParts.length; i++) {
	    successIconParts[i].style.backgroundColor = popupBackgroundColor;
	  }
	};
	
	var renderImage = function renderImage(instance, params) {
	  var image = getImage();
	
	  if (!params.imageUrl) {
	    return hide(image);
	  }
	
	  show(image); // Src, alt
	
	  image.setAttribute('src', params.imageUrl);
	  image.setAttribute('alt', params.imageAlt); // Width, height
	
	  applyNumericalStyle(image, 'width', params.imageWidth);
	  applyNumericalStyle(image, 'height', params.imageHeight); // Class
	
	  image.className = swalClasses.image;
	  applyCustomClass(image, params.customClass, 'image');
	
	  if (params.imageClass) {
	    addClass(image, params.imageClass);
	  }
	};
	
	var createStepElement = function createStepElement(step) {
	  var stepEl = document.createElement('li');
	  addClass(stepEl, swalClasses['progress-step']);
	  stepEl.innerHTML = step;
	  return stepEl;
	};
	
	var createLineElement = function createLineElement(params) {
	  var lineEl = document.createElement('li');
	  addClass(lineEl, swalClasses['progress-step-line']);
	
	  if (params.progressStepsDistance) {
	    lineEl.style.width = params.progressStepsDistance;
	  }
	
	  return lineEl;
	};
	
	var renderProgressSteps = function renderProgressSteps(instance, params) {
	  var progressStepsContainer = getProgressSteps();
	
	  if (!params.progressSteps || params.progressSteps.length === 0) {
	    return hide(progressStepsContainer);
	  }
	
	  show(progressStepsContainer);
	  progressStepsContainer.innerHTML = '';
	  var currentProgressStep = parseInt(params.currentProgressStep === null ? Swal.getQueueStep() : params.currentProgressStep);
	
	  if (currentProgressStep >= params.progressSteps.length) {
	    warn('Invalid currentProgressStep parameter, it should be less than progressSteps.length ' + '(currentProgressStep like JS arrays starts from 0)');
	  }
	
	  params.progressSteps.forEach(function (step, index) {
	    var stepEl = createStepElement(step);
	    progressStepsContainer.appendChild(stepEl);
	
	    if (index === currentProgressStep) {
	      addClass(stepEl, swalClasses['active-progress-step']);
	    }
	
	    if (index !== params.progressSteps.length - 1) {
	      var lineEl = createLineElement(step);
	      progressStepsContainer.appendChild(lineEl);
	    }
	  });
	};
	
	var renderTitle = function renderTitle(instance, params) {
	  var title = getTitle();
	  toggle(title, params.title || params.titleText);
	
	  if (params.title) {
	    parseHtmlToContainer(params.title, title);
	  }
	
	  if (params.titleText) {
	    title.innerText = params.titleText;
	  } // Custom class
	
	
	  applyCustomClass(title, params.customClass, 'title');
	};
	
	var renderHeader = function renderHeader(instance, params) {
	  var header = getHeader(); // Custom class
	
	  applyCustomClass(header, params.customClass, 'header'); // Progress steps
	
	  renderProgressSteps(instance, params); // Icon
	
	  renderIcon(instance, params); // Image
	
	  renderImage(instance, params); // Title
	
	  renderTitle(instance, params); // Close button
	
	  renderCloseButton(instance, params);
	};
	
	var renderPopup = function renderPopup(instance, params) {
	  var popup = getPopup(); // Width
	
	  applyNumericalStyle(popup, 'width', params.width); // Padding
	
	  applyNumericalStyle(popup, 'padding', params.padding); // Background
	
	  if (params.background) {
	    popup.style.background = params.background;
	  } // Default Class
	
	
	  popup.className = swalClasses.popup;
	
	  if (params.toast) {
	    addClass([document.documentElement, document.body], swalClasses['toast-shown']);
	    addClass(popup, swalClasses.toast);
	  } else {
	    addClass(popup, swalClasses.modal);
	  } // Custom class
	
	
	  applyCustomClass(popup, params.customClass, 'popup');
	
	  if (typeof params.customClass === 'string') {
	    addClass(popup, params.customClass);
	  } // CSS animation
	
	
	  toggleClass(popup, swalClasses.noanimation, !params.animation);
	};
	
	var render = function render(instance, params) {
	  renderPopup(instance, params);
	  renderContainer(instance, params);
	  renderHeader(instance, params);
	  renderContent(instance, params);
	  renderActions(instance, params);
	  renderFooter(instance, params);
	
	  if (typeof params.onRender === 'function') {
	    params.onRender(getPopup());
	  }
	};
	
	/*
	 * Global function to determine if SweetAlert2 popup is shown
	 */
	
	var isVisible$1 = function isVisible$$1() {
	  return isVisible(getPopup());
	};
	/*
	 * Global function to click 'Confirm' button
	 */
	
	var clickConfirm = function clickConfirm() {
	  return getConfirmButton() && getConfirmButton().click();
	};
	/*
	 * Global function to click 'Cancel' button
	 */
	
	var clickCancel = function clickCancel() {
	  return getCancelButton() && getCancelButton().click();
	};
	
	function fire() {
	  var Swal = this;
	
	  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
	    args[_key] = arguments[_key];
	  }
	
	  return _construct(Swal, args);
	}
	
	/**
	 * Returns an extended version of `Swal` containing `params` as defaults.
	 * Useful for reusing Swal configuration.
	 *
	 * For example:
	 *
	 * Before:
	 * const textPromptOptions = { input: 'text', showCancelButton: true }
	 * const {value: firstName} = await Swal.fire({ ...textPromptOptions, title: 'What is your first name?' })
	 * const {value: lastName} = await Swal.fire({ ...textPromptOptions, title: 'What is your last name?' })
	 *
	 * After:
	 * const TextPrompt = Swal.mixin({ input: 'text', showCancelButton: true })
	 * const {value: firstName} = await TextPrompt('What is your first name?')
	 * const {value: lastName} = await TextPrompt('What is your last name?')
	 *
	 * @param mixinParams
	 */
	function mixin(mixinParams) {
	  var MixinSwal =
	  /*#__PURE__*/
	  function (_this) {
	    _inherits(MixinSwal, _this);
	
	    function MixinSwal() {
	      _classCallCheck(this, MixinSwal);
	
	      return _possibleConstructorReturn(this, _getPrototypeOf(MixinSwal).apply(this, arguments));
	    }
	
	    _createClass(MixinSwal, [{
	      key: "_main",
	      value: function _main(params) {
	        return _get(_getPrototypeOf(MixinSwal.prototype), "_main", this).call(this, _extends({}, mixinParams, params));
	      }
	    }]);
	
	    return MixinSwal;
	  }(this);
	
	  return MixinSwal;
	}
	
	// private global state for the queue feature
	var currentSteps = [];
	/*
	 * Global function for chaining sweetAlert popups
	 */
	
	var queue = function queue(steps) {
	  var Swal = this;
	  currentSteps = steps;
	
	  var resetAndResolve = function resetAndResolve(resolve, value) {
	    currentSteps = [];
	    document.body.removeAttribute('data-swal2-queue-step');
	    resolve(value);
	  };
	
	  var queueResult = [];
	  return new Promise(function (resolve) {
	    (function step(i, callback) {
	      if (i < currentSteps.length) {
	        document.body.setAttribute('data-swal2-queue-step', i);
	        Swal.fire(currentSteps[i]).then(function (result) {
	          if (typeof result.value !== 'undefined') {
	            queueResult.push(result.value);
	            step(i + 1, callback);
	          } else {
	            resetAndResolve(resolve, {
	              dismiss: result.dismiss
	            });
	          }
	        });
	      } else {
	        resetAndResolve(resolve, {
	          value: queueResult
	        });
	      }
	    })(0);
	  });
	};
	/*
	 * Global function for getting the index of current popup in queue
	 */
	
	var getQueueStep = function getQueueStep() {
	  return document.body.getAttribute('data-swal2-queue-step');
	};
	/*
	 * Global function for inserting a popup to the queue
	 */
	
	var insertQueueStep = function insertQueueStep(step, index) {
	  if (index && index < currentSteps.length) {
	    return currentSteps.splice(index, 0, step);
	  }
	
	  return currentSteps.push(step);
	};
	/*
	 * Global function for deleting a popup from the queue
	 */
	
	var deleteQueueStep = function deleteQueueStep(index) {
	  if (typeof currentSteps[index] !== 'undefined') {
	    currentSteps.splice(index, 1);
	  }
	};
	
	/**
	 * Show spinner instead of Confirm button and disable Cancel button
	 */
	
	var showLoading = function showLoading() {
	  var popup = getPopup();
	
	  if (!popup) {
	    Swal.fire('');
	  }
	
	  popup = getPopup();
	  var actions = getActions();
	  var confirmButton = getConfirmButton();
	  var cancelButton = getCancelButton();
	  show(actions);
	  show(confirmButton);
	  addClass([popup, actions], swalClasses.loading);
	  confirmButton.disabled = true;
	  cancelButton.disabled = true;
	  popup.setAttribute('data-loading', true);
	  popup.setAttribute('aria-busy', true);
	  popup.focus();
	};
	
	var RESTORE_FOCUS_TIMEOUT = 100;
	
	var globalState = {};
	var focusPreviousActiveElement = function focusPreviousActiveElement() {
	  if (globalState.previousActiveElement && globalState.previousActiveElement.focus) {
	    globalState.previousActiveElement.focus();
	    globalState.previousActiveElement = null;
	  } else if (document.body) {
	    document.body.focus();
	  }
	}; // Restore previous active (focused) element
	
	
	var restoreActiveElement = function restoreActiveElement() {
	  return new Promise(function (resolve) {
	    var x = window.scrollX;
	    var y = window.scrollY;
	    globalState.restoreFocusTimeout = setTimeout(function () {
	      focusPreviousActiveElement();
	      resolve();
	    }, RESTORE_FOCUS_TIMEOUT); // issues/900
	
	    if (typeof x !== 'undefined' && typeof y !== 'undefined') {
	      // IE doesn't have scrollX/scrollY support
	      window.scrollTo(x, y);
	    }
	  });
	};
	
	/**
	 * If `timer` parameter is set, returns number of milliseconds of timer remained.
	 * Otherwise, returns undefined.
	 */
	
	var getTimerLeft = function getTimerLeft() {
	  return globalState.timeout && globalState.timeout.getTimerLeft();
	};
	/**
	 * Stop timer. Returns number of milliseconds of timer remained.
	 * If `timer` parameter isn't set, returns undefined.
	 */
	
	var stopTimer = function stopTimer() {
	  return globalState.timeout && globalState.timeout.stop();
	};
	/**
	 * Resume timer. Returns number of milliseconds of timer remained.
	 * If `timer` parameter isn't set, returns undefined.
	 */
	
	var resumeTimer = function resumeTimer() {
	  return globalState.timeout && globalState.timeout.start();
	};
	/**
	 * Resume timer. Returns number of milliseconds of timer remained.
	 * If `timer` parameter isn't set, returns undefined.
	 */
	
	var toggleTimer = function toggleTimer() {
	  var timer = globalState.timeout;
	  return timer && (timer.running ? timer.stop() : timer.start());
	};
	/**
	 * Increase timer. Returns number of milliseconds of an updated timer.
	 * If `timer` parameter isn't set, returns undefined.
	 */
	
	var increaseTimer = function increaseTimer(n) {
	  return globalState.timeout && globalState.timeout.increase(n);
	};
	/**
	 * Check if timer is running. Returns true if timer is running
	 * or false if timer is paused or stopped.
	 * If `timer` parameter isn't set, returns undefined
	 */
	
	var isTimerRunning = function isTimerRunning() {
	  return globalState.timeout && globalState.timeout.isRunning();
	};
	
	var defaultParams = {
	  title: '',
	  titleText: '',
	  text: '',
	  html: '',
	  footer: '',
	  type: null,
	  toast: false,
	  customClass: '',
	  customContainerClass: '',
	  target: 'body',
	  backdrop: true,
	  animation: true,
	  heightAuto: true,
	  allowOutsideClick: true,
	  allowEscapeKey: true,
	  allowEnterKey: true,
	  stopKeydownPropagation: true,
	  keydownListenerCapture: false,
	  showConfirmButton: true,
	  showCancelButton: false,
	  preConfirm: null,
	  confirmButtonText: 'OK',
	  confirmButtonAriaLabel: '',
	  confirmButtonColor: null,
	  confirmButtonClass: '',
	  cancelButtonText: 'Cancel',
	  cancelButtonAriaLabel: '',
	  cancelButtonColor: null,
	  cancelButtonClass: '',
	  buttonsStyling: true,
	  reverseButtons: false,
	  focusConfirm: true,
	  focusCancel: false,
	  showCloseButton: false,
	  closeButtonHtml: '&times;',
	  closeButtonAriaLabel: 'Close this dialog',
	  showLoaderOnConfirm: false,
	  imageUrl: null,
	  imageWidth: null,
	  imageHeight: null,
	  imageAlt: '',
	  imageClass: '',
	  timer: null,
	  width: null,
	  padding: null,
	  background: null,
	  input: null,
	  inputPlaceholder: '',
	  inputValue: '',
	  inputOptions: {},
	  inputAutoTrim: true,
	  inputClass: '',
	  inputAttributes: {},
	  inputValidator: null,
	  validationMessage: null,
	  grow: false,
	  position: 'center',
	  progressSteps: [],
	  currentProgressStep: null,
	  progressStepsDistance: null,
	  onBeforeOpen: null,
	  onOpen: null,
	  onRender: null,
	  onClose: null,
	  onAfterClose: null,
	  scrollbarPadding: true
	};
	var updatableParams = ['title', 'titleText', 'text', 'html', 'type', 'customClass', 'showConfirmButton', 'showCancelButton', 'confirmButtonText', 'confirmButtonAriaLabel', 'confirmButtonColor', 'confirmButtonClass', 'cancelButtonText', 'cancelButtonAriaLabel', 'cancelButtonColor', 'cancelButtonClass', 'buttonsStyling', 'reverseButtons', 'imageUrl', 'imageWidth', 'imageHeigth', 'imageAlt', 'imageClass', 'progressSteps', 'currentProgressStep'];
	var deprecatedParams = {
	  customContainerClass: 'customClass',
	  confirmButtonClass: 'customClass',
	  cancelButtonClass: 'customClass',
	  imageClass: 'customClass',
	  inputClass: 'customClass'
	};
	var toastIncompatibleParams = ['allowOutsideClick', 'allowEnterKey', 'backdrop', 'focusConfirm', 'focusCancel', 'heightAuto', 'keydownListenerCapture'];
	/**
	 * Is valid parameter
	 * @param {String} paramName
	 */
	
	var isValidParameter = function isValidParameter(paramName) {
	  return Object.prototype.hasOwnProperty.call(defaultParams, paramName);
	};
	/**
	 * Is valid parameter for Swal.update() method
	 * @param {String} paramName
	 */
	
	var isUpdatableParameter = function isUpdatableParameter(paramName) {
	  return updatableParams.indexOf(paramName) !== -1;
	};
	/**
	 * Is deprecated parameter
	 * @param {String} paramName
	 */
	
	var isDeprecatedParameter = function isDeprecatedParameter(paramName) {
	  return deprecatedParams[paramName];
	};
	
	var checkIfParamIsValid = function checkIfParamIsValid(param) {
	  if (!isValidParameter(param)) {
	    warn("Unknown parameter \"".concat(param, "\""));
	  }
	};
	
	var checkIfToastParamIsValid = function checkIfToastParamIsValid(param) {
	  if (toastIncompatibleParams.indexOf(param) !== -1) {
	    warn("The parameter \"".concat(param, "\" is incompatible with toasts"));
	  }
	};
	
	var checkIfParamIsDeprecated = function checkIfParamIsDeprecated(param) {
	  if (isDeprecatedParameter(param)) {
	    warnAboutDepreation(param, isDeprecatedParameter(param));
	  }
	};
	/**
	 * Show relevant warnings for given params
	 *
	 * @param params
	 */
	
	
	var showWarningsForParams = function showWarningsForParams(params) {
	  for (var param in params) {
	    checkIfParamIsValid(param);
	
	    if (params.toast) {
	      checkIfToastParamIsValid(param);
	    }
	
	    checkIfParamIsDeprecated();
	  }
	};
	
	
	
	var staticMethods = Object.freeze({
		isValidParameter: isValidParameter,
		isUpdatableParameter: isUpdatableParameter,
		isDeprecatedParameter: isDeprecatedParameter,
		argsToParams: argsToParams,
		isVisible: isVisible$1,
		clickConfirm: clickConfirm,
		clickCancel: clickCancel,
		getContainer: getContainer,
		getPopup: getPopup,
		getTitle: getTitle,
		getContent: getContent,
		getImage: getImage,
		getIcon: getIcon,
		getIcons: getIcons,
		getCloseButton: getCloseButton,
		getActions: getActions,
		getConfirmButton: getConfirmButton,
		getCancelButton: getCancelButton,
		getHeader: getHeader,
		getFooter: getFooter,
		getFocusableElements: getFocusableElements,
		getValidationMessage: getValidationMessage,
		isLoading: isLoading,
		fire: fire,
		mixin: mixin,
		queue: queue,
		getQueueStep: getQueueStep,
		insertQueueStep: insertQueueStep,
		deleteQueueStep: deleteQueueStep,
		showLoading: showLoading,
		enableLoading: showLoading,
		getTimerLeft: getTimerLeft,
		stopTimer: stopTimer,
		resumeTimer: resumeTimer,
		toggleTimer: toggleTimer,
		increaseTimer: increaseTimer,
		isTimerRunning: isTimerRunning
	});
	
	/**
	 * Enables buttons and hide loader.
	 */
	
	function hideLoading() {
	  var innerParams = privateProps.innerParams.get(this);
	  var domCache = privateProps.domCache.get(this);
	
	  if (!innerParams.showConfirmButton) {
	    hide(domCache.confirmButton);
	
	    if (!innerParams.showCancelButton) {
	      hide(domCache.actions);
	    }
	  }
	
	  removeClass([domCache.popup, domCache.actions], swalClasses.loading);
	  domCache.popup.removeAttribute('aria-busy');
	  domCache.popup.removeAttribute('data-loading');
	  domCache.confirmButton.disabled = false;
	  domCache.cancelButton.disabled = false;
	}
	
	function getInput$1(instance) {
	  var innerParams = privateProps.innerParams.get(instance || this);
	  var domCache = privateProps.domCache.get(instance || this);
	
	  if (!domCache) {
	    return null;
	  }
	
	  return getInput(domCache.content, innerParams.input);
	}
	
	var fixScrollbar = function fixScrollbar() {
	  // for queues, do not do this more than once
	  if (states.previousBodyPadding !== null) {
	    return;
	  } // if the body has overflow
	
	
	  if (document.body.scrollHeight > window.innerHeight) {
	    // add padding so the content doesn't shift after removal of scrollbar
	    states.previousBodyPadding = parseInt(window.getComputedStyle(document.body).getPropertyValue('padding-right'));
	    document.body.style.paddingRight = states.previousBodyPadding + measureScrollbar() + 'px';
	  }
	};
	var undoScrollbar = function undoScrollbar() {
	  if (states.previousBodyPadding !== null) {
	    document.body.style.paddingRight = states.previousBodyPadding + 'px';
	    states.previousBodyPadding = null;
	  }
	};
	
	/* istanbul ignore next */
	
	var iOSfix = function iOSfix() {
	  var iOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream || navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1;
	
	  if (iOS && !hasClass(document.body, swalClasses.iosfix)) {
	    var offset = document.body.scrollTop;
	    document.body.style.top = offset * -1 + 'px';
	    addClass(document.body, swalClasses.iosfix);
	    lockBodyScroll();
	  }
	};
	
	var lockBodyScroll = function lockBodyScroll() {
	  // #1246
	  var container = getContainer();
	  var preventTouchMove;
	
	  container.ontouchstart = function (e) {
	    preventTouchMove = e.target === container || !isScrollable(container) && e.target.tagName !== 'INPUT' // #1603
	    ;
	  };
	
	  container.ontouchmove = function (e) {
	    if (preventTouchMove) {
	      e.preventDefault();
	      e.stopPropagation();
	    }
	  };
	};
	/* istanbul ignore next */
	
	
	var undoIOSfix = function undoIOSfix() {
	  if (hasClass(document.body, swalClasses.iosfix)) {
	    var offset = parseInt(document.body.style.top, 10);
	    removeClass(document.body, swalClasses.iosfix);
	    document.body.style.top = '';
	    document.body.scrollTop = offset * -1;
	  }
	};
	
	var isIE11 = function isIE11() {
	  return !!window.MSInputMethodContext && !!document.documentMode;
	}; // Fix IE11 centering sweetalert2/issues/933
	
	/* istanbul ignore next */
	
	
	var fixVerticalPositionIE = function fixVerticalPositionIE() {
	  var container = getContainer();
	  var popup = getPopup();
	  container.style.removeProperty('align-items');
	
	  if (popup.offsetTop < 0) {
	    container.style.alignItems = 'flex-start';
	  }
	};
	/* istanbul ignore next */
	
	
	var IEfix = function IEfix() {
	  if (typeof window !== 'undefined' && isIE11()) {
	    fixVerticalPositionIE();
	    window.addEventListener('resize', fixVerticalPositionIE);
	  }
	};
	/* istanbul ignore next */
	
	var undoIEfix = function undoIEfix() {
	  if (typeof window !== 'undefined' && isIE11()) {
	    window.removeEventListener('resize', fixVerticalPositionIE);
	  }
	};
	
	// Adding aria-hidden="true" to elements outside of the active modal dialog ensures that
	// elements not within the active modal dialog will not be surfaced if a user opens a screen
	// reader’s list of elements (headings, form controls, landmarks, etc.) in the document.
	
	var setAriaHidden = function setAriaHidden() {
	  var bodyChildren = toArray(document.body.children);
	  bodyChildren.forEach(function (el) {
	    if (el === getContainer() || contains(el, getContainer())) {
	      return;
	    }
	
	    if (el.hasAttribute('aria-hidden')) {
	      el.setAttribute('data-previous-aria-hidden', el.getAttribute('aria-hidden'));
	    }
	
	    el.setAttribute('aria-hidden', 'true');
	  });
	};
	var unsetAriaHidden = function unsetAriaHidden() {
	  var bodyChildren = toArray(document.body.children);
	  bodyChildren.forEach(function (el) {
	    if (el.hasAttribute('data-previous-aria-hidden')) {
	      el.setAttribute('aria-hidden', el.getAttribute('data-previous-aria-hidden'));
	      el.removeAttribute('data-previous-aria-hidden');
	    } else {
	      el.removeAttribute('aria-hidden');
	    }
	  });
	};
	
	/**
	 * This module containts `WeakMap`s for each effectively-"private  property" that a `Swal` has.
	 * For example, to set the private property "foo" of `this` to "bar", you can `privateProps.foo.set(this, 'bar')`
	 * This is the approach that Babel will probably take to implement private methods/fields
	 *   https://github.com/tc39/proposal-private-methods
	 *   https://github.com/babel/babel/pull/7555
	 * Once we have the changes from that PR in Babel, and our core class fits reasonable in *one module*
	 *   then we can use that language feature.
	 */
	var privateMethods = {
	  swalPromiseResolve: new WeakMap()
	};
	
	/*
	 * Instance method to close sweetAlert
	 */
	
	function removePopupAndResetState(instance, container, isToast, onAfterClose) {
	  if (isToast) {
	    triggerOnAfterCloseAndDispose(instance, onAfterClose);
	  } else {
	    restoreActiveElement().then(function () {
	      return triggerOnAfterCloseAndDispose(instance, onAfterClose);
	    });
	    globalState.keydownTarget.removeEventListener('keydown', globalState.keydownHandler, {
	      capture: globalState.keydownListenerCapture
	    });
	    globalState.keydownHandlerAdded = false;
	  }
	
	  if (container.parentNode) {
	    container.parentNode.removeChild(container);
	  }
	
	  if (isModal()) {
	    undoScrollbar();
	    undoIOSfix();
	    undoIEfix();
	    unsetAriaHidden();
	  }
	
	  removeBodyClasses();
	}
	
	function removeBodyClasses() {
	  removeClass([document.documentElement, document.body], [swalClasses.shown, swalClasses['height-auto'], swalClasses['no-backdrop'], swalClasses['toast-shown'], swalClasses['toast-column']]);
	}
	
	function disposeSwal(instance) {
	  // Unset this.params so GC will dispose it (#1569)
	  delete instance.params; // Unset globalState props so GC will dispose globalState (#1569)
	
	  delete globalState.keydownHandler;
	  delete globalState.keydownTarget; // Unset WeakMaps so GC will be able to dispose them (#1569)
	
	  unsetWeakMaps(privateProps);
	  unsetWeakMaps(privateMethods);
	}
	
	function close(resolveValue) {
	  var popup = getPopup();
	
	  if (!popup || hasClass(popup, swalClasses.hide)) {
	    return;
	  }
	
	  var innerParams = privateProps.innerParams.get(this);
	
	  if (!innerParams) {
	    return;
	  }
	
	  var swalPromiseResolve = privateMethods.swalPromiseResolve.get(this);
	  removeClass(popup, swalClasses.show);
	  addClass(popup, swalClasses.hide);
	  handlePopupAnimation(this, popup, innerParams); // Resolve Swal promise
	
	  swalPromiseResolve(resolveValue || {});
	}
	
	var handlePopupAnimation = function handlePopupAnimation(instance, popup, innerParams) {
	  var container = getContainer(); // If animation is supported, animate
	
	  var animationIsSupported = animationEndEvent && hasCssAnimation(popup);
	  var onClose = innerParams.onClose,
	      onAfterClose = innerParams.onAfterClose;
	
	  if (onClose !== null && typeof onClose === 'function') {
	    onClose(popup);
	  }
	
	  if (animationIsSupported) {
	    animatePopup(instance, popup, container, onAfterClose);
	  } else {
	    // Otherwise, remove immediately
	    removePopupAndResetState(instance, container, isToast(), onAfterClose);
	  }
	};
	
	var animatePopup = function animatePopup(instance, popup, container, onAfterClose) {
	  globalState.swalCloseEventFinishedCallback = removePopupAndResetState.bind(null, instance, container, isToast(), onAfterClose);
	  popup.addEventListener(animationEndEvent, function (e) {
	    if (e.target === popup) {
	      globalState.swalCloseEventFinishedCallback();
	      delete globalState.swalCloseEventFinishedCallback;
	    }
	  });
	};
	
	var unsetWeakMaps = function unsetWeakMaps(obj) {
	  for (var i in obj) {
	    obj[i] = new WeakMap();
	  }
	};
	
	var triggerOnAfterCloseAndDispose = function triggerOnAfterCloseAndDispose(instance, onAfterClose) {
	  setTimeout(function () {
	    if (onAfterClose !== null && typeof onAfterClose === 'function') {
	      onAfterClose();
	    }
	
	    if (!getPopup()) {
	      disposeSwal(instance);
	    }
	  });
	};
	
	function setButtonsDisabled(instance, buttons, disabled) {
	  var domCache = privateProps.domCache.get(instance);
	  buttons.forEach(function (button) {
	    domCache[button].disabled = disabled;
	  });
	}
	
	function setInputDisabled(input, disabled) {
	  if (!input) {
	    return false;
	  }
	
	  if (input.type === 'radio') {
	    var radiosContainer = input.parentNode.parentNode;
	    var radios = radiosContainer.querySelectorAll('input');
	
	    for (var i = 0; i < radios.length; i++) {
	      radios[i].disabled = disabled;
	    }
	  } else {
	    input.disabled = disabled;
	  }
	}
	
	function enableButtons() {
	  setButtonsDisabled(this, ['confirmButton', 'cancelButton'], false);
	}
	function disableButtons() {
	  setButtonsDisabled(this, ['confirmButton', 'cancelButton'], true);
	} // @deprecated
	
	function enableConfirmButton() {
	  warnAboutDepreation('Swal.enableConfirmButton()', "Swal.getConfirmButton().removeAttribute('disabled')");
	  setButtonsDisabled(this, ['confirmButton'], false);
	} // @deprecated
	
	function disableConfirmButton() {
	  warnAboutDepreation('Swal.disableConfirmButton()', "Swal.getConfirmButton().setAttribute('disabled', '')");
	  setButtonsDisabled(this, ['confirmButton'], true);
	}
	function enableInput() {
	  return setInputDisabled(this.getInput(), false);
	}
	function disableInput() {
	  return setInputDisabled(this.getInput(), true);
	}
	
	function showValidationMessage(error) {
	  var domCache = privateProps.domCache.get(this);
	  domCache.validationMessage.innerHTML = error;
	  var popupComputedStyle = window.getComputedStyle(domCache.popup);
	  domCache.validationMessage.style.marginLeft = "-".concat(popupComputedStyle.getPropertyValue('padding-left'));
	  domCache.validationMessage.style.marginRight = "-".concat(popupComputedStyle.getPropertyValue('padding-right'));
	  show(domCache.validationMessage);
	  var input = this.getInput();
	
	  if (input) {
	    input.setAttribute('aria-invalid', true);
	    input.setAttribute('aria-describedBy', swalClasses['validation-message']);
	    focusInput(input);
	    addClass(input, swalClasses.inputerror);
	  }
	} // Hide block with validation message
	
	function resetValidationMessage$1() {
	  var domCache = privateProps.domCache.get(this);
	
	  if (domCache.validationMessage) {
	    hide(domCache.validationMessage);
	  }
	
	  var input = this.getInput();
	
	  if (input) {
	    input.removeAttribute('aria-invalid');
	    input.removeAttribute('aria-describedBy');
	    removeClass(input, swalClasses.inputerror);
	  }
	}
	
	function getProgressSteps$1() {
	  warnAboutDepreation('Swal.getProgressSteps()', "const swalInstance = Swal.fire({progressSteps: ['1', '2', '3']}); const progressSteps = swalInstance.params.progressSteps");
	  var innerParams = privateProps.innerParams.get(this);
	  return innerParams.progressSteps;
	}
	function setProgressSteps(progressSteps) {
	  warnAboutDepreation('Swal.setProgressSteps()', 'Swal.update()');
	  var innerParams = privateProps.innerParams.get(this);
	
	  var updatedParams = _extends({}, innerParams, {
	    progressSteps: progressSteps
	  });
	
	  renderProgressSteps(this, updatedParams);
	  privateProps.innerParams.set(this, updatedParams);
	}
	function showProgressSteps() {
	  var domCache = privateProps.domCache.get(this);
	  show(domCache.progressSteps);
	}
	function hideProgressSteps() {
	  var domCache = privateProps.domCache.get(this);
	  hide(domCache.progressSteps);
	}
	
	var Timer =
	/*#__PURE__*/
	function () {
	  function Timer(callback, delay) {
	    _classCallCheck(this, Timer);
	
	    this.callback = callback;
	    this.remaining = delay;
	    this.running = false;
	    this.start();
	  }
	
	  _createClass(Timer, [{
	    key: "start",
	    value: function start() {
	      if (!this.running) {
	        this.running = true;
	        this.started = new Date();
	        this.id = setTimeout(this.callback, this.remaining);
	      }
	
	      return this.remaining;
	    }
	  }, {
	    key: "stop",
	    value: function stop() {
	      if (this.running) {
	        this.running = false;
	        clearTimeout(this.id);
	        this.remaining -= new Date() - this.started;
	      }
	
	      return this.remaining;
	    }
	  }, {
	    key: "increase",
	    value: function increase(n) {
	      var running = this.running;
	
	      if (running) {
	        this.stop();
	      }
	
	      this.remaining += n;
	
	      if (running) {
	        this.start();
	      }
	
	      return this.remaining;
	    }
	  }, {
	    key: "getTimerLeft",
	    value: function getTimerLeft() {
	      if (this.running) {
	        this.stop();
	        this.start();
	      }
	
	      return this.remaining;
	    }
	  }, {
	    key: "isRunning",
	    value: function isRunning() {
	      return this.running;
	    }
	  }]);
	
	  return Timer;
	}();
	
	var defaultInputValidators = {
	  email: function email(string, validationMessage) {
	    return /^[a-zA-Z0-9.+_-]+@[a-zA-Z0-9.-]+\.[a-zA-Z0-9-]{2,24}$/.test(string) ? Promise.resolve() : Promise.resolve(validationMessage || 'Invalid email address');
	  },
	  url: function url(string, validationMessage) {
	    // taken from https://stackoverflow.com/a/3809435 with a small change from #1306
	    return /^https?:\/\/(www\.)?[-a-zA-Z0-9@:%._+~#=]{2,256}\.[a-z]{2,63}\b([-a-zA-Z0-9@:%_+.~#?&/=]*)$/.test(string) ? Promise.resolve() : Promise.resolve(validationMessage || 'Invalid URL');
	  }
	};
	
	function setDefaultInputValidators(params) {
	  // Use default `inputValidator` for supported input types if not provided
	  if (!params.inputValidator) {
	    Object.keys(defaultInputValidators).forEach(function (key) {
	      if (params.input === key) {
	        params.inputValidator = defaultInputValidators[key];
	      }
	    });
	  }
	}
	
	function validateCustomTargetElement(params) {
	  // Determine if the custom target element is valid
	  if (!params.target || typeof params.target === 'string' && !document.querySelector(params.target) || typeof params.target !== 'string' && !params.target.appendChild) {
	    warn('Target parameter is not valid, defaulting to "body"');
	    params.target = 'body';
	  }
	}
	/**
	 * Set type, text and actions on popup
	 *
	 * @param params
	 * @returns {boolean}
	 */
	
	
	function setParameters(params) {
	  setDefaultInputValidators(params); // showLoaderOnConfirm && preConfirm
	
	  if (params.showLoaderOnConfirm && !params.preConfirm) {
	    warn('showLoaderOnConfirm is set to true, but preConfirm is not defined.\n' + 'showLoaderOnConfirm should be used together with preConfirm, see usage example:\n' + 'https://sweetalert2.github.io/#ajax-request');
	  } // params.animation will be actually used in renderPopup.js
	  // but in case when params.animation is a function, we need to call that function
	  // before popup (re)initialization, so it'll be possible to check Swal.isVisible()
	  // inside the params.animation function
	
	
	  params.animation = callIfFunction(params.animation);
	  validateCustomTargetElement(params); // Replace newlines with <br> in title
	
	  if (typeof params.title === 'string') {
	    params.title = params.title.split('\n').join('<br />');
	  }
	
	  init(params);
	}
	
	function swalOpenAnimationFinished(popup, container) {
	  popup.removeEventListener(animationEndEvent, swalOpenAnimationFinished);
	  container.style.overflowY = 'auto';
	}
	/**
	 * Open popup, add necessary classes and styles, fix scrollbar
	 *
	 * @param {Array} params
	 */
	
	
	var openPopup = function openPopup(params) {
	  var container = getContainer();
	  var popup = getPopup();
	
	  if (typeof params.onBeforeOpen === 'function') {
	    params.onBeforeOpen(popup);
	  }
	
	  addClasses(container, popup, params); // scrolling is 'hidden' until animation is done, after that 'auto'
	
	  setScrollingVisibility(container, popup);
	
	  if (isModal()) {
	    fixScrollContainer(container, params.scrollbarPadding);
	  }
	
	  if (!isToast() && !globalState.previousActiveElement) {
	    globalState.previousActiveElement = document.activeElement;
	  }
	
	  if (typeof params.onOpen === 'function') {
	    setTimeout(function () {
	      return params.onOpen(popup);
	    });
	  }
	};
	
	var setScrollingVisibility = function setScrollingVisibility(container, popup) {
	  if (animationEndEvent && hasCssAnimation(popup)) {
	    container.style.overflowY = 'hidden';
	    popup.addEventListener(animationEndEvent, swalOpenAnimationFinished.bind(null, popup, container));
	  } else {
	    container.style.overflowY = 'auto';
	  }
	};
	
	var fixScrollContainer = function fixScrollContainer(container, scrollbarPadding) {
	  iOSfix();
	  IEfix();
	  setAriaHidden();
	
	  if (scrollbarPadding) {
	    fixScrollbar();
	  } // sweetalert2/issues/1247
	
	
	  setTimeout(function () {
	    container.scrollTop = 0;
	  });
	};
	
	var addClasses = function addClasses(container, popup, params) {
	  if (params.animation) {
	    addClass(popup, swalClasses.show);
	  }
	
	  show(popup);
	  addClass([document.documentElement, document.body, container], swalClasses.shown);
	
	  if (params.heightAuto && params.backdrop && !params.toast) {
	    addClass([document.documentElement, document.body], swalClasses['height-auto']);
	  }
	};
	
	var handleInputOptionsAndValue = function handleInputOptionsAndValue(instance, params) {
	  if (params.input === 'select' || params.input === 'radio') {
	    handleInputOptions(instance, params);
	  } else if (['text', 'email', 'number', 'tel', 'textarea'].indexOf(params.input) !== -1 && isPromise(params.inputValue)) {
	    handleInputValue(instance, params);
	  }
	};
	var getInputValue = function getInputValue(instance, innerParams) {
	  var input = instance.getInput();
	
	  if (!input) {
	    return null;
	  }
	
	  switch (innerParams.input) {
	    case 'checkbox':
	      return getCheckboxValue(input);
	
	    case 'radio':
	      return getRadioValue(input);
	
	    case 'file':
	      return getFileValue(input);
	
	    default:
	      return innerParams.inputAutoTrim ? input.value.trim() : input.value;
	  }
	};
	
	var getCheckboxValue = function getCheckboxValue(input) {
	  return input.checked ? 1 : 0;
	};
	
	var getRadioValue = function getRadioValue(input) {
	  return input.checked ? input.value : null;
	};
	
	var getFileValue = function getFileValue(input) {
	  return input.files.length ? input.getAttribute('multiple') !== null ? input.files : input.files[0] : null;
	};
	
	var handleInputOptions = function handleInputOptions(instance, params) {
	  var content = getContent();
	
	  var processInputOptions = function processInputOptions(inputOptions) {
	    return populateInputOptions[params.input](content, formatInputOptions(inputOptions), params);
	  };
	
	  if (isPromise(params.inputOptions)) {
	    showLoading();
	    params.inputOptions.then(function (inputOptions) {
	      instance.hideLoading();
	      processInputOptions(inputOptions);
	    });
	  } else if (_typeof(params.inputOptions) === 'object') {
	    processInputOptions(params.inputOptions);
	  } else {
	    error("Unexpected type of inputOptions! Expected object, Map or Promise, got ".concat(_typeof(params.inputOptions)));
	  }
	};
	
	var handleInputValue = function handleInputValue(instance, params) {
	  var input = instance.getInput();
	  hide(input);
	  params.inputValue.then(function (inputValue) {
	    input.value = params.input === 'number' ? parseFloat(inputValue) || 0 : inputValue + '';
	    show(input);
	    input.focus();
	    instance.hideLoading();
	  })["catch"](function (err) {
	    error('Error in inputValue promise: ' + err);
	    input.value = '';
	    show(input);
	    input.focus();
	    instance.hideLoading();
	  });
	};
	
	var populateInputOptions = {
	  select: function select(content, inputOptions, params) {
	    var select = getChildByClass(content, swalClasses.select);
	    inputOptions.forEach(function (inputOption) {
	      var optionValue = inputOption[0];
	      var optionLabel = inputOption[1];
	      var option = document.createElement('option');
	      option.value = optionValue;
	      option.innerHTML = optionLabel;
	
	      if (params.inputValue.toString() === optionValue.toString()) {
	        option.selected = true;
	      }
	
	      select.appendChild(option);
	    });
	    select.focus();
	  },
	  radio: function radio(content, inputOptions, params) {
	    var radio = getChildByClass(content, swalClasses.radio);
	    inputOptions.forEach(function (inputOption) {
	      var radioValue = inputOption[0];
	      var radioLabel = inputOption[1];
	      var radioInput = document.createElement('input');
	      var radioLabelElement = document.createElement('label');
	      radioInput.type = 'radio';
	      radioInput.name = swalClasses.radio;
	      radioInput.value = radioValue;
	
	      if (params.inputValue.toString() === radioValue.toString()) {
	        radioInput.checked = true;
	      }
	
	      var label = document.createElement('span');
	      label.innerHTML = radioLabel;
	      label.className = swalClasses.label;
	      radioLabelElement.appendChild(radioInput);
	      radioLabelElement.appendChild(label);
	      radio.appendChild(radioLabelElement);
	    });
	    var radios = radio.querySelectorAll('input');
	
	    if (radios.length) {
	      radios[0].focus();
	    }
	  }
	};
	/**
	 * Converts `inputOptions` into an array of `[value, label]`s
	 * @param inputOptions
	 */
	
	var formatInputOptions = function formatInputOptions(inputOptions) {
	  var result = [];
	
	  if (typeof Map !== 'undefined' && inputOptions instanceof Map) {
	    inputOptions.forEach(function (value, key) {
	      result.push([key, value]);
	    });
	  } else {
	    Object.keys(inputOptions).forEach(function (key) {
	      result.push([key, inputOptions[key]]);
	    });
	  }
	
	  return result;
	};
	
	var handleConfirmButtonClick = function handleConfirmButtonClick(instance, innerParams) {
	  instance.disableButtons();
	
	  if (innerParams.input) {
	    handleConfirmWithInput(instance, innerParams);
	  } else {
	    confirm(instance, innerParams, true);
	  }
	};
	var handleCancelButtonClick = function handleCancelButtonClick(instance, dismissWith) {
	  instance.disableButtons();
	  dismissWith(DismissReason.cancel);
	};
	
	var handleConfirmWithInput = function handleConfirmWithInput(instance, innerParams) {
	  var inputValue = getInputValue(instance, innerParams);
	
	  if (innerParams.inputValidator) {
	    instance.disableInput();
	    var validationPromise = Promise.resolve().then(function () {
	      return innerParams.inputValidator(inputValue, innerParams.validationMessage);
	    });
	    validationPromise.then(function (validationMessage) {
	      instance.enableButtons();
	      instance.enableInput();
	
	      if (validationMessage) {
	        instance.showValidationMessage(validationMessage);
	      } else {
	        confirm(instance, innerParams, inputValue);
	      }
	    });
	  } else if (!instance.getInput().checkValidity()) {
	    instance.enableButtons();
	    instance.showValidationMessage(innerParams.validationMessage);
	  } else {
	    confirm(instance, innerParams, inputValue);
	  }
	};
	
	var succeedWith = function succeedWith(instance, value) {
	  instance.closePopup({
	    value: value
	  });
	};
	
	var confirm = function confirm(instance, innerParams, value) {
	  if (innerParams.showLoaderOnConfirm) {
	    showLoading(); // TODO: make showLoading an *instance* method
	  }
	
	  if (innerParams.preConfirm) {
	    instance.resetValidationMessage();
	    var preConfirmPromise = Promise.resolve().then(function () {
	      return innerParams.preConfirm(value, innerParams.validationMessage);
	    });
	    preConfirmPromise.then(function (preConfirmValue) {
	      if (isVisible(getValidationMessage()) || preConfirmValue === false) {
	        instance.hideLoading();
	      } else {
	        succeedWith(instance, typeof preConfirmValue === 'undefined' ? value : preConfirmValue);
	      }
	    });
	  } else {
	    succeedWith(instance, value);
	  }
	};
	
	var addKeydownHandler = function addKeydownHandler(instance, globalState, innerParams, dismissWith) {
	  if (globalState.keydownTarget && globalState.keydownHandlerAdded) {
	    globalState.keydownTarget.removeEventListener('keydown', globalState.keydownHandler, {
	      capture: globalState.keydownListenerCapture
	    });
	    globalState.keydownHandlerAdded = false;
	  }
	
	  if (!innerParams.toast) {
	    globalState.keydownHandler = function (e) {
	      return keydownHandler(instance, e, innerParams, dismissWith);
	    };
	
	    globalState.keydownTarget = innerParams.keydownListenerCapture ? window : getPopup();
	    globalState.keydownListenerCapture = innerParams.keydownListenerCapture;
	    globalState.keydownTarget.addEventListener('keydown', globalState.keydownHandler, {
	      capture: globalState.keydownListenerCapture
	    });
	    globalState.keydownHandlerAdded = true;
	  }
	}; // Focus handling
	
	var setFocus = function setFocus(innerParams, index, increment) {
	  var focusableElements = getFocusableElements(); // search for visible elements and select the next possible match
	
	  for (var i = 0; i < focusableElements.length; i++) {
	    index = index + increment; // rollover to first item
	
	    if (index === focusableElements.length) {
	      index = 0; // go to last item
	    } else if (index === -1) {
	      index = focusableElements.length - 1;
	    }
	
	    return focusableElements[index].focus();
	  } // no visible focusable elements, focus the popup
	
	
	  getPopup().focus();
	};
	var arrowKeys = ['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown', 'Left', 'Right', 'Up', 'Down' // IE11
	];
	var escKeys = ['Escape', 'Esc' // IE11
	];
	
	var keydownHandler = function keydownHandler(instance, e, innerParams, dismissWith) {
	  if (innerParams.stopKeydownPropagation) {
	    e.stopPropagation();
	  } // ENTER
	
	
	  if (e.key === 'Enter') {
	    handleEnter(instance, e, innerParams); // TAB
	  } else if (e.key === 'Tab') {
	    handleTab(e, innerParams); // ARROWS - switch focus between buttons
	  } else if (arrowKeys.indexOf(e.key) !== -1) {
	    handleArrows(); // ESC
	  } else if (escKeys.indexOf(e.key) !== -1) {
	    handleEsc(e, innerParams, dismissWith);
	  }
	};
	
	var handleEnter = function handleEnter(instance, e, innerParams) {
	  // #720 #721
	  if (e.isComposing) {
	    return;
	  }
	
	  if (e.target && instance.getInput() && e.target.outerHTML === instance.getInput().outerHTML) {
	    if (['textarea', 'file'].indexOf(innerParams.input) !== -1) {
	      return; // do not submit
	    }
	
	    clickConfirm();
	    e.preventDefault();
	  }
	};
	
	var handleTab = function handleTab(e, innerParams) {
	  var targetElement = e.target;
	  var focusableElements = getFocusableElements();
	  var btnIndex = -1;
	
	  for (var i = 0; i < focusableElements.length; i++) {
	    if (targetElement === focusableElements[i]) {
	      btnIndex = i;
	      break;
	    }
	  }
	
	  if (!e.shiftKey) {
	    // Cycle to the next button
	    setFocus(innerParams, btnIndex, 1);
	  } else {
	    // Cycle to the prev button
	    setFocus(innerParams, btnIndex, -1);
	  }
	
	  e.stopPropagation();
	  e.preventDefault();
	};
	
	var handleArrows = function handleArrows() {
	  var confirmButton = getConfirmButton();
	  var cancelButton = getCancelButton(); // focus Cancel button if Confirm button is currently focused
	
	  if (document.activeElement === confirmButton && isVisible(cancelButton)) {
	    cancelButton.focus(); // and vice versa
	  } else if (document.activeElement === cancelButton && isVisible(confirmButton)) {
	    confirmButton.focus();
	  }
	};
	
	var handleEsc = function handleEsc(e, innerParams, dismissWith) {
	  if (callIfFunction(innerParams.allowEscapeKey)) {
	    e.preventDefault();
	    dismissWith(DismissReason.esc);
	  }
	};
	
	var handlePopupClick = function handlePopupClick(domCache, innerParams, dismissWith) {
	  if (innerParams.toast) {
	    handleToastClick(domCache, innerParams, dismissWith);
	  } else {
	    // Ignore click events that had mousedown on the popup but mouseup on the container
	    // This can happen when the user drags a slider
	    handleModalMousedown(domCache); // Ignore click events that had mousedown on the container but mouseup on the popup
	
	    handleContainerMousedown(domCache);
	    handleModalClick(domCache, innerParams, dismissWith);
	  }
	};
	
	var handleToastClick = function handleToastClick(domCache, innerParams, dismissWith) {
	  // Closing toast by internal click
	  domCache.popup.onclick = function () {
	    if (innerParams.showConfirmButton || innerParams.showCancelButton || innerParams.showCloseButton || innerParams.input) {
	      return;
	    }
	
	    dismissWith(DismissReason.close);
	  };
	};
	
	var ignoreOutsideClick = false;
	
	var handleModalMousedown = function handleModalMousedown(domCache) {
	  domCache.popup.onmousedown = function () {
	    domCache.container.onmouseup = function (e) {
	      domCache.container.onmouseup = undefined; // We only check if the mouseup target is the container because usually it doesn't
	      // have any other direct children aside of the popup
	
	      if (e.target === domCache.container) {
	        ignoreOutsideClick = true;
	      }
	    };
	  };
	};
	
	var handleContainerMousedown = function handleContainerMousedown(domCache) {
	  domCache.container.onmousedown = function () {
	    domCache.popup.onmouseup = function (e) {
	      domCache.popup.onmouseup = undefined; // We also need to check if the mouseup target is a child of the popup
	
	      if (e.target === domCache.popup || domCache.popup.contains(e.target)) {
	        ignoreOutsideClick = true;
	      }
	    };
	  };
	};
	
	var handleModalClick = function handleModalClick(domCache, innerParams, dismissWith) {
	  domCache.container.onclick = function (e) {
	    if (ignoreOutsideClick) {
	      ignoreOutsideClick = false;
	      return;
	    }
	
	    if (e.target === domCache.container && callIfFunction(innerParams.allowOutsideClick)) {
	      dismissWith(DismissReason.backdrop);
	    }
	  };
	};
	
	function _main(userParams) {
	  showWarningsForParams(userParams); // Check if there is another Swal closing
	
	  if (getPopup() && globalState.swalCloseEventFinishedCallback) {
	    globalState.swalCloseEventFinishedCallback();
	    delete globalState.swalCloseEventFinishedCallback;
	  } // Check if there is a swal disposal defer timer
	
	
	  if (globalState.deferDisposalTimer) {
	    clearTimeout(globalState.deferDisposalTimer);
	    delete globalState.deferDisposalTimer;
	  }
	
	  var innerParams = _extends({}, defaultParams, userParams);
	
	  setParameters(innerParams);
	  Object.freeze(innerParams); // clear the previous timer
	
	  if (globalState.timeout) {
	    globalState.timeout.stop();
	    delete globalState.timeout;
	  } // clear the restore focus timeout
	
	
	  clearTimeout(globalState.restoreFocusTimeout);
	  var domCache = populateDomCache(this);
	  render(this, innerParams);
	  privateProps.innerParams.set(this, innerParams);
	  return swalPromise(this, domCache, innerParams);
	}
	
	var swalPromise = function swalPromise(instance, domCache, innerParams) {
	  return new Promise(function (resolve) {
	    // functions to handle all closings/dismissals
	    var dismissWith = function dismissWith(dismiss) {
	      instance.closePopup({
	        dismiss: dismiss
	      });
	    };
	
	    privateMethods.swalPromiseResolve.set(instance, resolve);
	    setupTimer(globalState, innerParams, dismissWith);
	
	    domCache.confirmButton.onclick = function () {
	      return handleConfirmButtonClick(instance, innerParams);
	    };
	
	    domCache.cancelButton.onclick = function () {
	      return handleCancelButtonClick(instance, dismissWith);
	    };
	
	    domCache.closeButton.onclick = function () {
	      return dismissWith(DismissReason.close);
	    };
	
	    handlePopupClick(domCache, innerParams, dismissWith);
	    addKeydownHandler(instance, globalState, innerParams, dismissWith);
	
	    if (innerParams.toast && (innerParams.input || innerParams.footer || innerParams.showCloseButton)) {
	      addClass(document.body, swalClasses['toast-column']);
	    } else {
	      removeClass(document.body, swalClasses['toast-column']);
	    }
	
	    handleInputOptionsAndValue(instance, innerParams);
	    openPopup(innerParams);
	    initFocus(domCache, innerParams); // Scroll container to top on open (#1247)
	
	    domCache.container.scrollTop = 0;
	  });
	};
	
	var populateDomCache = function populateDomCache(instance) {
	  var domCache = {
	    popup: getPopup(),
	    container: getContainer(),
	    content: getContent(),
	    actions: getActions(),
	    confirmButton: getConfirmButton(),
	    cancelButton: getCancelButton(),
	    closeButton: getCloseButton(),
	    validationMessage: getValidationMessage(),
	    progressSteps: getProgressSteps()
	  };
	  privateProps.domCache.set(instance, domCache);
	  return domCache;
	};
	
	var setupTimer = function setupTimer(globalState$$1, innerParams, dismissWith) {
	  if (innerParams.timer) {
	    globalState$$1.timeout = new Timer(function () {
	      dismissWith('timer');
	      delete globalState$$1.timeout;
	    }, innerParams.timer);
	  }
	};
	
	var initFocus = function initFocus(domCache, innerParams) {
	  if (innerParams.toast) {
	    return;
	  }
	
	  if (!callIfFunction(innerParams.allowEnterKey)) {
	    return blurActiveElement();
	  }
	
	  if (innerParams.focusCancel && isVisible(domCache.cancelButton)) {
	    return domCache.cancelButton.focus();
	  }
	
	  if (innerParams.focusConfirm && isVisible(domCache.confirmButton)) {
	    return domCache.confirmButton.focus();
	  }
	
	  setFocus(innerParams, -1, 1);
	};
	
	var blurActiveElement = function blurActiveElement() {
	  if (document.activeElement && typeof document.activeElement.blur === 'function') {
	    document.activeElement.blur();
	  }
	};
	
	/**
	 * Updates popup parameters.
	 */
	
	function update(params) {
	  var popup = getPopup();
	
	  if (!popup || hasClass(popup, swalClasses.hide)) {
	    return warn("You're trying to update the closed or closing popup, that won't work. Use the update() method in preConfirm parameter or show a new popup.");
	  }
	
	  var validUpdatableParams = {}; // assign valid params from `params` to `defaults`
	
	  Object.keys(params).forEach(function (param) {
	    if (Swal.isUpdatableParameter(param)) {
	      validUpdatableParams[param] = params[param];
	    } else {
	      warn("Invalid parameter to update: \"".concat(param, "\". Updatable params are listed here: https://github.com/sweetalert2/sweetalert2/blob/master/src/utils/params.js"));
	    }
	  });
	  var innerParams = privateProps.innerParams.get(this);
	
	  var updatedParams = _extends({}, innerParams, validUpdatableParams);
	
	  render(this, updatedParams);
	  privateProps.innerParams.set(this, updatedParams);
	  Object.defineProperties(this, {
	    params: {
	      value: _extends({}, this.params, params),
	      writable: false,
	      enumerable: true
	    }
	  });
	}
	
	
	
	var instanceMethods = Object.freeze({
		hideLoading: hideLoading,
		disableLoading: hideLoading,
		getInput: getInput$1,
		close: close,
		closePopup: close,
		closeModal: close,
		closeToast: close,
		enableButtons: enableButtons,
		disableButtons: disableButtons,
		enableConfirmButton: enableConfirmButton,
		disableConfirmButton: disableConfirmButton,
		enableInput: enableInput,
		disableInput: disableInput,
		showValidationMessage: showValidationMessage,
		resetValidationMessage: resetValidationMessage$1,
		getProgressSteps: getProgressSteps$1,
		setProgressSteps: setProgressSteps,
		showProgressSteps: showProgressSteps,
		hideProgressSteps: hideProgressSteps,
		_main: _main,
		update: update
	});
	
	var currentInstance; // SweetAlert constructor
	
	function SweetAlert() {
	  // Prevent run in Node env
	
	  /* istanbul ignore if */
	  if (typeof window === 'undefined') {
	    return;
	  } // Check for the existence of Promise
	
	  /* istanbul ignore if */
	
	
	  if (typeof Promise === 'undefined') {
	    error('This package requires a Promise library, please include a shim to enable it in this browser (See: https://github.com/sweetalert2/sweetalert2/wiki/Migration-from-SweetAlert-to-SweetAlert2#1-ie-support)');
	  }
	
	  currentInstance = this;
	
	  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
	    args[_key] = arguments[_key];
	  }
	
	  var outerParams = Object.freeze(this.constructor.argsToParams(args));
	  Object.defineProperties(this, {
	    params: {
	      value: outerParams,
	      writable: false,
	      enumerable: true,
	      configurable: true
	    }
	  });
	
	  var promise = this._main(this.params);
	
	  privateProps.promise.set(this, promise);
	} // `catch` cannot be the name of a module export, so we define our thenable methods here instead
	
	
	SweetAlert.prototype.then = function (onFulfilled) {
	  var promise = privateProps.promise.get(this);
	  return promise.then(onFulfilled);
	};
	
	SweetAlert.prototype["finally"] = function (onFinally) {
	  var promise = privateProps.promise.get(this);
	  return promise["finally"](onFinally);
	}; // Assign instance methods from src/instanceMethods/*.js to prototype
	
	
	_extends(SweetAlert.prototype, instanceMethods); // Assign static methods from src/staticMethods/*.js to constructor
	
	
	_extends(SweetAlert, staticMethods); // Proxy to instance methods to constructor, for now, for backwards compatibility
	
	
	Object.keys(instanceMethods).forEach(function (key) {
	  SweetAlert[key] = function () {
	    if (currentInstance) {
	      var _currentInstance;
	
	      return (_currentInstance = currentInstance)[key].apply(_currentInstance, arguments);
	    }
	  };
	});
	SweetAlert.DismissReason = DismissReason;
	SweetAlert.version = '8.19.0';
	
	var Swal = SweetAlert;
	Swal["default"] = Swal;
	
	return Swal;
	
	})));
	if (typeof this !== 'undefined' && this.Sweetalert2){  this.swal = this.sweetAlert = this.Swal = this.SweetAlert = this.Sweetalert2}
	
	"undefined"!=typeof document&&function(e,t){var n=e.createElement("style");if(e.getElementsByTagName("head")[0].appendChild(n),n.styleSheet)n.styleSheet.disabled||(n.styleSheet.cssText=t);else try{n.innerHTML=t}catch(e){n.innerText=t}}(document,"@charset \"UTF-8\";.swal2-popup.swal2-toast{flex-direction:row;align-items:center;width:auto;padding:.625em;overflow-y:hidden;box-shadow:0 0 .625em #d9d9d9}.swal2-popup.swal2-toast .swal2-header{flex-direction:row}.swal2-popup.swal2-toast .swal2-title{flex-grow:1;justify-content:flex-start;margin:0 .6em;font-size:1em}.swal2-popup.swal2-toast .swal2-footer{margin:.5em 0 0;padding:.5em 0 0;font-size:.8em}.swal2-popup.swal2-toast .swal2-close{position:static;width:.8em;height:.8em;line-height:.8}.swal2-popup.swal2-toast .swal2-content{justify-content:flex-start;font-size:1em}.swal2-popup.swal2-toast .swal2-icon{width:2em;min-width:2em;height:2em;margin:0}.swal2-popup.swal2-toast .swal2-icon::before{display:flex;align-items:center;font-size:2em;font-weight:700}@media all and (-ms-high-contrast:none),(-ms-high-contrast:active){.swal2-popup.swal2-toast .swal2-icon::before{font-size:.25em}}.swal2-popup.swal2-toast .swal2-icon.swal2-success .swal2-success-ring{width:2em;height:2em}.swal2-popup.swal2-toast .swal2-icon.swal2-error [class^=swal2-x-mark-line]{top:.875em;width:1.375em}.swal2-popup.swal2-toast .swal2-icon.swal2-error [class^=swal2-x-mark-line][class$=left]{left:.3125em}.swal2-popup.swal2-toast .swal2-icon.swal2-error [class^=swal2-x-mark-line][class$=right]{right:.3125em}.swal2-popup.swal2-toast .swal2-actions{flex-basis:auto!important;width:auto;height:auto;margin:0 .3125em}.swal2-popup.swal2-toast .swal2-styled{margin:0 .3125em;padding:.3125em .625em;font-size:1em}.swal2-popup.swal2-toast .swal2-styled:focus{box-shadow:0 0 0 .0625em #fff,0 0 0 .125em rgba(50,100,150,.4)}.swal2-popup.swal2-toast .swal2-success{border-color:#a5dc86}.swal2-popup.swal2-toast .swal2-success [class^=swal2-success-circular-line]{position:absolute;width:1.6em;height:3em;transform:rotate(45deg);border-radius:50%}.swal2-popup.swal2-toast .swal2-success [class^=swal2-success-circular-line][class$=left]{top:-.8em;left:-.5em;transform:rotate(-45deg);transform-origin:2em 2em;border-radius:4em 0 0 4em}.swal2-popup.swal2-toast .swal2-success [class^=swal2-success-circular-line][class$=right]{top:-.25em;left:.9375em;transform-origin:0 1.5em;border-radius:0 4em 4em 0}.swal2-popup.swal2-toast .swal2-success .swal2-success-ring{width:2em;height:2em}.swal2-popup.swal2-toast .swal2-success .swal2-success-fix{top:0;left:.4375em;width:.4375em;height:2.6875em}.swal2-popup.swal2-toast .swal2-success [class^=swal2-success-line]{height:.3125em}.swal2-popup.swal2-toast .swal2-success [class^=swal2-success-line][class$=tip]{top:1.125em;left:.1875em;width:.75em}.swal2-popup.swal2-toast .swal2-success [class^=swal2-success-line][class$=long]{top:.9375em;right:.1875em;width:1.375em}.swal2-popup.swal2-toast.swal2-show{-webkit-animation:swal2-toast-show .5s;animation:swal2-toast-show .5s}.swal2-popup.swal2-toast.swal2-hide{-webkit-animation:swal2-toast-hide .1s forwards;animation:swal2-toast-hide .1s forwards}.swal2-popup.swal2-toast .swal2-animate-success-icon .swal2-success-line-tip{-webkit-animation:swal2-toast-animate-success-line-tip .75s;animation:swal2-toast-animate-success-line-tip .75s}.swal2-popup.swal2-toast .swal2-animate-success-icon .swal2-success-line-long{-webkit-animation:swal2-toast-animate-success-line-long .75s;animation:swal2-toast-animate-success-line-long .75s}.swal2-container{display:flex;position:fixed;z-index:1060;top:0;right:0;bottom:0;left:0;flex-direction:row;align-items:center;justify-content:center;padding:.625em;overflow-x:hidden;transition:background-color .1s;background-color:transparent;-webkit-overflow-scrolling:touch}.swal2-container.swal2-top{align-items:flex-start}.swal2-container.swal2-top-left,.swal2-container.swal2-top-start{align-items:flex-start;justify-content:flex-start}.swal2-container.swal2-top-end,.swal2-container.swal2-top-right{align-items:flex-start;justify-content:flex-end}.swal2-container.swal2-center{align-items:center}.swal2-container.swal2-center-left,.swal2-container.swal2-center-start{align-items:center;justify-content:flex-start}.swal2-container.swal2-center-end,.swal2-container.swal2-center-right{align-items:center;justify-content:flex-end}.swal2-container.swal2-bottom{align-items:flex-end}.swal2-container.swal2-bottom-left,.swal2-container.swal2-bottom-start{align-items:flex-end;justify-content:flex-start}.swal2-container.swal2-bottom-end,.swal2-container.swal2-bottom-right{align-items:flex-end;justify-content:flex-end}.swal2-container.swal2-bottom-end>:first-child,.swal2-container.swal2-bottom-left>:first-child,.swal2-container.swal2-bottom-right>:first-child,.swal2-container.swal2-bottom-start>:first-child,.swal2-container.swal2-bottom>:first-child{margin-top:auto}.swal2-container.swal2-grow-fullscreen>.swal2-modal{display:flex!important;flex:1;align-self:stretch;justify-content:center}.swal2-container.swal2-grow-row>.swal2-modal{display:flex!important;flex:1;align-content:center;justify-content:center}.swal2-container.swal2-grow-column{flex:1;flex-direction:column}.swal2-container.swal2-grow-column.swal2-bottom,.swal2-container.swal2-grow-column.swal2-center,.swal2-container.swal2-grow-column.swal2-top{align-items:center}.swal2-container.swal2-grow-column.swal2-bottom-left,.swal2-container.swal2-grow-column.swal2-bottom-start,.swal2-container.swal2-grow-column.swal2-center-left,.swal2-container.swal2-grow-column.swal2-center-start,.swal2-container.swal2-grow-column.swal2-top-left,.swal2-container.swal2-grow-column.swal2-top-start{align-items:flex-start}.swal2-container.swal2-grow-column.swal2-bottom-end,.swal2-container.swal2-grow-column.swal2-bottom-right,.swal2-container.swal2-grow-column.swal2-center-end,.swal2-container.swal2-grow-column.swal2-center-right,.swal2-container.swal2-grow-column.swal2-top-end,.swal2-container.swal2-grow-column.swal2-top-right{align-items:flex-end}.swal2-container.swal2-grow-column>.swal2-modal{display:flex!important;flex:1;align-content:center;justify-content:center}.swal2-container:not(.swal2-top):not(.swal2-top-start):not(.swal2-top-end):not(.swal2-top-left):not(.swal2-top-right):not(.swal2-center-start):not(.swal2-center-end):not(.swal2-center-left):not(.swal2-center-right):not(.swal2-bottom):not(.swal2-bottom-start):not(.swal2-bottom-end):not(.swal2-bottom-left):not(.swal2-bottom-right):not(.swal2-grow-fullscreen)>.swal2-modal{margin:auto}@media all and (-ms-high-contrast:none),(-ms-high-contrast:active){.swal2-container .swal2-modal{margin:0!important}}.swal2-container.swal2-shown{background-color:rgba(0,0,0,.4)}.swal2-popup{display:none;position:relative;box-sizing:border-box;flex-direction:column;justify-content:center;width:32em;max-width:100%;padding:1.25em;border:none;border-radius:.3125em;background:#fff;font-family:inherit;font-size:1rem}.swal2-popup:focus{outline:0}.swal2-popup.swal2-loading{overflow-y:hidden}.swal2-header{display:flex;flex-direction:column;align-items:center}.swal2-title{position:relative;max-width:100%;margin:0 0 .4em;padding:0;color:#595959;font-size:1.875em;font-weight:600;text-align:center;text-transform:none;word-wrap:break-word}.swal2-actions{display:flex;z-index:1;flex-wrap:wrap;align-items:center;justify-content:center;width:100%;margin:1.25em auto 0}.swal2-actions:not(.swal2-loading) .swal2-styled[disabled]{opacity:.4}.swal2-actions:not(.swal2-loading) .swal2-styled:hover{background-image:linear-gradient(rgba(0,0,0,.1),rgba(0,0,0,.1))}.swal2-actions:not(.swal2-loading) .swal2-styled:active{background-image:linear-gradient(rgba(0,0,0,.2),rgba(0,0,0,.2))}.swal2-actions.swal2-loading .swal2-styled.swal2-confirm{box-sizing:border-box;width:2.5em;height:2.5em;margin:.46875em;padding:0;-webkit-animation:swal2-rotate-loading 1.5s linear 0s infinite normal;animation:swal2-rotate-loading 1.5s linear 0s infinite normal;border:.25em solid transparent;border-radius:100%;border-color:transparent;background-color:transparent!important;color:transparent;cursor:default;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.swal2-actions.swal2-loading .swal2-styled.swal2-cancel{margin-right:30px;margin-left:30px}.swal2-actions.swal2-loading :not(.swal2-styled).swal2-confirm::after{content:\"\";display:inline-block;width:15px;height:15px;margin-left:5px;-webkit-animation:swal2-rotate-loading 1.5s linear 0s infinite normal;animation:swal2-rotate-loading 1.5s linear 0s infinite normal;border:3px solid #999;border-radius:50%;border-right-color:transparent;box-shadow:1px 1px 1px #fff}.swal2-styled{margin:.3125em;padding:.625em 2em;box-shadow:none;font-weight:500}.swal2-styled:not([disabled]){cursor:pointer}.swal2-styled.swal2-confirm{border:0;border-radius:.25em;background:initial;background-color:#3085d6;color:#fff;font-size:1.0625em}.swal2-styled.swal2-cancel{border:0;border-radius:.25em;background:initial;background-color:#aaa;color:#fff;font-size:1.0625em}.swal2-styled:focus{outline:0;box-shadow:0 0 0 2px #fff,0 0 0 4px rgba(50,100,150,.4)}.swal2-styled::-moz-focus-inner{border:0}.swal2-footer{justify-content:center;margin:1.25em 0 0;padding:1em 0 0;border-top:1px solid #eee;color:#545454;font-size:1em}.swal2-image{max-width:100%;margin:1.25em auto}.swal2-close{position:absolute;z-index:2;top:0;right:0;justify-content:center;width:1.2em;height:1.2em;padding:0;overflow:hidden;transition:color .1s ease-out;border:none;border-radius:0;outline:initial;background:0 0;color:#ccc;font-family:serif;font-size:2.5em;line-height:1.2;cursor:pointer}.swal2-close:hover{transform:none;background:0 0;color:#f27474}.swal2-content{z-index:1;justify-content:center;margin:0;padding:0;color:#545454;font-size:1.125em;font-weight:400;line-height:normal;text-align:center;word-wrap:break-word}.swal2-checkbox,.swal2-file,.swal2-input,.swal2-radio,.swal2-select,.swal2-textarea{margin:1em auto}.swal2-file,.swal2-input,.swal2-textarea{box-sizing:border-box;width:100%;transition:border-color .3s,box-shadow .3s;border:1px solid #d9d9d9;border-radius:.1875em;background:inherit;box-shadow:inset 0 1px 1px rgba(0,0,0,.06);color:inherit;font-size:1.125em}.swal2-file.swal2-inputerror,.swal2-input.swal2-inputerror,.swal2-textarea.swal2-inputerror{border-color:#f27474!important;box-shadow:0 0 2px #f27474!important}.swal2-file:focus,.swal2-input:focus,.swal2-textarea:focus{border:1px solid #b4dbed;outline:0;box-shadow:0 0 3px #c4e6f5}.swal2-file::-webkit-input-placeholder,.swal2-input::-webkit-input-placeholder,.swal2-textarea::-webkit-input-placeholder{color:#ccc}.swal2-file::-moz-placeholder,.swal2-input::-moz-placeholder,.swal2-textarea::-moz-placeholder{color:#ccc}.swal2-file:-ms-input-placeholder,.swal2-input:-ms-input-placeholder,.swal2-textarea:-ms-input-placeholder{color:#ccc}.swal2-file::-ms-input-placeholder,.swal2-input::-ms-input-placeholder,.swal2-textarea::-ms-input-placeholder{color:#ccc}.swal2-file::placeholder,.swal2-input::placeholder,.swal2-textarea::placeholder{color:#ccc}.swal2-range{margin:1em auto;background:inherit}.swal2-range input{width:80%}.swal2-range output{width:20%;color:inherit;font-weight:600;text-align:center}.swal2-range input,.swal2-range output{height:2.625em;padding:0;font-size:1.125em;line-height:2.625em}.swal2-input{height:2.625em;padding:0 .75em}.swal2-input[type=number]{max-width:10em}.swal2-file{background:inherit;font-size:1.125em}.swal2-textarea{height:6.75em;padding:.75em}.swal2-select{min-width:50%;max-width:100%;padding:.375em .625em;background:inherit;color:inherit;font-size:1.125em}.swal2-checkbox,.swal2-radio{align-items:center;justify-content:center;background:inherit;color:inherit}.swal2-checkbox label,.swal2-radio label{margin:0 .6em;font-size:1.125em}.swal2-checkbox input,.swal2-radio input{margin:0 .4em}.swal2-validation-message{display:none;align-items:center;justify-content:center;padding:.625em;overflow:hidden;background:#f0f0f0;color:#666;font-size:1em;font-weight:300}.swal2-validation-message::before{content:\"!\";display:inline-block;width:1.5em;min-width:1.5em;height:1.5em;margin:0 .625em;border-radius:50%;background-color:#f27474;color:#fff;font-weight:600;line-height:1.5em;text-align:center}.swal2-icon{position:relative;box-sizing:content-box;justify-content:center;width:5em;height:5em;margin:1.25em auto 1.875em;border:.25em solid transparent;border-radius:50%;font-family:inherit;line-height:5em;cursor:default;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.swal2-icon::before{display:flex;align-items:center;height:92%;font-size:3.75em}.swal2-icon.swal2-error{border-color:#f27474}.swal2-icon.swal2-error .swal2-x-mark{position:relative;flex-grow:1}.swal2-icon.swal2-error [class^=swal2-x-mark-line]{display:block;position:absolute;top:2.3125em;width:2.9375em;height:.3125em;border-radius:.125em;background-color:#f27474}.swal2-icon.swal2-error [class^=swal2-x-mark-line][class$=left]{left:1.0625em;transform:rotate(45deg)}.swal2-icon.swal2-error [class^=swal2-x-mark-line][class$=right]{right:1em;transform:rotate(-45deg)}.swal2-icon.swal2-warning{border-color:#facea8;color:#f8bb86}.swal2-icon.swal2-warning::before{content:\"!\"}.swal2-icon.swal2-info{border-color:#9de0f6;color:#3fc3ee}.swal2-icon.swal2-info::before{content:\"i\"}.swal2-icon.swal2-question{border-color:#c9dae1;color:#87adbd}.swal2-icon.swal2-question::before{content:\"?\"}.swal2-icon.swal2-question.swal2-arabic-question-mark::before{content:\"؟\"}.swal2-icon.swal2-success{border-color:#a5dc86}.swal2-icon.swal2-success [class^=swal2-success-circular-line]{position:absolute;width:3.75em;height:7.5em;transform:rotate(45deg);border-radius:50%}.swal2-icon.swal2-success [class^=swal2-success-circular-line][class$=left]{top:-.4375em;left:-2.0635em;transform:rotate(-45deg);transform-origin:3.75em 3.75em;border-radius:7.5em 0 0 7.5em}.swal2-icon.swal2-success [class^=swal2-success-circular-line][class$=right]{top:-.6875em;left:1.875em;transform:rotate(-45deg);transform-origin:0 3.75em;border-radius:0 7.5em 7.5em 0}.swal2-icon.swal2-success .swal2-success-ring{position:absolute;z-index:2;top:-.25em;left:-.25em;box-sizing:content-box;width:100%;height:100%;border:.25em solid rgba(165,220,134,.3);border-radius:50%}.swal2-icon.swal2-success .swal2-success-fix{position:absolute;z-index:1;top:.5em;left:1.625em;width:.4375em;height:5.625em;transform:rotate(-45deg)}.swal2-icon.swal2-success [class^=swal2-success-line]{display:block;position:absolute;z-index:2;height:.3125em;border-radius:.125em;background-color:#a5dc86}.swal2-icon.swal2-success [class^=swal2-success-line][class$=tip]{top:2.875em;left:.875em;width:1.5625em;transform:rotate(45deg)}.swal2-icon.swal2-success [class^=swal2-success-line][class$=long]{top:2.375em;right:.5em;width:2.9375em;transform:rotate(-45deg)}.swal2-progress-steps{align-items:center;margin:0 0 1.25em;padding:0;background:inherit;font-weight:600}.swal2-progress-steps li{display:inline-block;position:relative}.swal2-progress-steps .swal2-progress-step{z-index:20;width:2em;height:2em;border-radius:2em;background:#3085d6;color:#fff;line-height:2em;text-align:center}.swal2-progress-steps .swal2-progress-step.swal2-active-progress-step{background:#3085d6}.swal2-progress-steps .swal2-progress-step.swal2-active-progress-step~.swal2-progress-step{background:#add8e6;color:#fff}.swal2-progress-steps .swal2-progress-step.swal2-active-progress-step~.swal2-progress-step-line{background:#add8e6}.swal2-progress-steps .swal2-progress-step-line{z-index:10;width:2.5em;height:.4em;margin:0 -1px;background:#3085d6}[class^=swal2]{-webkit-tap-highlight-color:transparent}.swal2-show{-webkit-animation:swal2-show .3s;animation:swal2-show .3s}.swal2-show.swal2-noanimation{-webkit-animation:none;animation:none}.swal2-hide{-webkit-animation:swal2-hide .15s forwards;animation:swal2-hide .15s forwards}.swal2-hide.swal2-noanimation{-webkit-animation:none;animation:none}.swal2-rtl .swal2-close{right:auto;left:0}.swal2-animate-success-icon .swal2-success-line-tip{-webkit-animation:swal2-animate-success-line-tip .75s;animation:swal2-animate-success-line-tip .75s}.swal2-animate-success-icon .swal2-success-line-long{-webkit-animation:swal2-animate-success-line-long .75s;animation:swal2-animate-success-line-long .75s}.swal2-animate-success-icon .swal2-success-circular-line-right{-webkit-animation:swal2-rotate-success-circular-line 4.25s ease-in;animation:swal2-rotate-success-circular-line 4.25s ease-in}.swal2-animate-error-icon{-webkit-animation:swal2-animate-error-icon .5s;animation:swal2-animate-error-icon .5s}.swal2-animate-error-icon .swal2-x-mark{-webkit-animation:swal2-animate-error-x-mark .5s;animation:swal2-animate-error-x-mark .5s}@supports (-ms-accelerator:true){.swal2-range input{width:100%!important}.swal2-range output{display:none}}@media all and (-ms-high-contrast:none),(-ms-high-contrast:active){.swal2-range input{width:100%!important}.swal2-range output{display:none}}@-moz-document url-prefix(){.swal2-close:focus{outline:2px solid rgba(50,100,150,.4)}}@-webkit-keyframes swal2-toast-show{0%{transform:translateY(-.625em) rotateZ(2deg)}33%{transform:translateY(0) rotateZ(-2deg)}66%{transform:translateY(.3125em) rotateZ(2deg)}100%{transform:translateY(0) rotateZ(0)}}@keyframes swal2-toast-show{0%{transform:translateY(-.625em) rotateZ(2deg)}33%{transform:translateY(0) rotateZ(-2deg)}66%{transform:translateY(.3125em) rotateZ(2deg)}100%{transform:translateY(0) rotateZ(0)}}@-webkit-keyframes swal2-toast-hide{100%{transform:rotateZ(1deg);opacity:0}}@keyframes swal2-toast-hide{100%{transform:rotateZ(1deg);opacity:0}}@-webkit-keyframes swal2-toast-animate-success-line-tip{0%{top:.5625em;left:.0625em;width:0}54%{top:.125em;left:.125em;width:0}70%{top:.625em;left:-.25em;width:1.625em}84%{top:1.0625em;left:.75em;width:.5em}100%{top:1.125em;left:.1875em;width:.75em}}@keyframes swal2-toast-animate-success-line-tip{0%{top:.5625em;left:.0625em;width:0}54%{top:.125em;left:.125em;width:0}70%{top:.625em;left:-.25em;width:1.625em}84%{top:1.0625em;left:.75em;width:.5em}100%{top:1.125em;left:.1875em;width:.75em}}@-webkit-keyframes swal2-toast-animate-success-line-long{0%{top:1.625em;right:1.375em;width:0}65%{top:1.25em;right:.9375em;width:0}84%{top:.9375em;right:0;width:1.125em}100%{top:.9375em;right:.1875em;width:1.375em}}@keyframes swal2-toast-animate-success-line-long{0%{top:1.625em;right:1.375em;width:0}65%{top:1.25em;right:.9375em;width:0}84%{top:.9375em;right:0;width:1.125em}100%{top:.9375em;right:.1875em;width:1.375em}}@-webkit-keyframes swal2-show{0%{transform:scale(.7)}45%{transform:scale(1.05)}80%{transform:scale(.95)}100%{transform:scale(1)}}@keyframes swal2-show{0%{transform:scale(.7)}45%{transform:scale(1.05)}80%{transform:scale(.95)}100%{transform:scale(1)}}@-webkit-keyframes swal2-hide{0%{transform:scale(1);opacity:1}100%{transform:scale(.5);opacity:0}}@keyframes swal2-hide{0%{transform:scale(1);opacity:1}100%{transform:scale(.5);opacity:0}}@-webkit-keyframes swal2-animate-success-line-tip{0%{top:1.1875em;left:.0625em;width:0}54%{top:1.0625em;left:.125em;width:0}70%{top:2.1875em;left:-.375em;width:3.125em}84%{top:3em;left:1.3125em;width:1.0625em}100%{top:2.8125em;left:.875em;width:1.5625em}}@keyframes swal2-animate-success-line-tip{0%{top:1.1875em;left:.0625em;width:0}54%{top:1.0625em;left:.125em;width:0}70%{top:2.1875em;left:-.375em;width:3.125em}84%{top:3em;left:1.3125em;width:1.0625em}100%{top:2.8125em;left:.875em;width:1.5625em}}@-webkit-keyframes swal2-animate-success-line-long{0%{top:3.375em;right:2.875em;width:0}65%{top:3.375em;right:2.875em;width:0}84%{top:2.1875em;right:0;width:3.4375em}100%{top:2.375em;right:.5em;width:2.9375em}}@keyframes swal2-animate-success-line-long{0%{top:3.375em;right:2.875em;width:0}65%{top:3.375em;right:2.875em;width:0}84%{top:2.1875em;right:0;width:3.4375em}100%{top:2.375em;right:.5em;width:2.9375em}}@-webkit-keyframes swal2-rotate-success-circular-line{0%{transform:rotate(-45deg)}5%{transform:rotate(-45deg)}12%{transform:rotate(-405deg)}100%{transform:rotate(-405deg)}}@keyframes swal2-rotate-success-circular-line{0%{transform:rotate(-45deg)}5%{transform:rotate(-45deg)}12%{transform:rotate(-405deg)}100%{transform:rotate(-405deg)}}@-webkit-keyframes swal2-animate-error-x-mark{0%{margin-top:1.625em;transform:scale(.4);opacity:0}50%{margin-top:1.625em;transform:scale(.4);opacity:0}80%{margin-top:-.375em;transform:scale(1.15)}100%{margin-top:0;transform:scale(1);opacity:1}}@keyframes swal2-animate-error-x-mark{0%{margin-top:1.625em;transform:scale(.4);opacity:0}50%{margin-top:1.625em;transform:scale(.4);opacity:0}80%{margin-top:-.375em;transform:scale(1.15)}100%{margin-top:0;transform:scale(1);opacity:1}}@-webkit-keyframes swal2-animate-error-icon{0%{transform:rotateX(100deg);opacity:0}100%{transform:rotateX(0);opacity:1}}@keyframes swal2-animate-error-icon{0%{transform:rotateX(100deg);opacity:0}100%{transform:rotateX(0);opacity:1}}@-webkit-keyframes swal2-rotate-loading{0%{transform:rotate(0)}100%{transform:rotate(360deg)}}@keyframes swal2-rotate-loading{0%{transform:rotate(0)}100%{transform:rotate(360deg)}}body.swal2-shown:not(.swal2-no-backdrop):not(.swal2-toast-shown){overflow:hidden}body.swal2-height-auto{height:auto!important}body.swal2-no-backdrop .swal2-shown{top:auto;right:auto;bottom:auto;left:auto;max-width:calc(100% - .625em * 2);background-color:transparent}body.swal2-no-backdrop .swal2-shown>.swal2-modal{box-shadow:0 0 10px rgba(0,0,0,.4)}body.swal2-no-backdrop .swal2-shown.swal2-top{top:0;left:50%;transform:translateX(-50%)}body.swal2-no-backdrop .swal2-shown.swal2-top-left,body.swal2-no-backdrop .swal2-shown.swal2-top-start{top:0;left:0}body.swal2-no-backdrop .swal2-shown.swal2-top-end,body.swal2-no-backdrop .swal2-shown.swal2-top-right{top:0;right:0}body.swal2-no-backdrop .swal2-shown.swal2-center{top:50%;left:50%;transform:translate(-50%,-50%)}body.swal2-no-backdrop .swal2-shown.swal2-center-left,body.swal2-no-backdrop .swal2-shown.swal2-center-start{top:50%;left:0;transform:translateY(-50%)}body.swal2-no-backdrop .swal2-shown.swal2-center-end,body.swal2-no-backdrop .swal2-shown.swal2-center-right{top:50%;right:0;transform:translateY(-50%)}body.swal2-no-backdrop .swal2-shown.swal2-bottom{bottom:0;left:50%;transform:translateX(-50%)}body.swal2-no-backdrop .swal2-shown.swal2-bottom-left,body.swal2-no-backdrop .swal2-shown.swal2-bottom-start{bottom:0;left:0}body.swal2-no-backdrop .swal2-shown.swal2-bottom-end,body.swal2-no-backdrop .swal2-shown.swal2-bottom-right{right:0;bottom:0}@media print{body.swal2-shown:not(.swal2-no-backdrop):not(.swal2-toast-shown){overflow-y:scroll!important}body.swal2-shown:not(.swal2-no-backdrop):not(.swal2-toast-shown)>[aria-hidden=true]{display:none}body.swal2-shown:not(.swal2-no-backdrop):not(.swal2-toast-shown) .swal2-container{position:static!important}}body.swal2-toast-shown .swal2-container{background-color:transparent}body.swal2-toast-shown .swal2-container.swal2-shown{background-color:transparent}body.swal2-toast-shown .swal2-container.swal2-top{top:0;right:auto;bottom:auto;left:50%;transform:translateX(-50%)}body.swal2-toast-shown .swal2-container.swal2-top-end,body.swal2-toast-shown .swal2-container.swal2-top-right{top:0;right:0;bottom:auto;left:auto}body.swal2-toast-shown .swal2-container.swal2-top-left,body.swal2-toast-shown .swal2-container.swal2-top-start{top:0;right:auto;bottom:auto;left:0}body.swal2-toast-shown .swal2-container.swal2-center-left,body.swal2-toast-shown .swal2-container.swal2-center-start{top:50%;right:auto;bottom:auto;left:0;transform:translateY(-50%)}body.swal2-toast-shown .swal2-container.swal2-center{top:50%;right:auto;bottom:auto;left:50%;transform:translate(-50%,-50%)}body.swal2-toast-shown .swal2-container.swal2-center-end,body.swal2-toast-shown .swal2-container.swal2-center-right{top:50%;right:0;bottom:auto;left:auto;transform:translateY(-50%)}body.swal2-toast-shown .swal2-container.swal2-bottom-left,body.swal2-toast-shown .swal2-container.swal2-bottom-start{top:auto;right:auto;bottom:0;left:0}body.swal2-toast-shown .swal2-container.swal2-bottom{top:auto;right:auto;bottom:0;left:50%;transform:translateX(-50%)}body.swal2-toast-shown .swal2-container.swal2-bottom-end,body.swal2-toast-shown .swal2-container.swal2-bottom-right{top:auto;right:0;bottom:0;left:auto}body.swal2-toast-column .swal2-toast{flex-direction:column;align-items:stretch}body.swal2-toast-column .swal2-toast .swal2-actions{flex:1;align-self:stretch;height:2.2em;margin-top:.3125em}body.swal2-toast-column .swal2-toast .swal2-loading{justify-content:center}body.swal2-toast-column .swal2-toast .swal2-input{height:2em;margin:.3125em auto;font-size:1em}body.swal2-toast-column .swal2-toast .swal2-validation-message{font-size:1em}");

/***/ }),
/* 41 */
/***/ (function(module, exports) {

	$('body').on('click', function() {
	    $('.newsfeed-date-filter__box').removeClass('open');
	    $('.news-feed__tomail-box').removeClass('open');
	});

/***/ }),
/* 42 */
/***/ (function(module, exports) {

	checkSomeCheckboxes($('._check-not-all'), 2);
	
	function checkSomeCheckboxes(elementsWrapper, checkedLimit) {
	    elementsWrapper.each(function () {
	        var checkedArray = [];
	        $(this).find('input[type=checkbox]').on('change', function () {
	            var el = $(this);
	            var root = el.closest(elementsWrapper);
	            var elSiblings = root.find('input[type=checkbox]');
	            checkedArray.push(this);
	            if (checkedArray.length > checkedLimit) {
	                checkedArray.splice(0, 1);
	            }
	            if (elSiblings.filter(':checked').length > checkedLimit) {
	                checkedArray = $(checkedArray);
	                elSiblings.prop('checked', false);
	                checkedArray.eq(0).prop('checked', true);
	                el.prop('checked', true);
	            }
	        });
	    });
	}


/***/ }),
/* 43 */
/***/ (function(module, exports) {

	const $classHour = $('.class-hour');
	
	if ($classHour.length > 0) {
	    const search = $classHour.find('.collection-search');
	    const searchButton = $classHour.find('.js-class-hour-search');
	    const typeSelect = $classHour.find('.js-class-hour-type');
	    const classSelect = $classHour.find('.js-class-hour-class');
	
	    searchButton.click(function () {
	        window.location.href = Routing.generate('resh_class_hour', {
	            'search': searchValue = search.find('input').val()
	        });
	    })
	    search.find('input').on('keyup', function(e) {
	        if (e.keyCode === 13) {
	            window.location.href = Routing.generate('resh_class_hour', {
	                'search': searchValue = search.find('input').val()
	            });
	        }
	    });
	    $classHour.on(
	        'change',
	        '.js-class-hour-search, .js-class-hour-type, .js-class-hour-class',
	        function () {
	            const url = Routing.generate('resh_class_hour', getQuery())
	            window.location.href = url;
	        });
	
	    function getQuery() {
	        const searchValue = search.find('input').val();
	        const currentType = typeSelect.chosen().val();
	        const currentClass = classSelect.chosen().val();
	        const result = {};
	        if (searchValue !== "") {
	            result['search'] = searchValue;
	        }
	        if (currentType !== "") {
	            result['type'] = currentType;
	        }
	        if (currentClass !== "") {
	            result['class'] = currentClass;
	        }
	        return result;
	    }
	    $('.mesh-material__arrow').on('click', function(e) {
	        e.preventDefault();
	        $(this).toggleClass('open');
	        $item = $(this).parent();
	        $front = $item.find('.js-mesh-item-front');
	        $back = $item.find('.js-mesh-item-back');
	        $front.toggleClass('open');
	        $back.toggleClass('open');
	    });
	}
	


/***/ }),
/* 44 */
/***/ (function(module, exports) {

	var clickable = $('[class*=_clickable]');
	var close_cross = $('._win-close');
	var timeout;
	var timer = 300;
	var hideable = $('.main').add('.footer');
	var global_container = $('.outer-sf');
	
	clickable.on('click', function (e) {
	
	    e.stopPropagation();
	    var el = $(this);
	    var target;
	
	    var fadeout = function () {
	        el.removeClass('_clicked');
	        if (target !== undefined) {
	            target.removeClass('_triggered');
	            timeout = setTimeout(function () {
	                target.removeClass('_displayed');
	            }, timer);
	        }
	    };
	
	    if (el.attr('data-timer')) {
	        timer = el.data('timer');
	    }
	
	    if (el.attr('data-target')) {
	        $('body').off('click.trigger').find('._clicked, ._triggered').removeClass('_clicked _triggered');
	        $('._displayed').removeClass('_displayed');
	        global_container.show();
	        hideable.show();
	        target = $('.' + el.data('target'));
	        if (el.data('target') == '_login-menu') {
	            var index_clicked = $('.header__login').find('a').index(el);
	            $('.user-action').find('li').removeClass('tab-active').eq(index_clicked).addClass('tab-active');
	            $('.tab-content').removeClass('tab-content-visible').eq(index_clicked).addClass('tab-content-visible');
	        }
	    }
	
	    if (!el.hasClass('_clicked')) {
	        el.addClass('_clicked');
	        window.clearTimeout(timeout);
	        if (target !== undefined) {
	            target.addClass('_triggered _displayed');
	        }
	        if (el.hasClass('_clickable--outer')) {
	            $('body').on('click.trigger', function () {
	                fadeout();
	                $(this).off('click.trigger');
	            })
	        }
	        if (el.data('target') == '_login-menu' || el.data('target') == 'hmbrg-menu') {
	            setTimeout(function () {
	                hideable.hide();
	
	                if (el.data('target') == '_login-menu') {
	                    global_container.hide();
	                }
	            }, timer);
	        }
	    } else {
	        fadeout();
	        $('body').off('click.trigger');
	    }
	
	
	});
	
	close_cross.on('click', function () {
	    $('body').off('click.trigger').find('._clicked, ._triggered').removeClass('_clicked _triggered');
	    timeout = setTimeout(function () {
	        $('._displayed').removeClass('_displayed');
	    }, timer);
	    global_container.show();
	    hideable.show();
	});
	
	$('._stop-prop').on('click', function (e) {
	   e.stopPropagation();
	});
	


/***/ }),
/* 45 */
/***/ (function(module, exports) {

	// var close = $('.icon_delete-cross');
	//
	// close.on('click', function () {
	//     var closed_block = $(this).parent().parent('.block_js'),
	//         /*closed_block2 = $(this).parent().parent('.lk-user-stats'),*/
	//         closed_col = $(this).parent().parent().parent('.lk-col-3');
	//
	//
	//     closed_block.addClass('closeblock');
	//
	//     if (closed_block.siblings('.closeblock').length > 0) {
	//
	//         closed_col.addClass('closeblock');
	//         setTimeout(function () {
	//             $(closed_col).hide(200);
	//         }, 300);
	//     }
	//
	//     else if (closed_block.siblings('.closeblock').length == 0) {
	//
	//         closed_block.addClass('closeblock');
	//         setTimeout(function () {
	//             $(closed_block).hide(200);
	//         }, 300);
	//     }
	// });
	
	var close = $('.icon_delete-cross');
	close.on('click', function () {
	   var closed_block = $(this).parent().parent('.block_js'),
	       blocksLength = $('.lk-right-block').filter(':visible').length - 1,
	       closed_col = $(this).parent().parent().parent('.lk-col-3');
	
	   closed_block.addClass('closeblock');
	   setTimeout(function () {
	      $(closed_block).hide(200);
	   }, 300);
	
	   if (blocksLength < 1) {
	      closed_col.addClass('closeblock');
	      setTimeout(function () {
	         $(closed_col).hide(200);
	      }, 300);
	   }
	});
	
	
	


/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

	var getScrollWidth = __webpack_require__(31)
	
	
	(function ($) {
	    var methods = {
	        init: function () {
	            this.on('click', function () {
	                methods.show('#' + $(this).data('custom-modal'))
	            })
	        },
	        popup: function () {
	            methods.show($(this))
	
	        },
	        show: function (target, callback) {
	            var $target = $(target)
	            if ($target.length) {
	                $('body').css({overflowY: 'hidden', paddingRight: getScrollWidth + 'px'})
	                $target.addClass('js-shown js-modal-animation')
	                if ($target.attr('id')=='add-attestation-modal') {
	                    $target.off('click.closeModal');
	                } else {
	                    $target.off('click.closeModal').on('click.closeModal', function () {
	                        methods.hide(target);
	                    })
	                }
	                $target.find('.custom-modal__content-block').off('click').on('click', function (e) {
	                    e.stopPropagation()
	                });
	
	                if ($target.attr('id')=='add-attestation-modal') {
	                    //$target.find('.js-close-modal').off('click');
	                } else {
	                    $target.find('.js-close-modal').off('click').on('click', function () {
	                        methods.hide(target);
	                    });
	                }
	
	
	                if (typeof callback === "function") {
	                    callback()
	                }
	            }
	        },
	        hide: function (target, callback) {
	            var $target = $(target)
	            if ($target.length) {
	                $target.addClass('js-hide')
	                setTimeout(function () {
	                    $target.removeClass('js-shown js-modal-animation js-hide')
	                    $('body').css({overflowY: '', paddingRight: ''})
	                    if (typeof callback === "function") {
	                        callback()
	                    }
	                    $target.trigger('hide:after')
	                }, 500)
	            }
	            if (typeof callback === "function") {
	                callback()
	            }
	        },
	    };
	
	    $.fn.customModal = function (methodOrOptions) {
	        if (methods[methodOrOptions]) {
	            return methods[methodOrOptions].apply(this, Array.prototype.slice.call(arguments, 1));
	        } else if (typeof methodOrOptions === 'object' || !methodOrOptions) {
	            return methods.init.apply(this, arguments);
	        } else {
	            $.error('Method ' + methodOrOptions + ' does not exist on jQuery.customModal');
	        }
	    }
	
	}(jQuery));
	
	$('[data-custom-modal]').customModal()
	
	/*
	
	method examples:
	
	$('[data-custom-modal]').customModal('show', '#registration-child-modal')
	$('[data-custom-modal]').customModal('hide', '#registration-child-modal')
	
	*/
	
	
	


/***/ }),
/* 47 */
/***/ (function(module, exports) {

	var upButton = $('.page-up');
	
	$(window).scroll(function () {
	    if ($(this).scrollTop() > 150) {
	        upButton.fadeIn();
	    } else {
	        upButton.fadeOut();
	    }
	});


/***/ }),
/* 48 */
/***/ (function(module, exports) {

	$('.favourites .fav-lesson-class select, .favourites .fav-lesson-subject select').chosen().change(function () {
	    $.ajax({
	        type: "GET",
	        url: Routing.generate('private_office_user_favorite'),
	        data: {
	            'class': $('.favourites .fav-lesson-class .chosen-select').val(),
	            'subject': $('.favourites .fav-lesson-subject .chosen-select').val()
	        },
	        success: function (html) {
	            $('.favourites-block').html(html);
	        }
	    })
	});

/***/ }),
/* 49 */
/***/ (function(module, exports) {

	$('.feedback-inputs #feedback_type').on('change', function () {
	    const slug = this.options[this.selectedIndex].dataset.slug;
	    $('.feedback-attach.file').show();
	    $('.js-url, .js-lessonInfo, .js-inn, .feedback-attach.inn, ' +
	        '.feedback-attach.ogrn, .js-schoolClass, .js-subject, .js-lesson').hide();
	    $('.js-schoolClass input, .js-subject input, .js-subject input, .js-lessonInfo input, .js-url input, ' +
	        '.js-inn input, .feedback-attach.ogrn input, .feedback-attach.inn input').removeAttr('required');
	    if (slug === 'lesson_error') {
	        $('.js-schoolClass').show();
	        $('.js-schoolClass .text-danger').show();
	        $('.js-schoolClass input').attr('required', 'required');
	        $('.js-subject').show();
	        $('.js-subject .text-danger').show();
	        $('.js-subject input').attr('required', 'required');
	        $('.js-lesson').show();
	        $('.js-lesson .text-danger').show();
	        $('.js-lesson input').attr('required', 'required');
	    } else if (slug === 'site_error') {
	        $('.js-url').show();
	        $('.js-url .text-danger').show();
	        $('.js-url input').attr('required', 'required');
	    } else if (slug === 'school') {
	        $('.js-inn').show();
	        $('.js-inn .text-danger').show();
	        $('.js-inn input').attr('required', 'required');
	
	        $('.feedback-attach.inn').show();
	        // $('.feedback-attach.inn .text-danger').show();
	        $('.feedback-attach.inn input').attr('required', 'required');
	
	        $('.feedback-attach.ogrn').show();
	        // $('.feedback-attach.ogrn .text-danger').show();
	        $('.feedback-attach.ogrn input').attr('required', 'required');
	
	        $('.feedback-attach.file').hide();
	    }
	});
	
	$(document).ready(function() {
	    let hash = $(location).attr('hash').replace(/^#/, "");
	    if (hash) {
	        $('.feedback-inputs #feedback_type').find('option').each(function () {
	            $(this).attr("selected", false);
	        });
	        $('.feedback-inputs #feedback_type').find('option[data-slug="' + hash + '"]').each(function () {
	            $(this).attr("selected", "selected");
	        });
	    }
	    $('.feedback-inputs #feedback_type').trigger("change").trigger("chosen:updated");
	});

/***/ }),
/* 50 */
/***/ (function(module, exports) {

	//
	//
	//
	//-------------------------------
	// upload button
	//-------------------------------
	//
	
	var uploadForm = $("input[type='file']"),
	    upButtonText = $('.upload-value'),
	    uploadText = upButtonText.html();
	
	$('.upload-fake-butt').click(function () {
	    $(this).parent().find('input[type="file"]').trigger('click');
	});
	
	uploadForm.change(function () {
	
	    var curVal = this.value;
	
	    if (curVal == '') {
	        $(this).parent().find('.upload-value').html(uploadText);
	        $(this).parent().find('.upload-fake-butt').removeClass('file-attached');
	    } else {
	        $(this).parent().find('.upload-value').text(curVal.replace(/^.*[\\\/]/, ''));
	        $(this).parent().find('.upload-fake-butt').addClass('file-attached');
	    }
	
	});


/***/ }),
/* 51 */
/***/ (function(module, exports) {

	$('#ajax-vz_add_btn').on('click', function () {
	    
	    var el_row = $(this).closest('.lk__form-row'),
	        content = el_row.prev().clone(),
	        input_vz = $('#vz').val(),
	        input_spec = $('#spec').val();
	
	    if (input_vz.length && input_spec.length) {
	        el_row.after(content);
	
	        el_row.next().addClass('added-row-displayed').css('display', 'block');
	
	        el_row.siblings('.lk__form-row').eq(3).find('.lk__form-add-data-vz').text(input_vz);
	
	        el_row.siblings('.lk__form-row').eq(3).find('.lk__form-add-data-spec').text(input_spec);
	
	        el_row.siblings('.lk__form-row').eq(0).find('.lk__input-text').val('');
	
	        el_row.siblings('.lk__form-row').eq(1).find('.lk__input-text').val('');
	    }
	});
	


/***/ }),
/* 52 */
/***/ (function(module, exports) {

	const increaseCounter = function () {
	    const video = $(this);
	    $.ajax({
	        type: "POST",
	        url: Routing.generate('resh_guide_materials_counter_increase', {'material': video.data('material-id')}),
	        success: (result) => {
	            video.off('play', increaseCounter)
	        },
	    });
	}
	$('.guide-materials .guide-materials__video').on('play', increaseCounter);

/***/ }),
/* 53 */
/***/ (function(module, exports) {

	function hover_timout(elements, animationTime, delay_time) {
	    $.each(elements, function (index, el) {
	        var timeout;
	        var timeout_display;
	        $(el).hover(function () {
	            var self = $(this);
	            timeout = setTimeout(function () {
	                self.addClass('_hovered _displayed');
	            }, delay_time);
	            if ($(this).hasClass('_displayed')) {
	                clearTimeout(timeout_display);
	            }
	        }, function () {
	            var self = $(this);
	            timeout_display = setTimeout(function () {
	                self.removeClass('_displayed');
	            }, animationTime);
	            clearTimeout(timeout);
	            self.removeClass('_hovered');
	        });
	    });
	}
	
	hover_timout($('._hoverable'), 300, 100);


/***/ }),
/* 54 */
/***/ (function(module, exports) {

	if ( $('.icon_close-sidebar').length > 0 ) {
		var lessonCloseButton = $('.icon_close-sidebar'),
			lessonAnchor = $('.lesson-sidebar'),
			lessonAnchorTop = lessonAnchor.offset().top,
			lessonSidebar = lessonCloseButton.siblings('.lesson-sidebar__item'),
			lessonContent = lessonAnchor.siblings('.lesson-content'),
			startWindowPosition = 0,
			newWindowPosition = 0;
	
		$(window).scroll(function () {
	
			startWindowPosition = $(window).scrollTop();
	
	        var lessonSidebarTopHeight = lessonSidebar.outerHeight(true) + lessonAnchorTop,
	            windowHeight = $(window).height(),
				sidebarHeight = lessonSidebar.outerHeight(true),
				closeSidebarHeight = lessonSidebarTopHeight - windowHeight + 80;
	
			// if ( sidebarHeight > 600 ) {
			// 	if ( startWindowPosition > closeSidebarHeight && startWindowPosition > newWindowPosition ) {
			// 		closeSidebar();
			// 	}
			// } else {
			// 	if ( startWindowPosition > windowHeight && startWindowPosition > newWindowPosition ) {
			// 		closeSidebar();
			// 	}
			// }
	
			newWindowPosition = startWindowPosition;
	
			if ($(this).scrollTop() >= lessonAnchorTop && lessonAnchor.hasClass('sidebar-close') ) {
				lessonCloseButton.addClass('lesson-sidebar-fixed');
			} else {
				lessonCloseButton.removeClass('lesson-sidebar-fixed');
			}
		});
	
		lessonCloseButton.on('click', function(){
	
			var t = $(this);
	
			if (lessonAnchor.hasClass('sidebar-open') && lessonContent.hasClass('lesson-content_close')) {
				closeSidebar();
			}
			else if (lessonAnchor.hasClass('sidebar-close') && lessonContent.hasClass('lesson-content_open')) {
	
				if ( lessonCloseButton.hasClass('lesson-sidebar-fixed') ) {
					$('html, body').animate( { scrollTop: lessonAnchorTop }, 500 );
				}
				t.removeClass('icon_rotate_180').addClass('icon_rotate_0');
				lessonAnchor.removeClass('sidebar-close').addClass('sidebar-open');
				lessonSidebar.removeClass('lesson-sidebar__content_hide').addClass('lesson-sidebar__content_open');
				lessonContent.removeClass('lesson-content_open').addClass('lesson-content_close');
			}
		});
	}
	
	function closeSidebar () {
		lessonCloseButton.removeClass('icon_rotate_0').addClass('icon_rotate_180');
		lessonSidebar.removeClass('lesson-sidebar__content_open').addClass('lesson-sidebar__content_hide');
		lessonContent.removeClass('lesson-content_close').addClass('lesson-content_open');
		lessonAnchor.removeClass('sidebar-open').addClass('sidebar-close');
	}

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

	const iframetracker = __webpack_require__(56);
	console.log(iframetracker)
	
	const $frame = $('.lesson-video__player iframe');
	$frame.iframeTracker({
	    blurCallback: function (event) {
	        var url = $frame.attr('data-url');
	        if (undefined !== url) {
	            $.post(url, function () {
	
	            });
	        }
	    }
	});


/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (root, factory) {
		if (true) {
			!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(7)], __WEBPACK_AMD_DEFINE_RESULT__ = function (a0) {
				return (factory(a0));
			}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		} else if (typeof module === 'object' && module.exports) {
			module.exports = factory(require("jquery"));
		} else {
			factory(root["jQuery"]);
		}
	}(this, function (jQuery) {
	
	/*!
	 * jQuery iframe click tracking plugin
	 *
	 * @author Vincent Paré
	 * @copyright © 2013-2018 Vincent Paré
	 * @license http://opensource.org/licenses/Apache-2.0
	 * @version 2.1.0
	 */
	(function($) {
		// Tracking handler manager
		$.fn.iframeTracker = function(handler) {
			// Building handler object from handler function
			if (typeof handler == "function") {
				handler = {
					blurCallback: handler
				};
			}
	
			var target = this.get();
			if (handler === null || handler === false) {
				$.iframeTracker.untrack(target);
			} else if (typeof handler == "object") {
				$.iframeTracker.track(target, handler);
			} else {
				throw new Error("Wrong handler type (must be an object, or null|false to untrack)");
			}
			return this;
		};
	
		// Iframe tracker common object
		$.iframeTracker = {
			// State
			focusRetriever: null,  // Element used for restoring focus on window (element)
			focusRetrieved: false, // Says if the focus was retrieved on the current page (bool)
			handlersList: [],      // Store a list of every trakers (created by calling $(selector).iframeTracker...)
			isIE8AndOlder: false,  // true for Internet Explorer 8 and older
	
			// Init (called once on document ready)
			init: function() {
				// Determine browser version (IE8-) ($.browser.msie is deprecated since jQuery 1.9)
				try {
					if ($.browser.msie === true && $.browser.version < 9) {
						this.isIE8AndOlder = true;
					}
				} catch (ex) {
					try {
						var matches = navigator.userAgent.match(/(msie) ([\w.]+)/i);
						if (matches[2] < 9) {
							this.isIE8AndOlder = true;
						}
					} catch (ex2) {}
				}
	
				// Listening window blur
				$(window).focus();
				$(window).blur(function(e) {
					$.iframeTracker.windowLoseFocus(e);
				});
	
				// Focus retriever (get the focus back to the page, on mouse move)
				$("body").append('<div style="position:fixed; top:0; left:0; overflow:hidden;"><input style="position:absolute; left:-300px;" type="text" value="" id="focus_retriever" readonly="true" /></div>');
				this.focusRetriever = $("#focus_retriever");
				this.focusRetrieved = false;
	
				// Special processing to make it work with my old friend IE8 (and older) ;)
				if (this.isIE8AndOlder) {
					// Blur doesn't works correctly on IE8-, so we need to trigger it manually
					this.focusRetriever.blur(function(e) {
						e.stopPropagation();
						e.preventDefault();
						$.iframeTracker.windowLoseFocus(e);
					});
	
					// Keep focus on window (fix bug IE8-, focusable elements)
					$("body").click(function(e) {
						$(window).focus();
					});
					$("form").click(function(e) {
						e.stopPropagation();
					});
	
					// Same thing for "post-DOMready" created forms (issue #6)
					try {
						$("body").on("click", "form", function(e) {
							e.stopPropagation();
						});
					} catch (ex) {
						console.log("[iframeTracker] Please update jQuery to 1.7 or newer. (exception: " + ex.message + ")");
					}
				}
			},
	
			// Add tracker to target using handler (bind boundary listener + register handler)
			// target: Array of target elements (native DOM elements)
			// handler: User handler object
			track: function(target, handler) {
				// Adding target elements references into handler
				handler.target = target;
	
				// Storing the new handler into handler list
				$.iframeTracker.handlersList.push(handler);
	
				// Binding boundary listener
				$(target)
					.bind("mouseover", { handler: handler }, $.iframeTracker.mouseoverListener)
					.bind("mouseout",  { handler: handler }, $.iframeTracker.mouseoutListener);
			},
	
			// Remove tracking on target elements
			// target: Array of target elements (native DOM elements)
			untrack: function(target) {
				if (typeof Array.prototype.filter != "function") {
					console.log("Your browser doesn't support Array filter, untrack disabled");
					return;
				}
	
				// Unbinding boundary listener
				$(target).each(function(index) {
					$(this)
						.unbind("mouseover", $.iframeTracker.mouseoverListener)
						.unbind("mouseout", $.iframeTracker.mouseoutListener);
				});
	
				// Handler garbage collector
				var nullFilter = function(value) {
					return value === null ? false : true;
				};
				for (var i in this.handlersList) {
					// Prune target
					for (var j in this.handlersList[i].target) {
						if ($.inArray(this.handlersList[i].target[j], target) !== -1) {
							this.handlersList[i].target[j] = null;
						}
					}
					this.handlersList[i].target = this.handlersList[i].target.filter(nullFilter);
	
					// Delete handler if unused
					if (this.handlersList[i].target.length === 0) {
						this.handlersList[i] = null;
					}
				}
				this.handlersList = this.handlersList.filter(nullFilter);
			},
	
			// Target mouseover event listener
			mouseoverListener: function(e) {
				e.data.handler.over = true;
				$.iframeTracker.retrieveFocus();
				try {
					e.data.handler.overCallback(this, e);
				} catch (ex) {}
			},
	
			// Target mouseout event listener
			mouseoutListener: function(e) {
				e.data.handler.over = false;
				$.iframeTracker.retrieveFocus();
				try {
					e.data.handler.outCallback(this, e);
				} catch (ex) {}
			},
	
			// Give back focus from an iframe to parent page
			retrieveFocus: function() {
				if (document.activeElement && document.activeElement.tagName === "IFRAME") {
					$.iframeTracker.focusRetriever.focus();
					$.iframeTracker.focusRetrieved = true;
				}
			},
	
			// Calls blurCallback for every handler with over=true on window blur
			windowLoseFocus: function(e) {
				for (var i in this.handlersList) {
					if (this.handlersList[i].over === true) {
						try {
							this.handlersList[i].blurCallback(e);
						} catch (ex) {}
					}
				}
			}
		};
	
		// Init the iframeTracker on document ready
		$(document).ready(function() {
			$.iframeTracker.init();
		});
	})(jQuery);
	
	}));


/***/ }),
/* 57 */
/***/ (function(module, exports) {

	;(function ($) {
	
	    // open-accordion
	    $('#lesson-stat-chk1').on('change', function() {
	        var t = $(this),
	            a_box = $('.accordion-container'),
	            span = a_box.prev();
	
	        if ( t.prop('checked') ) {
	            a_box.addClass('accordion-open').height(
	                a_box.children('.accordion-content').outerHeight(true)
	            );
	            span.addClass('accordion-arr-flip');
	        } else {
	            a_box.height(0).removeClass('accordion-open');
	            span.removeClass('accordion-arr-flip');
	        }
	    });
	
	    // remove complete lessons
	    $('#lesson-stat-chk2').on('change', function() {
	        var t = $(this),
	            les = $('.complete').closest('.lesson-block'),
	            a_box = $('.accordion-open');
	
	        if ( t.prop('checked') ) {
	            les.css('display', 'none');
	            a_box.height(
	                a_box.children('.accordion-content').outerHeight(true)
	            );
	        } else {
	            les.css('display', 'block');
	            a_box.height(
	                a_box.children('.accordion-content').outerHeight(true)
	            );
	        }
	
	    });
	
	    // open/close statistics
	    
	    $('.icon_lesson-stat-open').on('click', function() {
	
	        var el = $('.icon_lesson-stat-open'),
	            statistics = el.parent().siblings('.lesson-statistics__box'),
	            close = statistics.find('.icon_close-acc');
	
	            el.removeClass('lesson-stat-open_show').addClass('lesson-stat-open_hide');
	            statistics.slideDown();
	            close.removeClass('icon_close-acc_hide').addClass('icon_close-acc_show');
	         });      
	
	    
	    $('.icon_close-acc').on('click', function() {
	
	        var el = $('.icon_close-acc'),
	            statistics = el.parent('.lesson-statistics__box'),
	            open_icon = statistics.next().find('.icon_lesson-stat-open');
	
	            el.removeClass('icon_close-acc_show').addClass('icon_close-acc_hide');
	            statistics.slideUp();
	            open_icon.removeClass('lesson-stat-open_hide').addClass('lesson-stat-open_show');
	         });
	
	    
	    // temp
	
	    $('.lesson-teachers__button').on('click', function() {
	        $('.lesson-teachers__line').fadeIn(500);
	    });
	
	
	    $('.individual-test-answer_text').on('keyup', function() {
	        var id = $(this).attr('data-id');
	        if ($('#answer-text-input-'+id).val() || $('#answer-file-input-'+id).val())  {
	            $('#answer-submit-'+id).prop('disabled', false);
	        } else {
	            $('#answer-submit-'+id).prop('disabled', true);
	        }
	    });
	
	    $('.individual-test-answer_file').on('change', function() {
	        var id = $(this).attr('data-id');
	        console.log();
	        if ($('#answer-text-input-'+id).val() || $('#answer-file-input-'+id).val())  {
	            $('#answer-submit-'+id).prop('disabled', false);
	        } else {
	            $('#answer-submit-'+id).prop('disabled', true);
	        }
	    });
	
	})(jQuery);
	


/***/ }),
/* 58 */
/***/ (function(module, exports) {

	$('.lesson-nav-item').on('click', function () {
	   var parent = $(this).parent('.lesson-menu');
	
	   $(this).addClass('lesson-nav-item_active');
	
	   parent.siblings().find('.lesson-nav-item').removeClass('lesson-nav-item_active');
	
	});
	


/***/ }),
/* 59 */
/***/ (function(module, exports) {

	$(document).on('click', '.lk-subject-open-btn', function (e) {
	    const button = $(this);
	    const subjectBlock = button.closest('.js-journal-subject');
	    const scroll = subjectBlock.find('.custom-scroll');
	    const statBox = subjectBlock.find('.lk-subjects__stat-table-box');
	
	    if (!button.hasClass('open') && statBox.children().length === 0) {
	        $.post(
	            Routing.generate('private_office_pupil_journal_subject', {subject: subjectBlock.data('subject-id')})+'?lesson='+button.data('lesson')+'&class='+button.data('schoolclass')+'&status='+button.data('status'),
	            function (data) {
	                statBox.html(data);
	                button.toggleClass('open');
	                statBox.slideToggle();
	                scroll.mCustomScrollbar('update');
	            }
	        );
	    } else {
	        button.toggleClass('open');
	        statBox.slideToggle();
	        scroll.mCustomScrollbar('update');
	    }
	});
	
	$('.js-timetable-subject').on('click', '.lk-subject-open-btn', function (e) {
	    const button = $(this);
	    const subjectBlock = button.closest('.js-timetable-subject');
	    const scroll = subjectBlock.find('.custom-scroll');
	    const statBox = subjectBlock.find('.lk-subjects__stat-table-box');
	
	    if (!button.hasClass('open') && statBox.children().length === 0) {
	        $.post(
	            Routing.generate('private_office_pupil_timetable_pupil_subject_stats', {userCourse: subjectBlock.data('user-course'), subject: subjectBlock.data('subject-id')}),
	            function (data) {
	                statBox.html(data);
	                button.toggleClass('open');
	                statBox.slideToggle();
	                scroll.mCustomScrollbar('update');
	            }
	        );
	    } else {
	        button.toggleClass('open');
	        statBox.slideToggle();
	        scroll.mCustomScrollbar('update');
	    }
	})

/***/ }),
/* 60 */
/***/ (function(module, exports) {

	$(function (){
	
	    $('.course-themes-btn-1').on('click', function() {
	        var box = $('.lk-themes-list-box'),
	            chks = box.find('input[type="checkbox"]'),
	            btns = box.find('.lk-themes-list-btn');
	
	        chks.prop('checked', true);
	        btns.addClass('checked');
	        $('.lk-themes-chk').removeClass('checked');
	        $('.lk-subject-themes').slideUp();
	    });
	    $('.course-themes-btn-2').on('click', function() {
	        $('.lk-subject-themes').slideDown();
	        $('.lk-themes-list-box').mCustomScrollbar('update');
	    });
	
	
	    $('.lk-themes-list-btn').on('click', function() {
	        var t = $(this),
	            chk = t.next().find('input[type="checkbox"]');
	
	        t.toggleClass('checked');
	
	        if ( t.hasClass('checked') ) {
	            chk.prop('checked', true);
	        } else {
	            chk.prop('checked', false);
	        }
	
	        $('.lk-themes-chk').removeClass('checked');
	    });
	
	    $('.lk-chk-label').on('click', function() {
	        var t = $(this),
	            btn = t.closest('.lk-themes__sub-list').find('.lk-themes-list-btn');
	
	        btn.removeClass('checked');
	        $('.lk-themes-chk').removeClass('checked');
	    });
	
	    $('.lk-themes-chk').on('click', function() {
	        var t = $(this),
	            chk = t.parent().next().find('input[type="checkbox"]'),
	            sbtn = t.parent().next().find('.lk-themes-list-btn');
	
	        t.toggleClass('checked');
	
	        if ( t.hasClass('checked') ) {
	            chk.prop('checked', false);
	            sbtn.removeClass('checked');
	        } else {
	            chk.prop('checked', true);
	            sbtn.addClass('checked');
	        }
	    });
	
	});

/***/ }),
/* 61 */
/***/ (function(module, exports) {

	$(document).on('change', '#new_individual_test_schoolClass', function (evt, params) {
	
	    if ($(this).hasClass('sys_loading')) {
	        return false;
	    }
	    $(this).addClass('sys_loading');
	    $.get('/office/user/newhomework/load_subjects/'+params.selected, function (data) {
	        $('#new_individual_test_subject').prop('disabled', false);
	        $('#new_individual_test_subject').html(data);
	        $("#new_individual_test_subject").trigger("chosen:updated");
	        $('#new_individual_test_schoolClass').removeClass('sys_loading');
	    }, 'html');
	
	    return false;
	});
	
	$(document).on('change', '#new_individual_test_subject', function (evt, params) {
	
	    if ($(this).hasClass('sys_loading')) {
	        return false;
	    }
	    $(this).addClass('sys_loading');
	    $.get('/office/user/newhomework/load_lessons/'+$('#new_individual_test_schoolClass').val()+'/'+params.selected, function (data) {
	        $('#new_individual_test_lesson').prop('disabled', false);
	        $('#new_individual_test_lesson').html(data);
	        $("#new_individual_test_lesson").trigger("chosen:updated");
	        $('#new_individual_test_subject').removeClass('sys_loading');
	    }, 'html');
	
	    return false;
	});
	
	$(document).on('click', '#new_individual_test_submit', function () {
	
	    var error = '';
	    if (!$('#new_individual_test_schoolClass').val()) error += "Поле 'Класс' обязательно для заполнения<br>";
	    if (!$('#new_individual_test_subject').val()) error += "Поле 'Предмет' обязательно для заполнения<br>";
	    if (!$('#new_individual_test_lesson').val()) error += "Поле 'Урок' обязательно для заполнения<br>";
	
	    if ($(".user-type-choice input[type=radio]:checked").val()==1 && !$('#new_individual_test_users').val()) error += "Выберите хотя бы одного ученика<br>";
	    if ($(".user-type-choice input[type=radio]:checked").val()==2 && !$('#new_individual_test_groups').val()) error += "Выберите хотя бы одну группу<br>";
	
	    if ($("#new_individual_test_answerText:checked").length==0 && $("#new_individual_test_answerFile:checked").length==0) error += "Выберите тип ожидаемого результата<br>";
	
	
	    if (error) {
	        Swal.fire({
	            title: "Не заполнены обязательные поля!",
	            html: error,
	            type: "error",
	            closeOnConfirm: true
	        });
	        return false;
	    }
	
	});
	
	$(document).on('focus', '#new_individual_test_users', function () {
	    $("#new_individual_test_userType_0").prop("checked", true);
	});
	
	$(document).on('focus', '#new_individual_test_groups', function () {
	    $("#new_individual_test_userType_1").prop("checked", true);
	});

/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

	const Swal = __webpack_require__(40);
	const ajaxButtonPost = __webpack_require__(4);
	const addChildPopup = $('.js-add-child-popup');
	const addGroupForm = $('.js-add-group-form');
	const studentGroupTables = $('.lk-student-group');
	
	function handleAddingChild () {
	    const addChildRoute = Routing.generate('private_office_parent_link_child');
	    const handleResponse = (response) => {
	        return response.json()
	            .then(json => {
	                if (!response.ok) {
	                    return  Promise.reject(json);
	                }
	                return json;
	            });
	    };
	    Swal.fire({
	        input: 'radio',
	        inputOptions: {'existing':'Привязать', 'new':'Зарегистрировать'},
	        inputValidator: (value) => {
	            if (!value) {
	                return 'Выберите один из вариантов'
	            }
	        },
	        showCloseButton: true,
	        showCancelButton: true,
	        cancelButtonText: 'Отмена',
	    }).then(({value:choice}) => {
	        if (choice === 'new') {
	            $('[data-custom-modal]').customModal('show', '#registration-child-modal')
	        } else if (choice === 'existing') {
	            Swal.fire({
	                title: 'Привязка учётной записи ребёнка',
	                showCloseButton: true,
	                showCancelButton: true,
	                html: 'Введите логин или почту ребёнка',
	                input:'text',
	                inputAttributes: {
	                    autocapitalize: 'off',
	                    id: 'new-child-username'
	                },
	                confirmButtonText: 'Привязать',
	                cancelButtonText: 'Отмена',
	                showLoaderOnConfirm: true,
	                preConfirm: (username) => {
	                    return window.fetch(addChildRoute, {
	                            method: 'POST',
	                            body: JSON.stringify({username:username}),
	                            headers:{
	                                'Content-Type': 'application/json'
	                            }
	                        })
	                        .then(handleResponse)
	                        .catch(error => {
	                            Swal.showValidationMessage(
	                                `Произошла ошибка: ${error.error}`
	                            );
	                        });
	                },
	                allowOutsideClick: () => !Swal.isLoading()
	            }).then(({value:result}) => {
	                if (result !== undefined) {
	                    Swal.fire({
	                        showCloseButton: true,
	                        html: `Пользователь "${result.username}" должен подтвердить у себя в личном кабинете в разделе "Уведомления", что он согласен привязать учётную запись.`,
	                    });
	                }
	            });
	        }
	    });
	}
	addChildPopup.on('click', handleAddingChild);
	$('#unlink-pupils').on('click', function () {
	    var listIds = [];
	    const btn = $(this);
	    $('input[type=checkbox].lk-chk:checked').each(function () {
	        listIds.push(parseInt($(this).attr('data-id')));
	    });
	
	    if (listIds.length) {
	        ajaxButtonPost(
	            Routing.generate('private_office_teacher_unlink_pupils'),
	            {
	                ids: JSON.stringify(listIds)
	            },
	            btn,
	            (data) => {
	                if (data.success) {
	                    Swal.fire({
	                        title: 'Ученики успешно отвязаны',
	                        text: 'Успешно отвязано ' + data.countUnlinked + ' учеников',
	                        type: 'success',
	                        onClose: function () {
	                            window.location.reload();
	                        }
	                    });
	                } else {
	                    Swal.fire({
	                        title: 'Не удалось отвязать учеников',
	                        type: 'error',
	                        onClose: function () {
	                            window.location.reload();
	                        }
	                    });
	                }
	            }
	        );
	    } else {
	        Swal.fire({
	            title: 'Ни один ученик не выбран!',
	            text: 'Выберите хотя бы одного ученика',
	            type: 'warning'
	        });
	    }
	});
	$('#unlink-children').on('click', function () {
	    var listIds = [];
	    const btn = $(this);
	    $('input[type=checkbox].lk-chk:checked').each(function () {
	        listIds.push(parseInt($(this).attr('data-id')));
	    });
	
	    if (listIds.length) {
	        ajaxButtonPost(
	            Routing.generate('private_office_parent_unlink_pupils'),
	            {
	                ids: JSON.stringify(listIds)
	            },
	            btn,
	            (data) => {
	                if (data.success) {
	                    Swal.fire({
	                        title: 'Учетные записи успешно отвязаны',
	                        text: 'Успешно отвязано ' + data.countUnlinked + ' учетных записей',
	                        type: 'success',
	                        onClose: function () {
	                            window.location.reload();
	                        }
	                    });
	                } else {
	                    Swal.fire({
	                        title: 'Не удалось отвязать учетные записи',
	                        type: 'error',
	                        onClose: function () {
	                            window.location.reload();
	                        }
	                    });
	                }
	            }
	        );
	    } else {
	        Swal.fire({
	            title: 'Ни одна учетная запись не выбрана!',
	            text: 'Выберите хотя бы одну учетную запись',
	            type: 'warning'
	        });
	    }
	});
	$('#delete-profile').click(function () {
	    Swal.fire({
	        title: 'Удаление профиля',
	        type: 'warning',
	        html: '<p>Согласно соглашению об обработке персональных данных в течение 10 дней все Ваши данные будут удалены из базы портала без возможности их восстановления.</p>' +
	            '<p>Повторная регистрация на данную почту будет возможна по истечении указанного срока.</p>',
	        confirmButtonText: 'Удалить',
	        cancelButtonText: 'Отмена',
	        showCloseButton: true,
	        showCancelButton: true,
	    }).then((result) => {
	        if (result.value) {
	            fetch(Routing.generate('private_office_user_delete_profile'), {
	                method: 'POST'
	            }).then(response => response.json())
	                .then((json) => {
	                if (json.result === 'success') {
	                    window.location.href = '/logout'
	                } else {
	                    Swal.fire({
	                        title: 'Ошибка',
	                        text: 'Не удалось удалить учетную запись',
	                        type: 'error'
	                    });
	                }
	            });
	        }
	    });
	});
	
	$('#delete-profile-parent-invalid').click(function () {
	    Swal.fire({
	        title: 'Удаление профиля',
	        type: 'warning',
	        html: '<p>Удаление профиля невозможно, так как будут нарушены связи.</p>' +
	            '<p>В разделе «Дети» все или часть пользователей зарегистрированы через Ваш личный кабинет. ' +
	            'В случае удаления Ваших данных будет потеряна возможность восстановления ' +
	            'пароля для зарегистрированных через Вас пользователей.</p>' +
	            '<p>Для удаления своего профиля необходимо отменить привязку таких пользователей в разделе «Дети».</p>' +
	            '<p>Предварительно рекомендуем в личном кабинете зарегистрированных через Вас пользователей заполнить ' +
	            'поле "Адрес электронной почты" для возможности восстановления пароля.</p>',
	        confirmButtonText: 'ОК',
	        showCloseButton: true,
	    });
	});
	
	$('#register-child-btn').click(function (e) {
	    e.preventDefault();
	    const $form = $('.register-child-form');
	    const btn = $(this);
	    ajaxButtonPost(
	        Routing.generate('private_office_parent_register_child'),
	        $form.serialize(),
	        btn,
	        (result) => {
	            if (result.result === 'success') {
	                $('[data-custom-modal]').customModal('hide', '#registration-child-modal')
	                Swal.fire({
	                    title: 'Регистрация учетной записи',
	                    text: `Пользователь ${result.name} успешно создан.`
	                }).then(() => {
	                    window.location.reload();
	                })
	            }
	        }
	    );
	});
	$('#pupil_connection_button').on('click', function () {
	    const btn = $(this);
	    ajaxButtonPost(
	        Routing.generate('private_office_teacher_get_teacher_code_link'),
	        {},
	        btn,
	        (data) => {
	            const currentUrl = window.location.origin;
	            Swal.fire({
	                title: 'Привязка учетных записей учеников',
	                html: `${data.text}<br><a href="${currentUrl}${data.link}">${currentUrl}${data.link}</a>`,
	            });
	        }
	    );
	});
	$('#unlink-teachers').on('click', function () {
	    const btn = $(this);
	    var listIds = [];
	    $('input[type=checkbox].lk-chk:checked').each(function () {
	        listIds.push(parseInt($(this).attr('data-id')));
	    });
	
	    if (listIds.length) {
	        ajaxButtonPost(
	            Routing.generate('private_office_pupil_unlink_teachers'),
	            {
	                ids: JSON.stringify(listIds)
	            },
	            btn,
	            (data) => {
	                if (data.success) {
	                    Swal.fire({
	                        title: 'Учётные записи успешно отвязаны',
	                        text: 'Успешно отвязано ' + data.countUnlinked + ' учётных записей',
	                        type: 'success',
	                        onClose: function () {
	                            window.location.reload();
	                        }
	                    });
	                } else {
	                    Swal.fire({
	                        title: 'Не удалось отвязать учётную запись',
	                        type: 'error',
	                        onClose: function () {
	                            window.location.reload();
	                        }
	                    });
	                }
	            }
	        );
	    } else {
	        Swal.fire({
	            title: 'Ни один пользователь не выбран!',
	            text: 'Выберите хотя бы одного пользователя',
	            type: 'warning'
	        });
	    }
	});
	$('#confirm-pupils').on('click', function () {
	    const ids = [];
	    $('input[type=checkbox].lk-chk:checked').each(function () {
	        ids.push(parseInt($(this).attr('data-id')));
	    });
	    if (ids.length) {
	        const btn = $(this);
	        ajaxButtonPost(
	            Routing.generate('private_office_teacher_confirm_pupils'),
	            {
	                ids: JSON.stringify(ids)
	            },
	            btn,
	            (data) => {
	                if (data.success) {
	                    Swal.fire({
	                        title: 'Учётные записи успешно привязаны',
	                        text: 'Успешно привязано ' + data.countConfirmed + ' учётных записей',
	                        type: 'success',
	                        onClose: function () {
	                            window.location.reload();
	                        }
	                    });
	                } else {
	                    Swal.fire({
	                        title: 'Не удалось привязать учётную запись',
	                        type: 'error',
	                        onClose: function () {
	                            window.location.reload();
	                        }
	                    });
	                }
	            }
	        );
	    } else {
	        Swal.fire({
	            title: 'Ни один пользователь не выбран!',
	            text: 'Выберите хотя бы одного пользователя',
	            type: 'warning'
	        });
	    }
	});
	
	$(document).on('click', '#students-submit-filter', function () {
	
	    if ($(this).hasClass('ajax-executing')) {
	        return false;
	    }
	    $(this).addClass('ajax-executing');
	    $.get(Routing.generate('private_office_teacher_students_ajax', {
	        'status': $('#students_choose_status').val(),
	        'group': $('#students_choose_group').val(),
	        'fio': $('#students_fio').val()
	    }), function (data) {
	
	        window.history.pushState({}, document.title, '/office/user/students/?status='+$('#students_choose_status').val()+'&group='+$('#students_choose_group').val()+'&fio='+$('#students_fio').val());
	        $('#students-table').html(data);
	        $('#students-submit-filter').removeClass('ajax-executing');
	    }, 'html');
	
	    return false;
	});
	
	/*
	$(document).on('change', '#journal-subject', function () {
	
	    var id = $(this).val();
	    if ($(this).hasClass('ajax-executing')) {
	        return false;
	    }
	    $(this).addClass('ajax-executing');
	
	    $.get('/office/user/journal/filter/subject/'+id, function (data) {
	        $('#journal-lesson').prop('disabled', false);
	        $('#journal-lesson').html(data);
	        $("#journal-lesson").trigger("chosen:updated");
	        $('#journal-subject').removeClass('ajax-executing');
	    }, 'html');
	
	});
	*/
	
	addGroupForm.on('submit', function (e) {
	    e.preventDefault();
	    if ($(this).find('.js-add-group-form').length > 0) {
	        return false;
	    }
	    const btn = $(this).find('.js-add-to-group-btn');
	    const form = $(this);
	    const selectedPupils = $('.js-students-table .lk-chk:checked').map(function () {
	        return $(this).data('pupil-id');
	    }).get();
	    try {
	        if (selectedPupils.length === 0) {
	            return Swal.fire({
	                title: 'Добавление учеников в группу',
	                text: `Выделите хотя бы одного ученика в таблице.`
	            }).then(() => {
	                $('[data-custom-modal]').customModal('hide', '#add-student-to-group-modal');
	                return false;
	            });
	        }
	        form.find('input[name="pupil_group[pupils]"]').val(JSON.stringify(Object.assign({}, selectedPupils)));
	        ajaxButtonPost(
	            Routing.generate('private_office_teacher_add_to_group'),
	            form.serializeArray(),
	            btn,
	            (result) => {
	                if (result.result === 'success') {
	                    $('[data-custom-modal]').customModal('hide', '#add-student-to-group-modal');
	                    Swal.fire({
	                        title: 'Добавление учеников в группу',
	                        text: `Учетные записи учеников успешно добавлены в группу ${result.group}.`
	                    }).then(() => {
	                        window.location.reload();
	                    })
	                } else if (result.result === 'error') {
	                    Swal.fire({
	                        title: 'Добавление учеников',
	                        text: `Не удалось добавить учетные записи учеников в группу ${result.group}.`
	                    }).then(() => {
	                        window.location.reload();
	                    })
	                }
	            }
	        );
	    } catch (e) {
	        return false;
	    }
	});
	studentGroupTables.on('click', '.js-remove-from-group', function (e) {
	    const btn = $(e.currentTarget);
	    const group = $(e.delegateTarget);
	    const groupId = group.data('group-id');
	    const selectedPupils = group.find('.lk-chk:checked').map(function () {
	        return $(this).data('pupil-id');
	    }).get();
	    ajaxButtonPost(
	        Routing.generate('private_office_teacher_remove_from_group'),
	        {
	            groupId: groupId,
	            pupils: JSON.stringify(Object.assign({}, selectedPupils))
	        },
	        btn,
	        (result) => {
	            if (result.result === 'success') {
	                Swal.fire({
	                    title: 'Удаление учеников из группы',
	                    text: `Учетные записи учеников успешно отвязаны от группы ${result.group}.`
	                }).then(() => {
	                    window.location.reload();
	                })
	            } else if (result.result === 'error') {
	                Swal.fire({
	                    title: 'Удаление учеников из группы',
	                    text: `Не удалось отзязать учетные записи учеников от группы ${result.group}.`
	                }).then(() => {
	                    window.location.reload();
	                })
	            }
	        }
	    );
	});
	
	$('#check-homework-button').on('click', function () {
	    const btn = $(this);
	    const homeworkId = btn.data('homework');
	    Swal.fire({
	        title: 'Поставить оценку',
	        html: '' +
	            '<div style="text-align: left"><label for="teacher_mark">Оценка:</label>' +
	            '<select id="teacher_mark" class="swal2-select" style="margin-top:0;">' +
	            '<option>5</option>' +
	            '<option>4</option>' +
	            '<option>3</option>' +
	            '<option>2</option>' +
	            '<option>1</option>' +
	            '</select>' +
	            '<label for="teacher_comment">Комментарий:</label>' +
	            '<textarea type="text" id="teacher_comment" class="swal2-textarea" style="margin-top:0;" ></textarea></div>',
	        showCancelButton: true,
	        confirmButtonText: 'Поставить оценку',
	        cancelButtonText: 'Закрыть',
	        reverseButtons: true,
	        onOpen: function() {
	            $('#hidden_individual_id').val()
	        }
	    }).then((result) => {
	        if (result.value) {
	            ajaxButtonPost(
	                Routing.generate('private_office_teacher_expose_mark_extended_question', {id: homeworkId}),
	                {
	                    mark: $('#teacher_mark').val(),
	                    comment: $('#teacher_comment').val()
	                },
	                btn,
	                (data) => {
	                    location.reload();
	                }
	            );
	        }
	    });
	});
	
	$('#edit-homework-mark').on('click', function () {
	    const btn = $(this);
	    const homeworkId = btn.data('homework');
	    const lessonSessionId = btn.data('session');
	    const mark = btn.data('mark');
	    const options = [1,2,3,4,5].reduce((acc, cur) => {
	        const selected = mark === cur;
	        return acc + '<option' + (selected ? ' selected="true"' : '') + '>' + cur + '</option>';
	    }, '');
	    console.log(options);
	    Swal.fire({
	        title: 'Поставить оценку',
	        html: '' +
	            '<div style="text-align: left"><label for="teacher_mark">Оценка:</label>' +
	            '<select id="teacher_mark" class="swal2-select" style="margin-top:0;">' + options +
	            '</select>' +
	            '<label for="teacher_comment">Комментарий:</label>' +
	            '<textarea required="required" type="text" id="teacher_comment" class="swal2-textarea" style="margin-top:0;" ></textarea></div>',
	        showCancelButton: true,
	        confirmButtonText: 'Поставить оценку',
	        cancelButtonText: 'Закрыть',
	        reverseButtons: true,
	        preConfirm: () => {
	            if (!$('#teacher_comment').val()) {
	                Swal.showValidationMessage('Заполните поле «Комментарий»')
	            }
	        },
	        onOpen: function() {
	            $('#hidden_individual_id').val()
	        }
	    }).then((result) => {
	        if (result.value) {
	            ajaxButtonPost(
	                Routing.generate('private_office_teacher_edit_homework_mark', {homework: homeworkId, session: lessonSessionId}),
	                {
	                    mark: $('#teacher_mark').val(),
	                    comment: $('#teacher_comment').val()
	                },
	                btn,
	                (data) => {
	                    location.reload();
	                }
	            );
	        }
	    });
	});
	
	$('.delete-homeworks').on('click', function (e) {
	    e.preventDefault();
	    const btn = $(this);
	    if (btn.hasClass('ajax-executing')) return;
	    var i = 0;
	    var sList = [];
	    $('.task-list input[type=checkbox]').each(function () {
	        if (this.checked) {
	            sList[i] = $(this).val();
	            i++;
	        }
	    });
	    if (sList.length>0) {
	        Swal.fire({
	            title: 'Удаление заданий',
	            html: 'Вы действительно хотите удалить выбранные задания?',
	            showCloseButton: true,
	            showCancelButton: true,
	            focusConfirm: false,
	            confirmButtonText: 'Удалить',
	            cancelButtonText: 'Отмена',
	        }).then(({ value: result }) => {
	            if (result === true) {
	                ajaxButtonPost(
	                    '/office/user/homeworks/delete',
	                    {
	                        works: JSON.stringify(sList)
	                    },
	                    btn,
	                    (data) => {
	                        if (data.success==true) location.reload();
	                    }
	                );
	            }
	        });
	    }
	});
	
	
	$('.delete-group').on('click', function() {
	    const id = $(this).data('id');
	    const btn = $(this);
	    Swal.fire({
	        title: 'Удаление группы',
	        html: 'Вы действительно хотите удалить группу?',
	        showCloseButton: true,
	        showCancelButton: true,
	        focusConfirm: false,
	        confirmButtonText: 'Удалить',
	        cancelButtonText: 'Отмена',
	    }).then(({ value: result }) => {
	        if (result === true) {
	            ajaxButtonPost(
	                Routing.generate('private_office_teacher_students_delete_group', { 'group': id }),
	                {},
	                btn,
	                (data) => {
	                    if (data.success === true) location.reload();
	                }
	            );
	        }
	    });
	});
	
	$('.edit-group').on('click', function() {
	    const id = $(this).data('id');
	    const btn = $(this);
	    const currentName = $(this).data('name');
	    Swal.fire({
	        title: 'Название группы',
	        input: 'text',
	        inputValue: currentName,
	        inputAttributes: {
	            autocapitalize: 'off'
	        },
	        showCloseButton: true,
	        showCancelButton: true,
	        showLoaderOnConfirm: true,
	        focusConfirm: false,
	        cancelButtonText: 'Отмена',
	        preConfirm: (name) => {
	            if (name.length < 1) {
	                Swal.showValidationMessage(
	                    `Введите название`
	                )
	            }
	        },
	        allowOutsideClick: () => !Swal.isLoading()
	    }).then((result) => {
	        if (result.value !== currentName && result.value.length > 0) {
	            ajaxButtonPost(
	                Routing.generate('private_office_teacher_students_rename_group', { 'group': id }),
	                { name: result.value },
	                btn,
	                (data) => {
	                    if (data.success === true) {
	                        location.reload();
	                    } else {
	                        Swal.fire({
	                            icon: 'error',
	                            text: data.message
	                        })
	                    }
	                }
	            );
	        }
	    });
	});
	
	$('.register-in-resh').on('click', function () {
	    $('.register-hidden').show();
	    $('.register-choose-block').hide();
	
	    return false;
	});

/***/ }),
/* 63 */
/***/ (function(module, exports) {

	$('.timetbl__additional-link').on('click', function () {
	    var t = $(this),
	        tText = t.find('span'),
	        parent = t.parent(),
	        contMain = parent.find('.timetbl-content__subjects_main'),
	        contAdd = parent.find('.timetbl-content__subjects_additional');
	
	    contMain.slideToggle(300);
	    contAdd.slideToggle(300).toggleClass('_vis');
	
	    if ( contAdd.hasClass('_vis') ) {
	        tText.text('Основные занятия');
	    } else {
	        tText.text('Дополнительные занятия');
	    }
	});

/***/ }),
/* 64 */
/***/ (function(module, exports) {

	$(document).ready(function(){
	
	   $(".tbForm_CallMe.jump").css({"position":"absolute", "right":"50px", "transition": "top 0.5s ease 0s"});
	   tbForm_Return_Button ();
	
	
	   $(window).scroll(function(){
	      tbForm_Return_Button();
	   });
	   $(window).resize(function(){
	      tbForm_Return_Button();
	   });
	
	   function  tbForm_Return_Button (){
	      var r=getPageSize();docW=r[0];docH=r[1];winW=r[2];winH=r[3];
	      var y=$(window).scrollTop();	 y=y+winH-130;
	      $(".tbForm_CallMe.jump").css({"position":"absolute", "top": y+"px", "right": "50px"});
	   }
	
	//определение высоты и ширины документа, а также высоты и ширины окна браузера
	   function  getPageSize(){
	      var xScroll, yScroll;
	
	      if (window.innerHeight && window.scrollMaxY) {
	         xScroll = document.body.scrollWidth;
	         yScroll = window.innerHeight + window.scrollMaxY;
	      } else if (document.body.scrollHeight > document.body.offsetHeight){ // all but Explorer Mac
	         xScroll = document.body.scrollWidth;
	         yScroll = document.body.scrollHeight;
	      } else if (document.documentElement && document.documentElement.scrollHeight > document.documentElement.offsetHeight){ // Explorer 6 strict mode
	         xScroll = document.documentElement.scrollWidth;
	         yScroll = document.documentElement.scrollHeight;
	      } else { // Explorer Mac...would also work in Mozilla and Safari
	         xScroll = document.body.offsetWidth;
	         yScroll = document.body.offsetHeight;
	      }
	
	      var windowWidth, windowHeight;
	      if (self.innerHeight) { // all except Explorer
	         windowWidth = self.innerWidth;
	         windowHeight = self.innerHeight;
	      } else if (document.documentElement && document.documentElement.clientHeight) { // Explorer 6 Strict Mode
	         windowWidth = document.documentElement.clientWidth;
	         windowHeight = document.documentElement.clientHeight;
	      } else if (document.body) { // other Explorers
	         windowWidth = document.body.clientWidth;
	         windowHeight = document.body.clientHeight;
	      }
	
	      // for small pages with total height less then height of the viewport
	      if(yScroll < windowHeight){
	         pageHeight = windowHeight;
	      } else {
	         pageHeight = yScroll;
	      }
	
	      // for small pages with total width less then width of the viewport
	      if(xScroll < windowWidth){
	         pageWidth = windowWidth;
	      } else {
	         pageWidth = xScroll;
	      }
	      
	      return [pageWidth,pageHeight,windowWidth,windowHeight];
	   }
	
	
	});

/***/ }),
/* 65 */
/***/ (function(module, exports) {

	$('.addbutton').on('click', function () {
	    var el = $(this);
	    var el_row = el.closest('.lk__form-row');
	    var content = el_row.prev().clone();
	    el_row.before(content);
	    el_row.prev().addClass('added-row-displayed').find('.lk__form-label').html('').end().find('.lk__input-text').val(''); 
	});
	
	$('.lk__form-block').on('click', '.icon_delete-cross', function () {
	    var el = $(this);
	    
	    el.closest('.lk__form-row').removeClass('added-row-displayed').addClass('closeblock');
	
	   setTimeout(function () {
	        el.closest('.lk__form-row').remove();
	    },300);
	});
	


/***/ }),
/* 66 */
/***/ (function(module, exports) {

	/*$('.search_close').on('click', function () {
	    var el = $(this),
	        search = el.parent('.header__navigation'),
	        modal = $('.modal-cover');
	        
	        search.removeClass('_search-clicked');
	        modal.removeClass('_modal-visible');
	});*/
	


/***/ }),
/* 67 */
/***/ (function(module, exports) {

	$('.modal-js').on('click', function (e) {
	   e.preventDefault();
	
	   $('.overlay').css('display', 'block');
	});


/***/ }),
/* 68 */
/***/ (function(module, exports) {

	var msgSelect = $('._msgs-select');
	var msgCheckbox = $('.message-check__wrapper input[type=checkbox]');
	var delSelected = $('._delete-selected');
	
	msgSelect.on('change', function () {
	    if ($(this).is(':checked')) {
	        msgCheckbox.each(function () {
	            $(this).prop("checked", true);
	        });
	        toggleRemove(true);
	    } else {
	        msgCheckbox.each(function () {
	            $(this).prop("checked", false);
	        });
	        toggleRemove(false);
	    }
	});
	
	msgCheckbox.on('change', function () {
	    if (msgCheckbox.filter(':checked').length > 0) {
	        toggleRemove(true);
	    } else {
	        toggleRemove(false);
	    }
	    if (msgCheckbox.filter(':checked').length == msgCheckbox.length) {
	        msgSelect.prop("checked", true);
	    } else {
	        msgSelect.prop("checked", false);
	    }
	});
	
	delSelected.on('click', function () {
	    msgCheckbox.filter(':checked').each(function () {
	        var selfRoot = $(this).closest('.lk-message__grid');
	        selfRoot.addClass('_closing');
	        setTimeout(function () {
	            selfRoot.remove();
	            disableCheckAll();
	            checkChecked();
	        }, 300)
	    });
	});
	
	closeBlock($('.msg-delete'), $('.lk-message__grid'), 300);
	
	function toggleRemove(toggle) {
	    if (toggle) {
	        delSelected.addClass('_del-visible');
	    } else {
	        delSelected.removeClass('_del-visible');
	    }
	}
	
	function disableCheckAll() {
	    if ($('.lk-message__grid').length == 0) {
	        msgSelect.prop('checked', false).prop('disabled', true);
	        toggleRemove(false);
	    }
	}
	
	function checkChecked() {
	    if ($('.message-check__wrapper input[type=checkbox]').filter(':checked').length == 0) {
	        toggleRemove();
	    }
	}
	
	/*hide blocks on cross click*/
	
	function closeBlock(elSelector, rootSelector, delay) {
	    elSelector.on('click', function () {
	        var self = $(this);
	        var selfRoot = self.closest(rootSelector);
	        selfRoot.addClass('_closing');
	        setTimeout(function () {
	            selfRoot.remove();
	            disableCheckAll();
	            checkChecked();
	
	        }, delay);
	
	    })
	}
	


/***/ }),
/* 69 */
/***/ (function(module, exports) {

	$('.newsfeed-date-filter__btn').on('click', function (e) {
	    e.stopPropagation();
	    var t = $(this);
	    t.parent().toggleClass('open');
	});
	
	
	$('.newsfeed-type-choise button').on('click', function () {
	    var t = $(this),
	        btns = t.parent().find('button');
	
	    btns.removeClass('active');
	    t.addClass('active');
	});
	
	
	// Subscrib button
	
	$('.news-feed__tomail').on('click', function (e) {
	    e.stopPropagation();
	    $(this).find('.news-feed__tomail-box').toggleClass('open');
	});
	
	// stop propagation
	
	$('.newsfeed-date-filter__dropdown')
	
	    .add('.news-feed__tomail-box')
	
	    .on('click', function (e) {
	        e.stopPropagation();
	    });
	
	var currentActiveYear = 0;
	
	$('.js-news-year-right, .js-news-year-left').on('click', function () {
	    var dropdownWindow = $(this).closest('.newsfeed-date-filter__dropdown');
	    var yearBlocks = dropdownWindow.find('.newsfeed-date-filter__year-wrapper');
	    var yearsNumber = yearBlocks.length;
	
	    if ($(this).hasClass('js-news-year-right')) {
	        toggleYearUp();
	    } else {
	        toggleYearDown()
	    }
	
	    function toggleYearUp() {
	        if (currentActiveYear >= yearsNumber - 1) {
	            currentActiveYear = 0;
	        } else {
	            currentActiveYear++;
	        }
	        yearBlocks.hide();
	        yearBlocks.eq(currentActiveYear).fadeIn(200);
	    }
	
	    function toggleYearDown() {
	        if (currentActiveYear <= 0) {
	            currentActiveYear = yearsNumber - 1;
	        } else {
	            currentActiveYear--;
	        }
	        yearBlocks.hide();
	        yearBlocks.eq(currentActiveYear).fadeIn(200);
	    }
	});

/***/ }),
/* 70 */
/***/ (function(module, exports) {

	
	$('.note-feed__close-btn').on('click', function() {
	   var t = $(this),
	       block = t.closest('.note-feed-block');
	
	   block.addClass('closeblock').slideUp();
	});
	
	$('.mi-id__close-btn').on('click', function() {
	   var t = $(this),
	       block = t.closest('.my-id__parent-block');
	
	   block.addClass('closeblock').slideUp();
	});
	
	
	


/***/ }),
/* 71 */
/***/ (function(module, exports) {

	$('.page-up').on('click' , function() {
	    $('html, body').animate({scrollTop: 0}, 500);
	    return false;
	})
	
	
	
	


/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

	const Swal = __webpack_require__(40);
	const ajaxButtonPost = __webpack_require__(4);
	const reshMultiSelect = __webpack_require__(30);
	
	$('.quiz-item-more').on('click', itemMoreClick);
	
	function itemMoreClick(e) {
	    e.stopPropagation();
	    let quizId = $(this).attr('data-id');
	
	    if ($('[data-block-id='+quizId+']').css('display')=='none') {
	
	        $.get(Routing.generate('private_office_teacher_quiz_more', {
	            'quizId': quizId ? quizId : null,
	        }), function (data) {
	            $('[data-block-id=' + quizId + ']').slideDown(400);
	            $('[data-block-id=' + quizId + '] td').html(data);
	        });
	    } else {
	        $('[data-block-id=' + quizId + ']').slideUp(400);
	        $('[data-block-id=' + quizId + '] td').empty();
	
	    }
	
	}
	
	$('.quiz-control-start').on('click', controlStartClick);
	
	function controlStartClick(e) {
	    e.stopPropagation();
	    let $this = $(this)
	    let title = $(this).data('title')
	    let duration = $(this).data('duration')
	    let period = $(this).data('period')
	
	    Swal.fire({
	        //reverseButtons: true,
	        confirmButtonColor: '#32d7c0',
	        focusCancel: true,
	        showCancelButton: true,
	        html: 'Блок №1<br>' +
	            '<strong>'+title+'</strong><br>' +
	            'Доступных попыток: <strong>1</strong><br>' +
	            'Ограничение по времени: <strong>'+duration+'</strong><br><br><br>',
	        confirmButtonText: 'Назад',
	        cancelButtonText: 'Приступить к выполнению'
	    }).then((result) => {
	        if (result.value === true) {
	            location.href = $this.attr('href')
	        }
	    });
	
	    return false;
	}
	
	function controlWorkMoreClick(e) {
	    e.stopPropagation();
	    let $this = $(this)
	    let sess_id = $(this).data('session-id')
	
	    $.ajax({
	        url: Routing.generate('private_office_pupil_quiz_control_more_popup', {'quizSession': sess_id}),
	        type: 'GET',
	        success: function (data) {
	            Swal.fire({
	                title: 'Информация о работе',
	                html: data
	            })
	        }
	    });
	
	    return false;
	}
	
	
	$('.pupil-work-more-popup').on('click', controlWorkMoreClick);
	
	
	function quizFormChange () {
	    $(this).find('button[type=submit]').attr('disabled', false)
	}
	
	$('.add-quiz-form').on('change', quizFormChange)
	
	function classSelectChange() {
	    var $this = $(this)
	    var $row = $this.closest('.row-wrap')
	    var $nextSelect = $row.find('.js-subject')
	    var $genderSelectRow = $row.next();
	
	    if (+$this.val() === 1) {
	        $nextSelect.attr("disabled", true).trigger("chosen:updated")
	    } else {
	        $nextSelect.removeAttr('disabled').trigger("chosen:updated")
	    }
	
	    if (+$this.val() === 7 || +$this.val() === 8) {
	        $genderSelectRow.removeClass('hidden');
	    } else {
	        $genderSelectRow.addClass('hidden');
	    }
	}
	
	function addModuleBtnClick() {
	
	    const list = $($(this).attr('data-list-selector'));
	    let counter = list.data('widget-counter') || list.children().length;
	    let newWidget = list.attr('data-prototype');
	
	    newWidget = newWidget.replace(/__name__/g, counter);
	    counter++;
	
	    list.data('widget-counter', counter);
	    const newElem = $(newWidget);
	    newElem.appendTo(list);
	
	    $('.chosen-select').chosen({
	        disable_search_threshold: 10,
	        no_results_text: "Ничего не найдено"
	    });
	    $('.lk-select-scenes .opt').on( 'mouseenter', '.active-result-more-link', chosenResultsMouseEnterMore)
	
	    reshMultiSelect.load('select-sumo-select');
	    reshMultiSelect.run();
	}
	
	function addQuizFormClick() {
	    $(this).closest('li').remove()
	    const list = $($('.js-add-quiz-btn').attr('data-list-selector'));
	    let counter = list.data('widget-counter') || list.children().length;
	    counter--;
	    list.data('widget-counter', counter);
	    clearErrors()
	}
	
	function customModalSubjectChange() {
	    const $this = $(this)
	    const $row = $this.closest('.row-wrap')
	    const $subject = $row.find('.js-quiz-subject')
	    const $class = $row.find('.js-quiz-class')
	    const selectedSubject = $subject.chosen().val();
	    let $newWidgetElement = $('#quiz-modules-list');
	    let $newWidget = $('#quiz-modules-list').attr('data-prototype');
	    let $newWidgetClassSplit = $newWidget.split('js-quiz-class');
	    let $newWidgetClassSplitClear = $newWidgetClassSplit[1].substring($newWidgetClassSplit[1].indexOf('</select>'));
	    $class.val('').trigger('chosen:updated')
	    let $resultPrototype = '';
	
	    $.get(Routing.generate('private_office_pupil_quiz_classes_query', {
	        'subject_id': selectedSubject ? selectedSubject : null,
	    }), function (data) {
	
	        $class.html(data)
	        $class.trigger('chosen:updated')
	
	        $row.find('.js-quiz-lessons').html(data);
	        $resultPrototype = $newWidgetClassSplit[0] + ' js-quiz-class form-control">' + data + $newWidgetClassSplitClear;
	
	        let $newWidgetLessonSplit = $resultPrototype.split('js-quiz-lessons');
	        let $newWidgetLessonSplitClear = $newWidgetLessonSplit[1].substring($newWidgetLessonSplit[1].indexOf('</select>'));
	        $resultPrototype = $newWidgetLessonSplit[0] + ' js-quiz-lessons form-control"><optopn value="">Урок</optopn>' + $newWidgetLessonSplitClear;
	
	        $($newWidgetElement).attr('data-prototype', $resultPrototype);
	    });
	
	}
	
	function customModalShowingDropdown() {
	    const $this = $(this);
	    if ($this.children('option').length === 0) {
	        loadModuleLessons($this);
	    }
	}
	
	function customModalKeyupChange(e, currentId = '') {
	
	    let $this = $(this)
	    let id = $this.attr('id');
	    let $row = ''
	    let $exercise = ''
	    let lessonId = ''
	    let sceneSelect = ''
	
	    if (id===undefined && currentId) {
	        id = currentId
	        $row = $('#'+currentId).parent().closest('.row-wrap')
	        $exercise = $row.find('.js-quiz-exercise');
	        lessonId = $row.find('.js-quiz-lessons').chosen().val();
	        sceneSelect = $row.find('.js-quiz-scenes')
	    } else {
	        $row = $this.parent().closest('.row-wrap')
	        $exercise = $row.find('.js-quiz-exercise');
	        lessonId = $row.find('.js-quiz-lessons').chosen().val();
	        sceneSelect = $row.find('.js-quiz-scenes')
	    }
	
	    let clearid = id.replace('quiz_modules_', '');
	    clearid = clearid.replace('_scenes', '');
	
	    let exerciseType = '';
	    $exercise.each(function(index, value) {
	        if ($(value).is(':checked')) {
	            exerciseType = $(value).val();
	        }
	    });
	
	    $('.multiselect__dropdown__result__option').each(function(i,el) {
	        let train_id = $(el).find('input').val();
	        let train_id_url = $(el).find('input').val();
	        if ($(el).data('train')) train_id_url = $(el).data('train')
	
	        $(el).find('label a').remove()
	
	        $(el).find('label').append('<a class="active-result-more-link" data-scene-selector="'+sceneSelect.attr('id')+'" data-exercise-type="'+exerciseType+'" data-lesson-id="'+lessonId+'" data-id="'+train_id+'" href="/subject/lesson/'+$('.js-quiz-lessons').val()+'/train/'+train_id_url+'/" target="_blank"><i class="icon icon_glasses"></i></a>');
	    });
	
	    $('.multiselect__dropdown__result__option').on( 'mouseenter', '.active-result-more-link', chosenResultsMouseEnterMore);
	}
	
	function editKeyupChange(el) {
	    let id = $(el).attr('id');
	    let $row = $(el).closest('.row-wrap');
	    $exercise = $row.find('.js-quiz-exercise');
	    lessonId = $row.find('.js-quiz-lessons').chosen().val();
	    sceneSelect = $row.find('.js-quiz-scenes');
	
	    let clearid = id.replace('quiz_modules_', '');
	    clearid = clearid.replace('_scenes', '');
	
	    let exerciseType = '';
	    $exercise.each(function(index, value) {
	        if ($(value).is(':checked')) {
	            exerciseType = $(value).val();
	        }
	    });
	
	    $('.multiselect__dropdown__result__option').each(function(i,el) {
	        let train_id = $(el).find('input').val();
	        let train_id_url = $(el).find('input').val();
	        if ($(el).data('train')) train_id_url = $(el).data('train')
	
	        $(el).find('label a').remove()
	
	        $(el).find('label').append('<a class="active-result-more-link" data-scene-selector="'+sceneSelect.attr('id')+'" data-exercise-type="'+exerciseType+'" data-lesson-id="'+lessonId+'" data-id="'+train_id+'" href="/subject/lesson/'+$('.js-quiz-lessons').val()+'/train/'+train_id_url+'/" target="_blank"><i class="icon icon_glasses"></i></a>');
	    });
	
	    $('.multiselect__dropdown__result__option').on( 'mouseenter', '.active-result-more-link', chosenResultsMouseEnterMore);
	
	}
	
	function chosenResultsMouseEnterMore() {
	    let target = $(this);
	    let popup = $('#active-result-more-popup');
	
	    $.get(Routing.generate('private_office_teacher_quiz_single_scene', {
	        'scene_id': target.data('id'),
	        'exercise_type': target.data('exercise-type'),
	        'lesson_id': target.data('lesson-id'),
	        'scene_selector': target.data('scene-selector'),
	    }), function (data) {
	        popup.show();
	        popup.html(data);
	        $('#js-close-preview').on('click', quizPreviewClose);
	        $('.active-result').on( 'click', quizPreviewClose);
	        $('.js-choose-from-preview').on('click', jsChooseFromPreviewClick);
	    });
	}
	
	
	function quizPreviewClose(e) {
	    e.stopPropagation();
	    let popup = $('#active-result-more-popup');
	    popup.hide();
	    popup.empty();
	}
	
	function chosenResultsLiMouseEnter(e) {
	    let target = $(e.currentTarget);
	    if ( target.data('option-array-index') >= 0 ) {
	        target.addClass('highlighted').next('.active-result-more').addClass('highlighted')
	    } else {
	        target.addClass('highlighted').prev().addClass('highlighted')
	    }
	}
	
	function lkSelectScenesMouseleave() {
	    $('.lk-select-scenes .chosen-results').children('li').removeClass('highlighted')
	}
	
	function customModalLessonsChange(e) {
	    const upBlock = e.target.closest('.js-module');
	    const $this = $(this)
	    const $row = $this.closest('.row-wrap')
	    const $subject = $('.js-quiz-subject')
	    const $class = $('.js-quiz-class')
	    const $scene = $row.find('.js-quiz-scenes')
	    const $exercise = $row.find('.js-quiz-exercise')
	    const sceneSelect = $row.find('.js-quiz-scenes')
	    const lessonId = $row.find('.js-quiz-lessons').chosen().val();
	
	    let current_exercise = '';
	
	    $exercise.each(function(index, value) {
	        if ($(value).is(':checked')) {
	            current_exercise = $(value).val();
	        }
	    });
	
	    const selectedLesson = $this.chosen().val();
	    $.get(Routing.generate('private_office_pupil_quiz_scenes_query', {
	        'lesson_id': selectedLesson ? selectedLesson : null,
	        'exercise_type': current_exercise ? current_exercise : null,
	    }), function (data) {
	        $scene.empty().html(data);
	        reshMultiSelect.remove('select-sumo-select', upBlock.querySelector('.js-quiz-scenes'));
	        reshMultiSelect.load('select-sumo-select', upBlock.querySelector('.js-quiz-scenes'));
	        reshMultiSelect.run();
	        customModalKeyupChange(e, $scene.attr('id'));
	    });
	}
	
	function customModalExerciseChange(e) {
	    const upBlock = e.target.closest('.js-module');
	    const $this = $(this)
	    const $row = $this.closest('.row-wrap')
	    const $subject = $row.find('.js-quiz-subject')
	    const $lesson = $row.find('.js-quiz-lessons')
	    const $class = $row.find('.js-quiz-class')
	    const $scene = $row.find('.js-quiz-scenes')
	    const $exercise = $row.find('.js-quiz-exercise')
	    let current_exercise = '';
	
	    $exercise.each(function(index, value) {
	        if ($(value).is(':checked')) {
	            current_exercise = $(value).val();
	        }
	    });
	
	    const selectedLesson = $lesson.chosen().val();
	    if (selectedLesson) {
	        $.get(Routing.generate('private_office_pupil_quiz_scenes_query', {
	            'lesson_id': selectedLesson ? selectedLesson : null,
	            'exercise_type': current_exercise ? current_exercise : null,
	        }), function (data) {
	            $scene.empty().html(data);
	            reshMultiSelect.remove('select-sumo-select', upBlock.querySelector('.js-quiz-scenes'));
	            reshMultiSelect.load('select-sumo-select', upBlock.querySelector('.js-quiz-scenes'));
	            reshMultiSelect.run();
	            // $scene[0].sumo.reload();
	            customModalKeyupChange(e, $scene.attr('id'));
	
	            //$scene.trigger('chosen:updated')
	
	        });
	    }
	}
	
	$('.custom-modal').on('change', '.js-quiz-exercise', customModalExerciseChange);
	
	function customModalClassChange() {
	    const $this = $(this)
	    loadModuleLessons($this);
	}
	
	function loadModuleLessons(element) {
	    const $row = element.closest('.row-wrap');
	    const $class = $row.find('.js-quiz-class');
	    const $subject = $row.find('.js-quiz-subject');
	    const $topic = $('.js-quiz-lessons');
	    let $newWidgetElement = $('#quiz-modules-list');
	    let $newWidget = $('#quiz-modules-list').attr('data-prototype');
	    let $newWidgetLessonSplit = $newWidget.split('js-quiz-lessons');
	    let $newWidgetLessonSplitClear = $newWidgetLessonSplit[1].substring($newWidgetLessonSplit[1].indexOf('</select>'));
	    let $resultPrototype = '';
	    let exercise = $row.find('.js-quiz-exercise');
	
	    const selectedClass = $class.chosen().val();
	    const selectedClassText = $class.chosen().find('option:selected').text();
	    const selectedSubject = $subject.chosen().val();
	    const selectedSubjectText = $subject.chosen().find('option:selected').text();
	
	    if (selectedClass==1) {
	        $(exercise).each(function(index, value){
	            if (index==0) {
	                $(value).prop("checked", true);
	            } else {
	                $(value).prop("disabled", true);
	            }
	        })
	    } else {
	        $(exercise).each(function(index, value){
	            $(value).prop("disabled", false);
	        })
	    }
	
	    $.get(Routing.generate('private_office_pupil_quiz_lessons_query', {
	        'subject_id': selectedSubject ? selectedSubject : null,
	        'class_id': selectedClass ? selectedClass : null
	    }), function (data) {
	
	        $row.find('.js-quiz-lessons').empty().html(data);
	        $resultPrototype = $newWidgetLessonSplit[0] + ' js-quiz-lessons form-control" data-placeholder="Все уроки">' + data + $newWidgetLessonSplitClear;
	
	        let $SubjectSplit = $resultPrototype.split('js-quiz-subject');
	        let $SubjectSplitCut = $SubjectSplit[1].substring($SubjectSplit[1].indexOf('</select>')).replace('</select>','');
	        let $subjectsList = $SubjectSplit[1].split('</select>');
	        let $subjectsListClear = $subjectsList[0].replace('form-control">','').replace('selected="selected"','');
	        let $newSubjectSplit = $subjectsListClear.split('>'+selectedSubjectText+'<');
	        $subjectsListClear = $newSubjectSplit[0] + ' selected="selected">' + selectedSubjectText + '<' + $newSubjectSplit[1].replace('>'+selectedSubjectText+'<', '');
	        $resultPrototype = $SubjectSplit[0] + ' js-quiz-subject form-control">' + $subjectsListClear + '</select>' + $SubjectSplitCut;
	
	        let $ClassSplit = $resultPrototype.split('js-quiz-class');
	        let $ClassSplitCut = $ClassSplit[1].substring($ClassSplit[1].indexOf('</select>')).replace('</select>','');
	        let $classesList = $ClassSplit[1].split('</select>');
	        let $classesListClear = $classesList[0].replace('form-control">','').replace('selected="selected"','');
	        let $newClassSplit = $classesListClear.split('>'+selectedClassText+'<');
	        $classesListClear = $newClassSplit[0] + ' selected="selected">' + selectedClassText + '<' + $newClassSplit[1].replace('>'+selectedClassText+'<', '');
	        $resultPrototype = $ClassSplit[0] + ' js-quiz-class form-control">' + $classesListClear + '</select>' + $ClassSplitCut;
	
	        $($newWidgetElement).attr('data-prototype', $resultPrototype);
	
	        //$topic.trigger('chosen:updated');
	        $row.find('.js-quiz-lessons').trigger('chosen:updated');
	        $row.find('.js-quiz-scenes').empty();
	        $row.find('.js-quiz-scenes').trigger('chosen:updated');
	    });
	
	}
	
	function handleModule(module) {
	
	    const subjectSelect = module.find('.js-quiz-subject');
	    const classSelect = module.find('.js-quiz-class');
	    const lessonsSelect = module.find(('.select2entity'));
	    const url = lessonsSelect.data('ajax--url');
	
	    module.find('.js-quiz-subject, .js-quiz-class').on('change', function () {
	        const subjectId = subjectSelect.find('option:selected').val();
	        const classId = classSelect.find('option:selected').val();
	        if (subjectId !== "" && classId !== "") {
	            lessonsSelect.data('ajax--url', `${url}&subject_id=${subjectId}&class_id=${classId}`);
	            lessonsSelect.select2({
	                ajax: {
	                    url: lessonsSelect.data('ajax--url')
	                }
	            });
	        }
	    });
	    module.find('.select2entity').select2();
	}
	
	function jsChooseFromPreviewClick(e) {
	
	    let sceneSelector = $(this).data('scene-selector')
	    let sceneId = $(this).data('scene-id')
	    let vals = $('#'+sceneSelector).val()
	
	    if (vals)
	        vals.push(sceneId)
	    else
	        vals = sceneId
	
	     $('#'+sceneSelector).val(vals);
	
	    let index_flag = -1;
	    $('#'+sceneSelector+' option').each(function(index, value){
	        $(vals).each(function(ind_val, value_val) {
	            if ($(value).val()==value_val) {
	                // $(value).attr('selected', 'selected');
	                index_flag = index;
	            }
	        });
	
	        // $('#'+sceneSelector).parent().find('li.opt').each(function(ind_opt, value_opt){
	        $('#'+sceneSelector).parent().find('.multiselect__dropdown__result__option input').each(function(ind_opt, value_opt){
	            if (index_flag==ind_opt) {
	                // if (!$(value_opt).hasClass('selected')) $(value_opt).addClass('selected');
	                value_opt.checked = true;
	            }
	        });
	        index_flag = -1;
	
	    })
	}
	
	function startDateSelect(currentTime,$input) {
	    const endDate = $('#quiz_workEndTime');
	
	    if (endDate.val()) {
	        if (currentTime >= endDate.datetimepicker('getValue')) {
	            endDate.datetimepicker('reset');
	            $('.quiz_workEndTime_err').css('display', 'block');
	        } else {
	            $('.quiz_workEndTime_err').css('display', 'none');
	        }
	    }
	};
	
	function endDateSelect(currentTime,$input) {
	    const startDate = $('#quiz_workStartTime');
	
	    if (startDate.val()) {
	        if (currentTime <= startDate.datetimepicker('getValue')) {
	            $input.datetimepicker('reset');
	            $('.quiz_workEndTime_err').css('display', 'block');
	        } else {
	            $('.quiz_workEndTime_err').css('display', 'none');
	        }
	    }
	}
	
	
	function jsQuizEditClick(e) {
	    e.preventDefault();
	    e.stopPropagation();
	    const button = $(this);
	    const id = button.data('id');
	    const hasPupils = button.data('has-pupils');
	
	    $.ajax({
	        url: Routing.generate('private_office_teacher_quiz_edit', {'quiz': id}),
	        type: 'GET',
	        success: function (data) {
	            $('#add-quiz-modal').empty().html(data)
	            $('#add-quiz-modal').customModal();
	            $('#add-quiz-modal').customModal('popup');
	            $('.chosen-select').chosen();
	            reshMultiSelect.load('select-sumo-select');
	            reshMultiSelect.run();
	
	            $('.select-sumo-select').each(function(i, el) {
	                editKeyupChange(el);
	            });
	            
	            $('.js-add-quiz-btn').on('click', addModuleBtnClick);
	            $('#add-quiz-modal .js-close-modal').on('click', closeModalClick);
	            $('#add-quiz-modal .js-close-modal-quit').on('click', closeModalQuitClick);
	            $('#add-quiz-modal').on('hide:after', addQuizModalHide);
	            $('.add-quiz-form').on('click', '.js-delete-module-row', addQuizFormClick)
	            $('.custom-modal').on('change', '.js-quiz-subject', customModalSubjectChange);
	            $('.custom-modal').on('chosen:showing_dropdown', '.js-quiz-lessons', customModalShowingDropdown);
	            $('.lk-select-scenes .opt').on( 'mouseenter', '.active-result-more-link', chosenResultsMouseEnterMore)
	            $('.lk-select-scenes .chosen-results').on( 'mouseenter', 'li', chosenResultsLiMouseEnter)
	            $('.lk-select-scenes .chosen-results').on( 'mouseleave', 'li', lkSelectScenesMouseleave);
	
	            $('.lk-select-scenes .chosen-results').on( 'input', 'li', function() {
	                $('select.SlectBox')[0].sumo.reload();
	            })
	
	            $('#quiz_workStartTime').datetimepicker({ todayButton: false, step: 5, format: 'd.m.Y, H:i', onSelectTime: startDateSelect });
	            $('#quiz_workEndTime').datetimepicker({ todayButton: false, step: 5, format: 'd.m.Y, H:i', onSelectTime: endDateSelect });
	            $.datetimepicker.setLocale('ru');
	
	            $('.custom-modal').on('change', '.js-quiz-lessons', customModalLessonsChange);
	            $('.custom-modal').on('change', '.js-quiz-class', customModalClassChange)
	            $('#new_individual_test_users').on('focus', newIndividualTestUsers);
	            $('#new_individual_test_groups').on('focus', newIndividualTestGroups);
	            $('.add-quiz-form__lower-btn-row > .lk-form-submit:submit').click(jsQuizFormSubmit);
	
	            $('.SumoSelect>.optWrapper.multiple>.options li.opt').on( 'mouseenter', '.opt', function() {  debugger })
	            $('.SumoSelect>.optWrapper.multiple>.options li.opt').on( 'mouseenter', '.opt', chosenResultsLiMouseEnter)
	            $('.SumoSelect>.optWrapper.multiple>.options li.opt').on( 'mouseleave', '.opt', lkSelectScenesMouseleave)
	
	            $('.add-quiz-form__wrap').ready(quizWrap);
	        }
	    })
	}
	$('.js-quiz-edit').click(jsQuizEditClick);
	
	function quizWrap() {
	    $('.edit-disable').css('width', (parseInt($('.add-quiz-form__wrap').width())+60)+'px');
	    $('.edit-disable').css('height', (parseInt($('.add-quiz-form__wrap').height())-10)+'px');
	}
	
	
	function jsQuizAddClick(e) {
	    e.preventDefault();
	    e.stopPropagation();
	
	    $.ajax({
	        url: Routing.generate('private_office_teacher_quiz_add', {'control': $(this).data('control')}),
	        type: 'GET',
	        success: function (data) {
	            $('#add-quiz-modal').empty().html(data)
	            $('.chosen-select').chosen();
	            reshMultiSelect.load('select-sumo-select');
	            reshMultiSelect.run();
	            
	            $('.js-add-quiz-btn').on('click', addModuleBtnClick);
	            $('#add-quiz-modal .js-close-modal').on('click', closeModalClick);
	            $('#add-quiz-modal .js-close-modal-quit').on('click', closeModalQuitClick);
	            $('#add-quiz-modal').on('hide:after', addQuizModalHide);
	            $('.js-class-select').chosen().change(classSelectChange)
	            $('.add-quiz-form').on('click', '.js-delete-module-row', addQuizFormClick)
	            $('.custom-modal').on('change', '.js-quiz-subject', customModalSubjectChange);
	            $('.custom-modal').on('chosen:showing_dropdown', '.js-quiz-lessons', customModalShowingDropdown);
	            $('.custom-modal__content-center').on('chosen:showing_dropdown keyup change', '.js-quiz-scenes', customModalKeyupChange);
	            $('.lk-select-scenes .opt').on( 'mouseenter', '.active-result-more-link', chosenResultsMouseEnterMore)
	            $('.lk-select-scenes .chosen-results').on( 'mouseenter', 'li', chosenResultsLiMouseEnter)
	            $('.lk-select-scenes .chosen-results').on( 'mouseleave', 'li', lkSelectScenesMouseleave)
	
	            $('.lk-select-scenes .chosen-results').on( 'input', 'li', function() {
	                $('select.SlectBox')[0].sumo.reload();
	            })
	            
	            $('#quiz_workStartTime').datetimepicker({ todayButton: false, step: 5, format: 'd.m.Y, H:i', onSelectTime: startDateSelect });
	            $('#quiz_workEndTime').datetimepicker({ todayButton: false, step: 5, format: 'd.m.Y, H:i', onSelectTime: endDateSelect });
	            $.datetimepicker.setLocale('ru');
	
	            $('.custom-modal').on('change', '.js-quiz-lessons', customModalLessonsChange);
	            $('.custom-modal').on('change', '.js-quiz-class', customModalClassChange)
	            $('#new_individual_test_users').on('focus', newIndividualTestUsers);
	            $('#new_individual_test_groups').on('focus', newIndividualTestGroups);
	            $('.add-quiz-form__lower-btn-row > .lk-form-submit:submit').click(jsQuizFormSubmit);
	
	            $('.SumoSelect>.optWrapper.multiple>.options li.opt').on( 'mouseenter', '.opt', chosenResultsMouseEnterMore)
	            $('.SumoSelect>.optWrapper.multiple>.options li.opt').on( 'mouseenter', '.opt', chosenResultsLiMouseEnter)
	            $('.SumoSelect>.optWrapper.multiple>.options li.opt').on( 'mouseleave', '.opt', lkSelectScenesMouseleave)
	        }
	    })
	}
	$('#add-quiz-button').click(jsQuizAddClick);
	
	function jsQuizFormSubmit(e) {
	    let valid = false
	    let errors = 0
	    let errorBlock = $('.add-quiz-form__errors-block'),
	        titleBlock = $('#quiz_title'),
	        timeInput = $('#quiz_workTime'),
	        requiredTimeInp = timeInput.attr( 'required' ),
	        workStartTimeInput = $('#quiz_workStartTime'),
	        requiredworkStartTimeInp = workStartTimeInput.attr( 'required' ),
	        workEndTimeInput = $('#quiz_workEndTime'),
	        requiredworkEndTimeInp = workEndTimeInput.attr( 'required' );
	
	    if (!titleBlock.val()) {
	        titleBlock.addClass( 'add-quiz-error-class');
	        errors++;
	    } else {
	        titleBlock.removeClass( 'add-quiz-error-class')
	    }
	
	    titleBlock.on('change', function() {
	        if (!titleBlock.val()) {
	            errors++;
	            titleBlock.addClass( 'add-quiz-error-class');
	        } else {
	            titleBlock.removeClass( 'add-quiz-error-class');
	        }
	    })
	
	    if (requiredTimeInp) {
	        if( !timeInput.val() || timeInput.val() == '0') {
	            errors++;
	            timeInput.addClass( 'add-quiz-error-class');
	        } else {
	            timeInput.removeClass( 'add-quiz-error-class')
	        }
	    } else {
	        timeInput.removeClass( 'add-quiz-error-class')
	    }
	    timeInput.on('change', function() {
	        if (!timeInput.val()) {
	            errors++;
	            timeInput.addClass( 'add-quiz-error-class');
	        } else {
	            timeInput.removeClass( 'add-quiz-error-class');
	        }
	    })
	
	
	
	    if (requiredworkStartTimeInp) {
	        if( !workStartTimeInput.val() || workStartTimeInput.val() == '0') {
	            errors++;
	            workStartTimeInput.addClass( 'add-quiz-error-class');
	        } else {
	            workStartTimeInput.removeClass( 'add-quiz-error-class')
	        }
	    } else {
	        workStartTimeInput.removeClass( 'add-quiz-error-class')
	    }
	    workStartTimeInput.on('change', function() {
	        if (!workStartTimeInput.val()) {
	            errors++;
	            workStartTimeInput.addClass( 'add-quiz-error-class');
	        } else {
	            workStartTimeInput.removeClass( 'add-quiz-error-class');
	        }
	    })
	
	    if (requiredworkEndTimeInp) {
	        if( !workEndTimeInput.val() || workEndTimeInput.val() == '0') {
	            errors++;
	            workEndTimeInput.addClass( 'add-quiz-error-class');
	        } else {
	            workEndTimeInput.removeClass( 'add-quiz-error-class')
	        }
	    } else {
	        workEndTimeInput.removeClass( 'add-quiz-error-class')
	    }
	    workEndTimeInput.on('change', function() {
	        if (!workEndTimeInput.val()) {
	            errors++;
	            workEndTimeInput.addClass( 'add-quiz-error-class');
	        } else {
	            workEndTimeInput.removeClass( 'add-quiz-error-class');
	        }
	    })
	
	    if (workStartTimeInput.val() && workEndTimeInput.val()) {
	        if (workStartTimeInput.val() > workEndTimeInput.val()) {
	            errors++;
	            workEndTimeInput.addClass( 'add-quiz-error-class');
	            $('.quiz_workEndTime_err').css('display', 'block');
	        } else {
	            workEndTimeInput.removeClass( 'add-quiz-error-class');
	            $('.quiz_workEndTime_err').css('display', 'none');
	        }
	    }
	
	    let all_scenes = []
	
	    $('.row-wrap').each(function(index,item) {
	
	        let subject = $(item).find('.js-quiz-subject')
	        let school_class = $(item).find('.js-quiz-class')
	        let lesson = $(item).find('.js-quiz-lessons')
	        let scene = $(item).find('.js-quiz-scenes')
	        let exercise = $(item).find('.js-quiz-exercise:checked')
	        let selected_scenes = $(item).find('.opt.selected')
	
	            let sub = getValidField(subject),
	                sch = getValidField(school_class),
	                les = getValidField(lesson),
	                sc = getValidField(scene);
	
	            if ( sub || sch || les || sc ) {
	                errors++;
	            }
	        if (scene.val()) {
	            $(scene.val()).each(function(i,sel_item) {
	                all_scenes.push(subject.val()+'_'+school_class.val()+'_'+lesson.val()+'_'+exercise.val()+'_'+sel_item)
	            })
	
	        }
	    })
	
	    $('#scenes_all').val(all_scenes.join())
	
	    if (errors > 0) {
	        errorBlock.html('Заполнены не все обязательные поля');
	    } else {
	        valid = true
	    }
	
	    if (valid == false)
	        return false;
	}
	
	function getValidField( field ) {
	    let error = 0;
	    if (!field.val()) {
	        error++
	        field.parents('.lk-select').addClass( 'add-quiz-error-class');
	    } else { field.parents('.lk-select').removeClass( 'add-quiz-error-class'); error = 0 }
	
	    field.on('change', function() {
	        if (!field.val()) {
	            error++;
	            field.parents('.lk-select').addClass( 'add-quiz-error-class');
	        } else { field.parents('.lk-select').removeClass( 'add-quiz-error-class'); error = 0; $('.add-quiz-form__errors-block').html(''); }
	    })
	
	    return error
	}
	
	function jsQuizDeleteClick(e) {
	    e.preventDefault();
	    e.stopPropagation();
	    const button = $(this);
	    const id = button.data('id');
	    const hasPupils = button.data('has-pupils');
	
	    let warningText = '';
	    if (hasPupils === 1) {
	        warningText = getMessageText('delete_teacher_with_pupils');
	
	        Swal.fire({
	            cancelButtonColor: '#3085d6',
	            confirmButtonColor: '#fb5e3a',
	            reverseButtons: true,
	            focusCancel: true,
	            showCancelButton: true,
	            html: warningText,
	            confirmButtonText: 'Удалить',
	            cancelButtonText: 'Отмена',
	            footer: '<button type="button" class="swal2-cancel swal2-styled swal2-cancel-custom" aria-label="" style="display: inline-block; border-left-color: rgb(48, 133, 214); border-right-color: rgb(48, 133, 214);">Отмена</button>'
	        }).then((result) => {
	            if (result.value === true) {
	                $.ajax({
	                    url: Routing.generate('private_office_teacher_quiz_delete', {'quiz': id}),
	                    type: 'POST',
	                    success: function (result) {
	                        window.location.reload();
	                    }
	                })
	            }
	        });
	        $('.swal2-cancel-custom').click(function () {
	            Swal.close();
	        })
	    } else {
	        warningText = getMessageText('delete');
	
	        Swal.fire({
	            showCancelButton: true,
	            html: warningText,
	            confirmButtonText: 'Да',
	            cancelButtonText: 'Нет',
	        }).then((result) => {
	            if (result.value === true) {
	                $.ajax({
	                    url: Routing.generate('private_office_teacher_quiz_delete', {'quiz': id}),
	                    type: 'POST',
	                    success: function (result) {
	                        window.location.reload();
	                    }
	                })
	            }
	        });
	    }
	}
	
	$('.js-quiz-delete').click(jsQuizDeleteClick);
	
	function jsQuizDeleteStartedClick(e) {
	    e.preventDefault();
	    e.stopPropagation();
	
	    Swal.fire({
	        title: 'Удаление работы',
	        text: 'Наступило время выполнения работы. Удаление невозможно.'
	    });
	
	}
	
	$('.js-quiz-delete-started').click(jsQuizDeleteStartedClick);
	
	function newIndividualTestUsers(e) {
	    $("#quiz_userType_0").prop("checked", true);
	}
	
	function newIndividualTestGroups(e) {
	    $("#quiz_userType_1").prop("checked", true);
	}
	
	function clearErrors() {
	    $('.add-quiz-form__errors-block, .module-row__errors-block, .add-quiz-form__errors-row').html('');
	}
	
	function resultsDeleteBtnClick() {
	    const btn = $(this);
	    const groupData = [];
	    const pupilData = [];
	    const checkboxes = $('.timetable-results__table').find('.js-timetable-results-table-checkbox:checked');
	    checkboxes.each((index, checkbox) => {
	        const $checkbox = $(checkbox)
	        if ($checkbox.data('type') === 'group') {
	            groupData.push($checkbox.data('id'));
	        } else if ($checkbox.data('type') === 'pupil') {
	            pupilData.push($checkbox.data('id'));
	        }
	    });
	    ajaxButtonPost(
	        Routing.generate('private_office_pupil_timetable_remove_pupils', {'userCourse': btn.data('user-course')}),
	        {'groups': groupData, 'pupils': pupilData},
	        btn,
	        (result) => {
	            if (result.result === 'success') {
	                Swal.fire({
	                    title: result.title,
	                    text: result.message
	                }).then(() => {
	                    window.location.reload();
	                })
	            } else if (result.result === 'error') {
	                Swal.fire({
	                    title: 'Удаление из траектории',
	                    text: `Не удалось отзязать учетные записи.`
	                }).then(() => {
	                    window.location.reload();
	                })
	            }
	        }
	    );
	}
	
	$('.js-quiz-results-delete-btn').click(resultsDeleteBtnClick);
	
	function quizCommentBtnClick() {
	    let quiz_assessment = $('#quiz_assessment').val()
	    let quiz_comment = $('#quiz_comment').val()
	    let quizId = $('#quizId').val()
	    let current_assessment = $('#current_assessment').val()
	    let assessment_recommended = $('#assessment_recommended').val()
	    let userWork = $('#userWork').val()
	    let postdata = 'quiz_assessment='+quiz_assessment+'&quiz_comment='+quiz_comment+'&quizId='+quizId+'&userWork='+userWork;
	
	    $.ajax({
	        url: Routing.generate('private_office_teacher_quiz_pupil_work_edit'),
	        data: postdata,
	        type: 'POST',
	        success: function (data) {
	                Swal.fire({
	                    title: 'Сохранение',
	                    text: `Данные успешно сохранены.`
	                }).then((result) => {
	                    location.href = '/office/user/quiz/detail_by_pupil/'+quizId+'/'
	                });
	        }
	    })
	}
	$('#quiz_comment_submit').click(quizCommentBtnClick);
	
	function closeModalClick() {
	    let $target = $('#add-quiz-modal');
	
	    Swal.fire({
	        title: '<strong>Внимание!</strong>',
	        html: 'При закрытии окна все введенные вами данные будут утеряны! Вы действительно хотите выйти?',
	        showCloseButton: true,
	        showCancelButton: true,
	        focusConfirm: false,
	        confirmButtonText: 'Да',
	        confirmButtonAriaLabel: 'Да',
	        cancelButtonText: 'Отмена',
	        cancelButtonAriaLabel: 'Отмена'
	    }).then((result) => {
	        if (result.value===true || result===true) {
	            if ($target.length) {
	                $target.addClass('js-hide')
	                setTimeout(function () {
	                    $target.removeClass('js-shown js-modal-animation js-hide')
	                    $('body').css({overflowY: '', paddingRight: ''})
	                    if (typeof callback === "function") {
	                        callback()
	                    }
	                    $target.trigger('hide:after')
	                    $('#add-quiz-modal').empty()
	                }, 500)
	            }
	            if (typeof callback === "function") {
	                callback()
	            }
	        }
	    });
	}
	
	
	function changeQuizSort() {
	    let href = $(this).data('href');
	    let control = $(this).data('control');
	    if (control==1)
	        location.href = href+'?control=1&order='+$(this).val();
	    else
	        location.href = href+'?order='+$(this).val();
	}
	$('#quiz_sort').on('change', changeQuizSort);
	
	
	function closeModalQuitClick() {
	    let $target = $('#add-quiz-modal');
	
	    if ($target.length) {
	        $target.addClass('js-hide')
	        setTimeout(function () {
	            $target.removeClass('js-shown js-modal-animation js-hide')
	            $('body').css({overflowY: '', paddingRight: ''})
	            if (typeof callback === "function") {
	                callback()
	            }
	            $target.trigger('hide:after')
	            $('#add-quiz-modal').empty()
	        }, 500)
	    }
	}
	
	function addQuizModalClick() {
	
	    var $target = $(this);
	
	    Swal.fire({
	        title: '<strong>Внимание!</strong>',
	        html: 'При закрытии окна, все введенные вами данные будут утеряны! Вы действительно хотите выйти?',
	        showCloseButton: true,
	        showCancelButton: true,
	        focusConfirm: false,
	        confirmButtonText: 'Да, закрыть',
	        confirmButtonAriaLabel: 'Да, закрыть',
	        cancelButtonText: 'Отмена',
	        cancelButtonAriaLabel: 'Отмена'
	    }).then((result) => {
	        if (result.value===true || result===true) {
	            if ($target.length) {
	                $target.addClass('js-hide')
	                setTimeout(function () {
	                    $target.removeClass('js-shown js-modal-animation js-hide')
	                    $('body').css({overflowY: '', paddingRight: ''})
	                    if (typeof callback === "function") {
	                        callback()
	                    }
	                    $target.trigger('hide:after')
	                }, 500)
	            }
	            if (typeof callback === "function") {
	                callback()
	            }
	        }
	    });
	}
	
	function addQuizModalHide() {
	    $('.js-form-type-switch[value="default"]').trigger('click').trigger('change');
	    $('.chosen-select option:selected').removeAttr('selected');
	    $('.chosen-select').trigger('chosen:updated');
	    $('.js-module:not(:first-of-type)').remove();
	    $('#quiz-modules-list').data('widget-counter', 1);
	}
	
	function subjectSelectChange() {
	    const value = $(this).val()
	    const $subjects = $('.js-quiz-subject');
	    if (value === 'all') {
	        $subjects.show();
	        return;
	    }
	    const $current = $('.js-quiz-subject[data-subject-id=' + value + ']');
	    if ($current.length > 0) {
	        $subjects.hide();
	        $current.show();
	    }
	}
	
	$('.js-quiz-subject-select').on('change', subjectSelectChange);
	
	function getMessageText(key, courseName) {
	    const messages = {
	        'delete': `Вы точно хотите удалить задание?`,
	        'delete_teacher_with_pupils': `Вы точно хотите удалить траекторию? Она назначена для изучения ученикам. 
	        Полное её удаление приведет к потере связей. 
	        Для их сохранения можно перевести траекторию в категорию «Завершенные», при этом у всех учеников её категория также изменится`,
	        'finish_control': 'Завершить прохождение?'
	    }
	
	    return messages[key];
	}

/***/ }),
/* 73 */
/***/ (function(module, exports) {

	const registrationForm = $('#form-registration');
	registrationForm.find('.js-user-role select').chosen().change(function (evt, params) {
	   const role = $(this).find('option:selected').text();
	   const classRow = registrationForm.find('.js-user-class');
	   const schoolRow = registrationForm.find('#block-school');
	   if (role === 'Учитель' || role === 'Родитель') {
	      classRow.find('input').attr('required', false);
	      classRow.hide();
	   } else {
	      classRow.find('input').attr('required', true);
	      classRow.show();
	   }
	   if (role === 'Родитель' && ($("#application_sonata_user_registration_country option:selected").val() == 183)) {
	      schoolRow.find('select').attr('required', false);
	      schoolRow.hide();
	   } else {
	      schoolRow.find('select').attr('required', true);
	      schoolRow.show();
	   }
	});

/***/ }),
/* 74 */
/***/ (function(module, exports) {

	$('.collection-search__input').on('click', function () {
	    var t = $(this).parent();
	
	    t.addClass('active');
	    t.find('.collection-search-close').removeClass('search-close_hide');
	    $('.mask').fadeIn();
	});
	
	$('.collection-search-close').on('click', function (e) {
	    e.stopPropagation();
	
	    $(this).addClass('search-close_hide');
	    $('.mask').fadeOut();
	    $('.collection-search').removeClass('active');
	});
	
	$('.mask').on('click', function () {
	    $(this).fadeOut();
	    $('.collection-search').removeClass('active');
	    $('.collection-search-close').addClass('search-close_hide');
	});
	
	// clear
	$('.search-input__clear-btn').on('click', function (e) {
	    e.stopPropagation();
	
	    var t = $(this),
	        input = t.next();
	
	    input.val('');
	    t.addClass('closeblock');
	});
	$('.collection-search__input input').on('input', function () {
	    var t = $(this),
	        value = t.val(),
	        closeButton = t.prev();
	
	    if ( value != '' ) {
	        closeButton.removeClass('closeblock').addClass('showblock');
	    } else {
	        closeButton.removeClass('showblock').addClass('closeblock');
	    }
	});

/***/ }),
/* 75 */
/***/ (function(module, exports) {

	var selectOne = $('._selecteable-one');
	
	selectOne.on('click',function () {
	    selectOne.removeClass('_selected');
	    $(this).addClass('_selected');
	});


/***/ }),
/* 76 */
/***/ (function(module, exports) {

	$('.special-course').on('click', '.js-show-more-btn button', function () {
	    const btn = $(this);
	    btn.prop('disabled', true).text('Загружается...');
	    $.get(btn.data('href'), function (data) {
	        const block = $('<div>' + data + '</div>');
	        $('.lesson-blocks').append(block.find('.lesson-blocks').html());
	        if (block.find('.js-show-more-btn').length > 0) {
	            $('.js-show-more-btn').html(block.find('.js-show-more-btn').html());
	        } else {
	            $('.js-show-more-btn').remove();
	        }
	    }, 'html');
	    return false;
	});
	
	const lessonFilters = $('.special-course .lesson-filters');
	lessonFilters.on('change', '.js-lesson-choose-section', function() {
	    const lessonSelect = $(this);
	    const currentCourse = lessonFilters.data('current-course');
	    const sectionId = lessonSelect.val();
	    window.location.href = Routing.generate('resh.special_course_by_id', {
	        'course': currentCourse,
	        'section': sectionId === 'all' ? null : sectionId
	    });
	});
	
	lessonFilters.on('click', '.js-search-lesson-names-btn', function() {
	    const searchBtn = $(this);
	    const search = searchBtn.prev('input').val();
	    const currentCourse = lessonFilters.data('current-course');
	    if (!search || 0 === search.length) {
	        return;
	    }
	    window.location.href = Routing.generate('resh.special_course_by_id', {
	        'course': currentCourse,
	        'search': search
	    });
	});
	
	lessonFilters.on('keypress', function (e) {
	    if (e.which == 13) {
	        lessonFilters.find('.js-search-lesson-names-btn').click();
	        return false;
	    }
	});

/***/ }),
/* 77 */
/***/ (function(module, exports) {

	const $summerEducation = $('.summer-education');
	
	if ($summerEducation.length > 0) {
	    const search = $summerEducation.find('.collection-search');
	    const searchButton = $summerEducation.find('.js-summer-resources-search');
	    const typeSelect = $summerEducation.find('.js-summer-resources-type');
	    const formatSelect = $summerEducation.find('.js-summer-resources-format');
	    const organizationSelect = $summerEducation.find('.js-summer-resources-organization');
	
	    searchButton.click(function () {
	        window.location.href = Routing.generate('resh_summer_education', {
	            'search': searchValue = search.find('input').val()
	        });
	    })
	    search.find('input').on('keyup', function(e) {
	        if (e.keyCode === 13) {
	            window.location.href = Routing.generate('resh_summer_education', {
	                'search': searchValue = search.find('input').val()
	            });
	        }
	    });
	    $summerEducation.on(
	        'change',
	        '.js-summer-resources-search, .js-summer-resources-type, .js-summer-resources-format, .js-summer-resources-organization',
	        function () {
	            const url = Routing.generate('resh_summer_education', getQuery())
	            window.location.href = url;
	        });
	
	    function getQuery() {
	        const searchValue = search.find('input').val();
	        const currentType = typeSelect.chosen().val();
	        const currentFormat = formatSelect.chosen().val();
	        const currentOrganization = organizationSelect.chosen().val();
	        const result = {};
	        if (searchValue !== "") {
	            result['search'] = searchValue;
	        }
	        if (currentType !== "") {
	            result['type'] = currentType;
	        }
	        if (currentFormat !== "") {
	            result['format'] = currentFormat;
	        }
	        if (currentOrganization !== "") {
	            result['organization'] = currentOrganization;
	        }
	        return result;
	    }
	}
	


/***/ }),
/* 78 */
/***/ (function(module, exports) {

	const $actionBlock = $('.js-switch-group-action')
	const $inputText = $actionBlock.find('div[class*=col] > input[type=text]')
	const $inputTextRow = $inputText.closest('.row')
	const $select = $actionBlock.find('.chosen-select-type-2')
	const $selectRow = $select.closest('.row')
	
	const warnings = ['Выберите один из вариантов', 'Введите название новой группы', 'Выберите группу']
	
	let warningTemplate = $('<div class="add-group-warning text-center position-absolute"></div>')
	
	
	$inputTextRow.on('click', function () {
	    $(this).removeClass('inactive')
	    $select.val('').trigger("chosen:updated")
	    $selectRow.addClass('inactive')
	    warningTemplate.remove()
	})
	
	$selectRow.on('click', function () {
	    $(this).removeClass('inactive')
	    $inputTextRow.addClass('inactive')
	    $inputText.val('')
	    warningTemplate.remove()
	})
	
	$('.js-add-group-form').on('submit', function (e) {
	    if (!$actionBlock.find('.inactive').length) {
	        e.preventDefault()
	        $(this).append(warningTemplate.text(warnings[0]))
	    } else if ($selectRow.hasClass('inactive') && !$inputText.val()) {
	        e.preventDefault()
	        $(this).append(warningTemplate.text(warnings[1]))
	    } else if ($inputTextRow.hasClass('inactive') && !$select.val()) {
	        e.preventDefault()
	        $(this).append(warningTemplate.text(warnings[2]))
	    }
	})


/***/ }),
/* 79 */
/***/ (function(module, exports) {

	$('.user-action span.tab').on('click', function () {
	    var el = $(this),
	        root = el.closest('.menu-slide__content'),
	        index = root.find('.user-action .tab').index(el),
	        contents = root.find('> .tab-content');
	    
	    if (!el.hasClass('tab-active')) {
	        root.find('> .menu-slide__row').find('> .user-action').find('.tab-active').removeClass('tab-active');
	        el.addClass('tab-active');
	        contents.removeClass('tab-content-visible').eq(index).addClass('tab-content-visible');
	    }
	});


/***/ }),
/* 80 */
/***/ (function(module, exports) {

	$('._tabs__tab').on('click', function () {
	    var el = $(this),
	        root = el.closest('._tabs'),
	        index = root.find('._tabs__tab').index(el),
	        contents = root.find('._tabs__content');
	
	    if (!el.hasClass('_tab-active')) {
	        root.find('._tab-active').removeClass('_tab-active');
	        el.addClass('_tab-active');
	        contents.removeClass('_tab-cont-visible').eq(index).addClass('_tab-cont-visible');
	    }
	});
	
	


/***/ }),
/* 81 */
/***/ (function(module, exports) {

	$('.test__tab').on('click', function () {
	    var el = $(this),
	        root = el.closest('.tabs'),
	        index = root.find('.test__tab').index(el),
	        contents = root.find('.test__task');
	
	    if (!el.hasClass('tab-active')) {
	        root.find('.test__tab_active').removeClass('test__tab_active');
	        el.addClass('test__tab_active');
	        
	        contents.removeClass('test__task_active').eq(index).addClass('test__task_active');
	
	    }
	});


/***/ }),
/* 82 */
/***/ (function(module, exports) {

	// abc choice
	
	$('.teachers-abc-choise button').on('click', function() {
	    var t = $(this),
	        btns = t.parent().find('button');
	
	    btns.removeClass('active');
	    t.addClass('active');
	});
	


/***/ }),
/* 83 */
/***/ (function(module, exports) {

	$('.lk-popup').find('.lk-form-submit').on('click', function () {
	    $(this).closest('.lk-popup').addClass('closeblock');
	    $('.mask').fadeOut(1000);
	});
	
	$('.my-id__add-child__btn').on('click', function () {
	    var t = $(this);
	    t.prev().prev().fadeIn(700);
	    t.prev().fadeIn(700);
	    t.fadeOut(0);
	});

/***/ }),
/* 84 */
/***/ (function(module, exports) {

	if ( $('.test-sentence__clear-btn').length > 0 ) {
	
	    var sentencesWords = $('.test-sentence__text-area span'),
	        sentencesButtonsBox = $('.test-sentence__buttons-line'),
	        sentencesButtons = sentencesButtonsBox.find('input');
	
	    sentencesWords.on('click', function () {
	       var t = $(this),
	           chekedButtonClass = sentencesButtons.filter(':checked').attr('class');
	
	       t.removeAttr('class');
	
	        switch ( chekedButtonClass ) {
	            case 'gramm-subject-input test-sentense-input':
	                t.addClass('gramm-subject');
	                break;
	            case 'predicate-input test-sentense-input':
	                t.addClass('predicate');
	                break;
	            case 'gramm-object-input test-sentense-input':
	                t.addClass('gramm-object');
	                break;
	            case 'gramm-modifier-input test-sentense-input':
	                t.addClass('gramm-modifier');
	                break;
	            case 'adverbial-input test-sentense-input':
	                t.addClass('adverbial-common');
	                break;
	            case 'blue-input test-sentense-input':
	                t.addClass('text-blue');
	                break;
	            case 'orange-input test-sentense-input':
	                t.addClass('text-orange');
	                break;
	            case 'purple-input test-sentense-input':
	                t.addClass('text-purple');
	                break;            
	        }
	    });
	
	
	    $('.test-sentence__clear-btn').on('click', function () {
	        
	        sentencesButtons.prop('checked', false);
	        sentencesWords.removeAttr('class');
	
	    });
	
	}

/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

	const Swal = __webpack_require__(40);
	const ajaxButtonPost = __webpack_require__(4);
	
	const $courseForm = $('.add-course-form');
	const $classSelect = $('.js-class-select');
	const $addModuleBtn = $('.js-add-module-btn');
	$.fn.customModal('show', '#default-course-warning')
	
	$courseForm.on('change', function () {
	    $(this).find('button[type=submit]').attr('disabled', false)
	})
	$classSelect.chosen().change(function () {
	    var $this = $(this)
	    var $row = $this.closest('.row')
	    var $nextSelect = $row.find('.js-subject')
	    var $genderSelectRow = $row.next();
	
	    if (+$this.val() === 1) {
	        $nextSelect.attr("disabled", true).trigger("chosen:updated")
	    } else {
	        $nextSelect.removeAttr('disabled').trigger("chosen:updated")
	    }
	
	    if (+$this.val() === 7 || +$this.val() === 8) {
	        $genderSelectRow.removeClass('hidden');
	    } else {
	        $genderSelectRow.addClass('hidden');
	    }
	})
	
	$addModuleBtn.click(function () {
	    const list = $($(this).attr('data-list-selector'));
	    let counter = list.data('widget-counter') || list.children().length;
	    let newWidget = list.attr('data-prototype');
	    newWidget = newWidget.replace(/__name__/g, counter);
	    counter++;
	
	    list.data('widget-counter', counter);
	    const newElem = $(newWidget);
	    newElem.appendTo(list);
	
	    $('.chosen-select').chosen({
	        disable_search_threshold: 10,
	        no_results_text: "Ничего не найдено"
	    });
	    if (counter >= 4) {
	        clearErrors();
	        $('.add-course-form__errors-block').html('Добавлено максимальное количество позиций по параметру «предмет-класс». Дополнительные позиции можно включить в новый индивидуальный курс.')
	        $addModuleBtn.attr('disabled', true)
	    }
	});
	
	$('.add-course-form').on('click', '.js-delete-module-row', function () {
	    $(this).closest('li').remove()
	    const list = $($addModuleBtn.attr('data-list-selector'));
	    let counter = list.data('widget-counter') || list.children().length;
	    counter--;
	    list.data('widget-counter', counter);
	    $addModuleBtn.attr('disabled', false)
	    clearErrors()
	})
	
	$('.custom-modal').on('change', '.js-module-subject', function () {
	    const $this = $(this)
	    const $row = $this.closest('.row')
	    const $subject = $row.find('.js-module-subject')
	    const $class = $row.find('.js-module-class')
	
	    const selectedSubject = $subject.chosen().val();
	    $.get(Routing.generate('private_office_pupil_timetable_module_classes_query', {
	        'subject_id': selectedSubject ? selectedSubject : null,
	    }), function (data) {
	        $class.html(data);
	        $class.trigger('chosen:updated')
	    });
	
	});
	$('.custom-modal').on('chosen:showing_dropdown', '.js-module-topics', function () {
	    const $this = $(this);
	    if ($this.children('option').length === 0) {
	        loadModuleLessons($this);
	    }
	})
	
	$('.custom-modal').on('change', '.js-module-class', function () {
	    const $this = $(this)
	    loadModuleLessons($this);
	})
	
	function loadModuleLessons(element) {
	    const $row = element.closest('.row')
	    const $class = $row.find('.js-module-class')
	    const $topic = $row.find(".js-module-topics")
	    const $subject = $row.find('.js-module-subject')
	    if (element.hasClass('js-module-subject')) {
	        $class.val('').trigger('chosen:updated')
	    }
	    const selectedClass = $class.chosen().val();
	    const selectedSubject = $subject.chosen().val();
	    $.get(Routing.generate('private_office_pupil_timetable_module_lessons_query', {
	        'subject_id': selectedSubject ? selectedSubject : null,
	        'class_id': selectedClass ? selectedClass : null
	    }), function (data) {
	        $topic.html(data);
	        $topic.trigger('chosen:updated')
	    });
	}
	
	
	$('.js-form-type-switch').each(function () {
	
	    var $this = $(this)
	
	    var $section = $this.parent().next()
	    var $thisShield = $section.find('.js-shield')
	
	    if ($this.is(':checked')) {
	        $thisShield.fadeOut()
	    }
	})
	
	$('.js-form-type-switch').on('change', function () {
	    var $this = $(this)
	    var $allShields = $('.js-shield')
	    var $section = $this.parent().next()
	    var $thisShield = $section.find('.js-shield')
	
	    clearErrors()
	    $allShields.not($thisShield[0]).fadeIn(200)
	    $thisShield.fadeOut(200)
	})
	
	function handleModule(module) {
	
	    const subjectSelect = module.find('.js-module-subject');
	    const classSelect = module.find('.js-module-class');
	    const lessonsSelect = module.find(('.select2entity'));
	    const url = lessonsSelect.data('ajax--url');
	
	    module.find('.js-module-subject, .js-module-class').on('change', function () {
	        const subjectId = subjectSelect.find('option:selected').val();
	        const classId = classSelect.find('option:selected').val();
	        if (subjectId !== "" && classId !== "") {
	            lessonsSelect.data('ajax--url', `${url}&subject_id=${subjectId}&class_id=${classId}`);
	            lessonsSelect.select2({
	                ajax: {
	                    url: lessonsSelect.data('ajax--url')
	                }
	            });
	        }
	    });
	    module.find('.select2entity').select2();
	}
	
	$('.js-timetable-course-delete').click(function (e) {
	    e.preventDefault();
	    e.stopPropagation();
	    const button = $(this);
	    const url = button.attr('href');
	    const courseType = button.data('type');
	    const hasPupils = button.data('has-pupils');
	    const courseName = button.data('course-name');
	    const courseFullName = button.data('course-full-name');
	    const userCourse = button.data('user-course');
	    const courseParentType = button.data('parent-type');
	
	    let warningText = '';
	    if (hasPupils === 1) {
	        if (courseParentType === 'parent') {
	            warningText = getMessageText('delete_parent_with_pupils', courseName);
	        } else if (courseParentType === 'teacher') {
	            warningText = getMessageText('delete_teacher_with_pupils', courseName);
	        }
	
	        Swal.fire({
	            cancelButtonColor: '#3085d6',
	            confirmButtonColor: '#fb5e3a',
	            reverseButtons: true,
	            focusCancel: true,
	            showCancelButton: true,
	            html: warningText,
	            confirmButtonText: 'Удалить',
	            cancelButtonText: 'Перевести в Завершенные',
	            footer: '<button type="button" class="swal2-cancel swal2-styled swal2-cancel-custom" aria-label="" style="display: inline-block; border-left-color: rgb(48, 133, 214); border-right-color: rgb(48, 133, 214);">Отмена</button>'
	        }).then((result) => {
	            if (result.dismiss === Swal.DismissReason.cancel) {
	                console.log('Перевести в Завершенные')
	                $.ajax({
	                    url: Routing.generate('private_office_pupil_timetable_set_inactive_course', {'userCourse': userCourse}),
	                    type: 'POST',
	                    success: function (result) {
	                        window.location.reload();
	                    }
	                })
	            }
	            if (result.value === true) {
	                window.location = url;
	            }
	        });
	        $('.swal2-cancel-custom').click(function () {
	            Swal.close();
	        })
	    } else {
	        if (courseType === 'individual') {
	            warningText = getMessageText('delete_individual', courseName);
	        } else if (courseType === 'default') {
	            warningText = getMessageText('delete_default', courseFullName);
	        }
	
	        Swal.fire({
	            showCancelButton: true,
	            html: warningText,
	            confirmButtonText: 'Да',
	            cancelButtonText: 'Нет',
	        }).then((result) => {
	            if (result.value === true) {
	                window.location = url;
	            }
	        });
	    }
	});
	
	function clearErrors() {
	    $('.add-course-form__errors-block, .module-row__errors-block, .add-course-form__errors-row').html('');
	}
	
	$('.js-timetable-results-delete-btn').click(function () {
	    const btn = $(this);
	    const groupData = [];
	    const pupilData = [];
	    const checkboxes = $('.timetable-results__table').find('.js-timetable-results-table-checkbox:checked');
	    checkboxes.each((index, checkbox) => {
	        const $checkbox = $(checkbox)
	        if ($checkbox.data('type') === 'group') {
	            groupData.push($checkbox.data('id'));
	        } else if ($checkbox.data('type') === 'pupil') {
	            pupilData.push($checkbox.data('id'));
	        }
	    });
	    ajaxButtonPost(
	        Routing.generate('private_office_pupil_timetable_remove_pupils', {'userCourse': btn.data('user-course')}),
	        {'groups': groupData, 'pupils': pupilData},
	        btn,
	        (result) => {
	            if (result.result === 'success') {
	                Swal.fire({
	                    title: result.title,
	                    text: result.message
	                }).then(() => {
	                    window.location.reload();
	                })
	            } else if (result.result === 'error') {
	                Swal.fire({
	                    title: 'Удаление из траектории',
	                    text: `Не удалось отзязать учетные записи.`
	                }).then(() => {
	                    window.location.reload();
	                })
	            }
	        }
	    );
	})
	
	$('#add-course-modal').on('hide:after', function () {
	    // $courseForm[0].reset();
	    $('.js-form-type-switch[value="default"]').trigger('click').trigger('change');
	    $('.chosen-select option:selected').removeAttr('selected');
	    $('.js-day-select').val(4);
	    $('.chosen-select').trigger('chosen:updated');
	    $('.js-module:not(:first-of-type)').remove();
	    $('#individual-course-modules-list').data('widget-counter', 1);
	    $addModuleBtn.prop('disabled', false);
	});
	
	$('.js-timetable-subject-select').on('change', function () {
	    const value = $(this).val()
	    const $subjects = $('.js-timetable-subject');
	    if (value === 'all') {
	        $subjects.show();
	        return;
	    }
	    const $current = $('.js-timetable-subject[data-subject-id=' + value + ']');
	    if ($current.length > 0) {
	        $subjects.hide();
	        $current.show();
	    }
	});
	
	function getMessageText(key, courseName) {
	    const messages = {
	        'delete_default': `Вы точно хотите удалить траекторию "${courseName}"?`,
	        'delete_individual': `Вы точно хотите удалить траекторию "${courseName}"?`,
	        'delete_teacher_with_pupils': `Вы точно хотите удалить траекторию "${courseName}"? Она назначена для изучения ученикам. 
	        Полное её удаление приведет к потере связей. 
	        Для их сохранения можно перевести траекторию в категорию «Завершенные», при этом у всех учеников её категория также изменится`,
	        'delete_parent_with_pupils': `Вы точно хотите удалить траекторию "${courseName}"? Она назначена для изучения вашим детям. 
	        Полное её удаление приведет к потере связей. 
	        Для их сохранения можно перевести траекторию в категорию «Завершенные», при этом у детей её категория также изменится`,
	    }
	
	    return messages[key];
	}

/***/ }),
/* 86 */
/***/ (function(module, exports) {

	function timetableLinkHover(el, root) {
	    $(el).hover(function () {
	        $(this).closest(root).find('a').addClass('_hovered');
	    }, function () {
	        $(this).closest(root).find('a').removeClass('_hovered');
	    })
	}
	
	timetableLinkHover($('.timetbl-current__link'), 'tr');

/***/ }),
/* 87 */
/***/ (function(module, exports) {

	if ('undefined' != typeof window['tinymce']) {
	tinymce.PluginManager.add('plain_word', function (editor, url) {
	    editor.addButton('plain_word', {
	        text: 'из Word',
	        icon: 'code',
	        tooltip: 'Вставить из Word',
	        onclick: function () {
	            editor.windowManager.open({
	                title: 'Вставить текст из Word',
	                width: 400,
	                height: 200,
	                body: [
	                    {type: 'textbox', name: 'text', label: 'Текст'},
	                    {type: 'label', text: 'Вставить как формулу:'},
	                    {
	                        type: 'checkbox',
	                        checked: true,
	                        text: 'MS Word',
	                        name: 'isFormulaWord',
	                        tooltip: 'Сразу в кавычках'
	                    },
	                    {
	                        type: 'checkbox',
	                        checked: false,
	                        text: 'LaTeX',
	                        name: 'isFormulaLatex',
	                        tooltip: 'Сразу в $$'
	                    }
	                ],
	                onsubmit: function (e) {
	                    e.data.text = $.trim(e.data.text);
	                    if (e.data.text.length) {
	                        if (e.data.isFormulaWord) {
	                            e.data.text = '`' + e.data.text + '`';
	                        } else if(e.data.isFormulaLatex){
	                            e.data.text = '$' + e.data.text + '$';
	                        }
	                        editor.insertContent(e.data.text);
	                    }
	                }
	            });
	        }
	    });
	});
	
	tinymce.PluginManager.add('set_as_formula', function (editor, url) {
	    editor.addButton('set_as_formula', {
	        text: 'F',
	        icon: false,
	        tooltip: 'Отметить как формула',
	        onclick: function () {
	            var selectContent = editor.selection.getContent();
	            if (selectContent.length) {
	                if (selectContent.startsWith('`') && selectContent.endsWith('`')) {
	                    editor.selection.setContent(selectContent.substr(1, selectContent.length - 2));
	                } else {
	                    editor.selection.setContent('`' + selectContent + '`');
	                }
	            }
	        }
	    });
	});
	
	tinymce.PluginManager.add('set_as_latex_formula', function (editor, url) {
	    editor.addButton('set_as_latex_formula', {
	        text: 'LaTeX',
	        icon: false,
	        tooltip: 'Формула LaTeX',
	        onclick: function () {
	            var selectContent = editor.selection.getContent();
	            if (selectContent.length) {
	                if (selectContent.startsWith('$') && selectContent.endsWith('$')) {
	                    editor.selection.setContent(selectContent.substr(1, selectContent.length - 2));
	                } else {
	                    editor.selection.setContent('$' + selectContent + '$');
	                }
	            }
	        }
	    });
	});
	
	function admitTextAreaInitMCE($selector) {
	    return tinymce.init({
	        selector: $selector,
	        height: 640,
	
	        plugins: [
	            'advlist autolink lists link image charmap print preview hr anchor pagebreak fullscreen',
	            'searchreplace wordcount visualblocks visualchars code fullscreen',
	            'insertdatetime media nonbreaking save table contextmenu directionality',
	            'emoticons template paste textcolor colorpicker textpattern imagetools plain_word set_as_formula set_as_latex_formula'
	        ],
	        content_style: "p, li, div {line-height: 1.5; font-family: TimesNewRoman; font-size: 12pt; margin: 0 0 12pt; text-indent: 1.5em; } ol, ul{padding-left: 1.5em;} td{vertical-align:top}",
	        fontsize_formats: '8pt 10pt 12pt 14pt 18pt 24pt 36pt',
	        toolbar1: 'styleselect | fontsizeselect | bold italic underline | forecolor backcolor | alignleft aligncenter alignright alignjustify | bullist numlist outdent indent | link image media emoticons | plain_word set_as_formula set_as_latex_formula | paste removeformat | insertfile undo redo | preview fullscreen',
	        image_advtab: true,
	        automatic_uploads: true,
	        paste_data_images: true,
	        language_url: '/custom/js/vendor/tinymce/langs/ru.js',
	        language: 'ru',
	        images_dataimg_filter: function (img) {
	            return img.hasAttribute('internal-blob');
	        },
	        images_upload_handler: function (blobInfo, success, failure) {
	            success("data:" + blobInfo.blob().type + ";base64," + blobInfo.base64());
	        },
	
	        font_formats: 'Times New Roman=times new roman,times;',
	
	        paste_preprocess: function (plugin, args) {
	            var input = args.content;
	
	            // remove line breaks / Mso classes
	            var stringStripper = /(\n|\r| class=(")?Mso[a-zA-Z]+(")?)/g;
	            var output = input.replace(stringStripper, ' ');
	            // strip Word generated HTML comments
	            var commentSripper = new RegExp('<!--(.*?)-->', 'g');
	            output = output.replace(commentSripper, '');
	            var tagStripper = new RegExp('<(/)*(meta|link|span|\\?xml:|st1:|o:|font)(.*?)>', 'gi');
	            // remove tags leave content if any
	            output = output.replace(tagStripper, '');
	            // remove everything in between and including tags '<style(.)style(.)>'
	            var badTags = ['style', 'script', 'applet', 'embed', 'noframes', 'noscript'];
	
	            for (var i = 0; i < badTags.length; i++) {
	                tagStripper = new RegExp('<' + badTags[i] + '.*?' + badTags[i] + '(.*?)>', 'gi');
	                output = output.replace(tagStripper, '');
	            }
	            // remove attributes
	            var badAttributes = ['class', 'align', 'hspace', 'name'];
	            for (var i = 0; i < badAttributes.length; i++) {
	                var attributeStripper = new RegExp(' ' + badAttributes[i] + '="(.*?)"', 'gi');
	                output = output.replace(attributeStripper, '');
	            }
	            args.content = output;
	        },
	        paste_convert_word_fake_lists: false
	    });
	};
	}

/***/ }),
/* 88 */
/***/ (function(module, exports) {

	var animationTime = 700;
	var submitBtn = $('._submit-btn');
	
	const $tosAgree = $('._tos-agree');
	const $tosCheck = $('._tos-check');
	
	$('._tos-link').on('click', function (e) {
	   e.preventDefault();
	   $('._terms-window').addClass('_shown _displayed-tos');
	   $('html, body').animate({scrollTop: 0}, 500);
	});
	
	$('._tos-close').on('click', function () {
	   closeTos();
	});
	
	$tosAgree.on('click', function () {
	   closeTos();
	   $tosCheck.prop('checked', true);
	   submitBtn.attr('disabled', false);
	   $('html, body').animate({scrollTop: 170}, 500);
	});
	
	$tosCheck.on('change', function () {
	   if ($tosCheck.is(':checked'))
	      submitBtn.attr('disabled', false);
	   else
	      submitBtn.attr('disabled', true);
	});
	
	$(document).keyup(function (e) {
	   if (e.keyCode == 27 && $('._terms-window').hasClass('_shown')) {
	      closeTos();
	   }
	});
	
	function closeTos() {
	   var block = $('._terms-window');
	   block.removeClass('_shown');
	   setTimeout(function () {
	      block.removeClass('_displayed-tos');
	   }, animationTime);
	}
	
	


/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(90);
	
	const tvLessonsForm = $('.tv-lessons__date-form');
	const dateInput = $('.tv-lessons-datepicker');
	const timezoneForm = $('.tv-lessons__timezone');
	let selectableDates = [];
	
	if (dateInput.length > 0) {
	    $.get(
	        Routing.generate('resh_tv_lessons_selectable_dates'),
	        (result) => {
	            selectableDates = result;
	        }
	    );
	
	}
	
	const disableDates = (date) => {
	    if (selectableDates.length === 0) {
	        return [true];
	    }
	    const string = $.datepicker.formatDate('yy-mm-dd', date);
	    return [!(selectableDates.indexOf(string) === -1)];
	}
	
	dateInput.datepicker({
	    dateFormat: 'D, d MM',
	    altField: ".tv-lessons__date-form__date",
	    monthNames: ['января','февраля','марта','апреля','мая','июня',
	        'июля','августа','сентября','октября','ноября','декабря'],
	    dayNamesShort: ['вс','пн','вт','ср','чт','пт','сб'],
	    altFormat: "yy.mm.dd",
	    beforeShowDay: disableDates
	}).datepicker('widget').wrap('<div class="ll-skin-melon"/>');
	
	dateInput.on('change', function () {
	    tvLessonsForm.submit();
	});
	
	timezoneForm.on('change', 'select', function () {
	    timezoneForm.submit()
	});

/***/ }),
/* 90 */
/***/ (function(module, exports) {

	/* Russian (UTF-8) initialisation for the jQuery UI date picker plugin. */
	/* Written by Andrew Stromnov (stromnov@gmail.com). */
	jQuery(function($){
		$.datepicker.regional['ru'] = {
			closeText: 'Закрыть',
			prevText: '&#x3C;Пред',
			nextText: 'След&#x3E;',
			currentText: 'Сегодня',
			monthNames: ['Январь','Февраль','Март','Апрель','Май','Июнь',
			'Июль','Август','Сентябрь','Октябрь','Ноябрь','Декабрь'],
			monthNamesShort: ['Янв','Фев','Мар','Апр','Май','Июн',
			'Июл','Авг','Сен','Окт','Ноя','Дек'],
			dayNames: ['воскресенье','понедельник','вторник','среда','четверг','пятница','суббота'],
			dayNamesShort: ['вск','пнд','втр','срд','чтв','птн','сбт'],
			dayNamesMin: ['Вс','Пн','Вт','Ср','Чт','Пт','Сб'],
			weekHeader: 'Нед',
			dateFormat: 'dd.mm.yy',
			firstDay: 1,
			isRTL: false,
			showMonthAfterYear: false,
			yearSuffix: ''};
		$.datepicker.setDefaults($.datepicker.regional['ru']);
	});


/***/ }),
/* 91 */
/***/ (function(module, exports) {

	var warning = $('.bottom-warning');
	var close = warning.find('.slider-exit');
	var closeButton = $('#close_button');
	
	$(function () {
	    if ( localStorage.getItem('warningShownYear') !== 'shown') {
	        setTimeout(function () {
	            warning.addClass('_animated');
	        }, 1000);
	    }
	
	    close.on('click', function () {
	        warning.removeClass('_animated');
	        setTimeout(function () {
	            hideWarning();
	        },600);
	    });
	
	    closeButton.on('click', function () {
	        warning.removeClass('_animated');
	        setTimeout(function () {
	            hideWarning();
	        },600);
	        return false;
	    });
	});
	
	
	function hideWarning() {
	    localStorage.setItem('warningShownYear', 'shown');
	    warning.removeClass('_shown');
	}

/***/ })
/******/ ])));
//# sourceMappingURL=bundle.js.map